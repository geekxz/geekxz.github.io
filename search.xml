<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java IO 知识整理</title>
      <link href="/2018/11/05/hou-duan/java/java-io-zhi-shi-zheng-li/"/>
      <url>/2018/11/05/hou-duan/java/java-io-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="各IO类关系梳理"><a href="#各IO类关系梳理" class="headerlink" title="各IO类关系梳理"></a>各IO类关系梳理</h2><ul><li>InputStream: Java IO中的顶级的字节输入流的抽象类，定义了最基础的输入、读取的相关方法。实现了<code>Closeable</code>接口。<ul><li>FileInputStream: 继承自<code>InputStream</code>的文件输入流类，用于从本地文件中读取字节数据。</li><li>ByteArrayInputStream: 继承自<code>InputStream</code>的字节数组输入流类，它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而 ByteArrayInputStream 本质就是通过字节数组来实现的。InputStream通过<code>read()</code>向外提供接口，供它们来读取字节数据；而 ByteArrayInputStream 的内部额外的定义了一个计数器，它被用来跟踪<code>read()</code>方法要读取的下一个字节。</li><li>StringBufferInputStream: 继承自<code>InputStream</code>的字节输入流类，其中读取的字节由字符串的内容提供的输入流。该类已过时，不推荐使用，由 StringReader 代替。</li><li>PipedInputStream: 继承自<code>InputStream</code>的管道输入流类，在使用管道通信时，必须与 PipedOutputStream 配合使用。让多线程可以通过管道进行线程间的通讯。</li><li>ObjectInputStream: 继承自<code>InputStream</code>的对象输入流类，实现了 ObjectInput 和 ObjectStreamConstants 接口。作用是从输入流中读取Java对象和基本数据。只有支持 Serializable  或 Externalizable 接口的对象才能被<code>ObjectInputStream/ObjectOutputStream</code>所操作！</li><li>SequenceInputStream: 继承自<code>InputStream</code>的输入合并流类。SequenceInputStream 会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。合并流的作用是将多个源合并合一个源。</li><li>AudioInputStream: 继承自<code>InputStream</code>的音频输入流类。音频输入流是具有指定音频格式和长度的输入流。长度用示例帧表示，不用字节表示。提供几种方法，用于从流读取一定数量的字节，或未指定数量的字节。音频输入流跟踪所读取的最后一个字节。可以跳过任意数量的字节以到达稍后的读取位置。音频输入流可支持标记。设置标记时，会记住当前位置，以便可以稍后返回到该位置。</li><li>FilterInputStream: 继承自<code>InputStream</code>的过滤输入流类（装饰器超类），是用来“封装其它的输入流，并为它们提供额外的功能”。<ul><li>BufferedInputStream: 继承自<code>FilterInputStream</code>的带缓冲区功能的输入流类（装饰器子类），默认缓冲区大小是8K，能够减少访问磁盘的次数，提高文件读取性能。</li><li>DataInputStream: 继承自<code>FilterInputStream</code>的数据输入流类，实现了 DataInput 接口。它允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。</li><li>PushbackInputStream: 继承自<code>FilterInputStream</code>的回退输入流类。允许试探性的读取数据流，如果不是我们想要的则返还回去。</li><li>LineNumberInputStream: 继承自<code>FilterInputStream</code>的行号输入流类。可以获取当前的行号或设置当前行号，已过时，已经被 LineNumberReader 替代。</li><li>CheckedInputStream: 继承自<code>FilterInputStream</code>的校验输入流类。</li><li>CipherInputStream: 继承自<code>FilterInputStream</code>的密钥输入流类。</li><li>DigestInputStream: 继承自<code>FilterInputStream</code>的摘要处理输入流类。</li><li>InflaterInputStream: 继承自<code>FilterInputStream</code>的解压缩处理输入流类。<ul><li>GZIPInputStream: 继承自<code>InflaterInputStream</code>的gzip文件处理输入流类。</li><li>ZipInputStream: 继承自<code>InflaterInputStream</code>的解压缩处理输入流类。<ul><li>JarInputStream: 继承自<code>ZipInputStream</code>的解压缩处理输入流类。</li></ul></li></ul></li><li>DeflaterInputStream: 继承自<code>FilterInputStream</code>的压缩数据输入流类。</li><li>ProgressMonitorInputStream: 继承自<code>FilterInputStream</code>的进度监控输入流类。</li></ul></li></ul></li><li>OutputStream: JavaIO中的顶级的字节输出流的抽象类，定义了最基础的输出、写入的相关方法。实现了<code>Closeable</code>和<code>Flushable</code>接口。<ul><li>FileOutputStream: 继承自<code>OutputStream</code>的文件输出流类，用于向本地文件中写入字节数据。</li><li>ByteArrayOutputStream: 继承自<code>OutputStream</code>的字节数组输出流类，ByteArrayOutputStream 中的数据会被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</li><li>PipedOutputStream: 继承自<code>OutputStream</code>的管道输出流类，在使用管道通信时，必须与 PipedInputStream 配合使用。让多线程可以通过管道进行线程间的通讯。</li><li>ObjectOutputStream: 继承自<code>OutputStream</code>的对象输出流类，实现了 ObjectOutput 和 ObjectStreamConstants 接口。作用是把Java对象和基本数据写入到对象输出流中。只有支持 Serializable  或 Externalizable 接口的对象才能被<code>ObjectInputStream/ObjectOutputStream</code>所操作！</li><li>FilterOutputStream: 继承自<code>OutputStream</code>的过滤输出流类，是用来“封装其它的输出流，并为它们提供额外的功能”。<ul><li>BufferedOutputStream: 继承自<code>FilterOutputStream</code>的带缓冲区功能的输出流类，默认缓冲区大小是8K，能够提高文件的写入效率。</li><li>DataOutputStream: 继承自<code>FilterOutputStream</code>的数据输出流类，实现了 DataOutput 接口。它允许应用程序以与机器无关方式向底层输入流中写入基本 Java 数据类型。</li><li>PrintStream: 继承自<code>FilterOutputStream</code>的打印输出流类，实现了 Appendable 和 Closeable 接口。使它们能够方便地打印各种数据值表示形式。PrintStream 永远不会抛出 IOException。PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</li><li>CheckedOutputStream: 继承自<code>FilterOutputStream</code>的校验输出流类。</li><li>CipherOutputStream: 继承自<code>FilterOutputStream</code>的密钥输出流类。</li><li>DigestOutputStream: 继承自<code>FilterOutputStream</code>的摘要处理输出流类。</li><li>InflaterOutputStream: 继承自<code>FilterOutputStream</code>的解压缩处理输出流类。</li><li>DeflaterOutputStream: 继承自<code>FilterOutputStream</code>的解压缩数据输出流类。<ul><li>GZIPOutputStream: 继承自<code>DeflaterOutputStream</code>的gzip文件解压缩输出流类。</li><li>ZipOutputStream: 继承自<code>DeflaterOutputStream</code>的zip文件解压缩输出流类。<ul><li>JarOutputStream: 继承自<code>ZipOutputStream</code>的zip文件解压缩输出流类。</li></ul></li></ul></li></ul></li></ul></li><li>Reader: JavaIO中的顶级的字符读取的抽象类，定义了最基础的读取方法。实现了 Readable 和 Closeable 接口。<ul><li>BufferedReader: 继承自<code>Reader</code>的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。创建 BufferReader 时，我们会通过它的构造函数指定某个 Reader 为参数。BufferReader 会将该 Reader 中的数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从 Reader 中读取下一部分的数据。<ul><li>LineNumberReader: 继承自<code>BufferedReader</code>，可以获取当前的行号或设置当前行号。</li></ul></li><li>InputStreamReader: 继承自<code>Reader</code>，用于将从字节流转换成字符流的 Reader。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。<ul><li>FileReader: 继承自<code>InputStreamReader</code>，用来读取字符文件的便捷类。</li></ul></li><li>StringReader: 继承自<code>Reader</code>，用于字符串读取的字符流。</li><li>CharArrayReader: 继承自<code>Reader</code>的字符数组输入流类。</li><li>FilterReader: 继承自<code>Reader</code>的字符过滤输入流抽象类。<ul><li>PushbackReader: 继承自<code>FilterReader</code>的字符回退输入流类。</li></ul></li><li>PipedReader: 继承自<code>Reader</code>的字符管道输入流类。作用是可以通过管道进行线程间的通讯。必须和 PipedWriter 配合使用。</li></ul></li><li>Writer: JavaIO中的顶级的字符写入的抽象类，定义了最基础的写入方法。实现了 Appendable 、 Closeable 和 Flushable 接口。<ul><li>BufferedWriter: 继承自<code>Writer</code>的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输出流中写入字符到文本中，缓冲各个字符，从而实现字符、数组和行的高效写入。</li><li>OutputStreamWriter: 继承自<code>Reader</code>，用于将从字节流转换成字符流的 Writer。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。<ul><li>FileWriter: 继承自<code>OutputStreamWriter</code>，用来向文件中写入字符的便捷类。</li></ul></li><li>FilterWriter: 继承自<code>Writer</code>的字符过滤输出流抽象类。与 FilterOutputStream 功能一样、只是简单重写了父类的方法、目的是为所有装饰类提供标准和基本的方法、要求子类必须实现核心方法、和拥有自己的特色。这里 FilterWriter 没有子类、可能其意义只是提供一个接口、留着以后的扩展，本身是一个抽象类。</li><li>StringWriter: 继承自<code>Writer</code>，用于字符串写入的字符流。</li><li>PipedWriter: 继承自<code>Writer</code>的字符管道输出流类。作用是可以通过管道进行线程间的通讯。必须和 PipedReader 配合使用。</li><li>CharArrayWriter: 继承自<code>Writer</code>的字符数组输出流类。</li><li>PrintWriter: 继承自<code>Writer</code>的打印写入类，提供了PrintStream的所有打印方法，其方法也从不抛出IOException。与PrintStream的区别：作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream类型的字节流，还能够封装Writer类型的字符输出流并增强其功能。</li></ul></li></ul><p><img src="http://static.blinkfox.com/Javaio_mind_all.png" alt="Java IO Mind"></p><h2 id="IO-UML类图"><a href="#IO-UML类图" class="headerlink" title="IO UML类图"></a>IO UML类图</h2><p><img src="http://static.blinkfox.com/java_inputstream_uml.png" alt="Java InputStream UML"></p><p><img src="http://static.blinkfox.com/java_outputstream_uml.png" alt="Java OutputStream UML"></p><p><img src="http://static.blinkfox.com/java_reader_uml.png" alt="Java Reader UML"></p><p><img src="http://static.blinkfox.com/java_writer_uml.png" alt="Java Writer UML"></p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul><li>字节流和字符流：<ul><li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。</li><li>字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。</li></ul></li><li>输出流和输入流：<ul><li>输入流：从文件读入到内存。只能进行读操作。</li><li>输出流：从内存读出到文件。只能进行写操作。</li></ul></li><li>节点流和处理流：<ul><li>节点流：直接与数据源相连，读入或读出。</li><li>处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul></li></ul><blockquote><p><strong>注</strong>：输入输出流中的入和出，都是相对于系统内存而言的。为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。</p></blockquote><p><img src="http://static.blinkfox.com/javaio_mind_optype.png" alt="流按类型分类"></p><p><img src="http://static.blinkfox.com/javaio_mind_object.png" alt="流按用途分类"></p><h2 id="流中主要方法梳理"><a href="#流中主要方法梳理" class="headerlink" title="流中主要方法梳理"></a>流中主要方法梳理</h2><h3 id="InputStream中的主要方法"><a href="#InputStream中的主要方法" class="headerlink" title="InputStream中的主要方法"></a>InputStream中的主要方法</h3><ul><li><code>abstract int read()</code>: 从流中读取数据，读取一个字节，返回值为所读得字节</li><li><code>int read(byte b[])</code>: 从流中读取数据，读取多个字节，放置到字节数组 b 中，通常读取的字节数量为 b 的长度，返回值为实际独取的字节的数量。</li><li><code>int read(byte b[], int off, int len)</code>: 从流中读取数据，读取 len 个字节，放置到以下标 off 开始字节数组 b 中，返回值为实际读取的字节的数量。</li><li><code>long skip(long n)</code>: 读指针跳过n个字节不读，返回值为实际跳过的字节数量。</li><li><code>int available()</code>: 返回值为流中尚未读取的字节的数量。</li><li><code>void close()</code>: 关闭输入流。</li><li><code>synchronized void mark(int readlimit)</code>: 记录当前指针的所在位置，<code>readlimit</code>表示读指针读出的<code>readlimit</code>个字节后，所标记的指针位置才实效。</li><li><code>synchronized void reset()</code>: 把读指针重新指向用 mark 方法所记录的位置。</li><li><code>boolean markSupported()</code>: 当前的流是否支持读指针的记录功能。</li></ul><blockquote><p><strong>注</strong>：其中<code>read()</code>返回的是读入的一个字节所对应的 int 值(0-255),而<code>read(byte[] b)</code>和<code>read(byte[] b, int off, int len)</code>返回的是读入的字节数。</p></blockquote><h3 id="OutputStream中的主要方法"><a href="#OutputStream中的主要方法" class="headerlink" title="OutputStream中的主要方法"></a>OutputStream中的主要方法</h3><ul><li><code>abstract void write(int b)</code>: 输出数据，往流中写一个字节 b。</li><li><code>void write(byte b[])</code>: 输出数据，往流中写一个字节数组 b。</li><li><code>void write(byte b[], int off, int len)</code>: 输出数据，把字节数组 b 中从下标 off 开始，长度为 len 的字节写入到流中。</li><li><code>void flush()</code>: 刷空输出流，并输出所有被缓存的字节。由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li><li><code>void close()</code>: 关闭输出流。</li></ul><h3 id="Reader中的主要方法"><a href="#Reader中的主要方法" class="headerlink" title="Reader中的主要方法"></a>Reader中的主要方法</h3><ul><li><code>int read(java.nio.CharBuffer target)</code>: 试图读取字符入指定的字符缓冲区。</li><li><code>int read()</code>: 读取单个字符。</li><li><code>int read(char cbuf[])</code>: 读取字符到一个数组中。</li><li><code>int read(char cbuf[], int off, int len)</code>: 读取字符到一个数组中的一部分。</li><li><code>long skip(long n)</code>: 跳过n个字符。</li><li><code>boolean ready()</code>: 通知此流是否已准备好被读取。</li><li><code>boolean markSupported()</code>: 告诉此流是否支持<code>mark()</code>操作。</li><li><code>void mark(int readAheadLimit)</code>: 标记流中的当前位置。</li><li><code>void reset()</code>: 重置流。</li><li><code>void close()</code>: 关闭该流并释放与之关联的所有系统资源。</li></ul><h3 id="Writer中的主要方法"><a href="#Writer中的主要方法" class="headerlink" title="Writer中的主要方法"></a>Writer中的主要方法</h3><ul><li><code>void write(int c)</code>: 写入单个字符。</li><li><code>void write(char cbuf[])</code>: 写入字符数组。</li><li><code>abstract void write(char cbuf[], int off, int len)</code>: 写入字符数组的一部分。</li><li><code>void write(String str)</code>: 写入一个字符串。</li><li><code>void write(String str, int off, int len)</code>: 写入一个字符串的一部分。</li><li><code>Writer append(CharSequence csq)</code>: 将指定的字符序列追加写到writer中。</li><li><code>Writer append(CharSequence csq, int start, int end)</code>: 将指定的字符序列的子序列追加写入此writer。</li><li><code>Writer append(char c)</code>: 将指定字符追加到这个writer。</li><li><code>abstract void flush()</code>: 刷新流。</li><li><code>abstract void close()</code>: 关闭流，但要先刷新它。</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="FileInputStream-和-FileOutputStream"><a href="#FileInputStream-和-FileOutputStream" class="headerlink" title="FileInputStream 和 FileOutputStream"></a>FileInputStream 和 FileOutputStream</h3><pre><code class="java">/** * 测试复制文件a.txt中的内容到b.txt文件中. */private static void testCopyByFileStream() {    try (        InputStream in = new FileInputStream(&quot;G:/test/a.txt&quot;);        OutputStream out = new FileOutputStream(&quot;G:/test/b.txt&quot;, true)    ) {        int len;        byte[] b = new byte[1024];        while ((len = in.read(b)) != -1) {            out.write(b, 0, len);        }    } catch (IOException e) {        log.error(&quot;文件读取写入失败!&quot;, e);    }}</code></pre><h3 id="BufferedInputStream-和-BufferedOutputStream"><a href="#BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="BufferedInputStream 和 BufferedOutputStream"></a>BufferedInputStream 和 BufferedOutputStream</h3><pre><code class="java">/** * 测试通过 BufferedInputStream 和 BufferedOutputStream 来复制文件a.txt中的内容到b.txt文件中. */private static void testCopyByBufferedStream() {    try (        InputStream in = new BufferedInputStream(new FileInputStream(&quot;G:/test/a.txt&quot;));        OutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;G:/test/b.txt&quot;))    ) {        int len;        byte[] b = new byte[1024];        while ((len = in.read(b)) != -1) {            out.write(b, 0, len);        }    } catch (IOException e) {        log.error(&quot;通过缓冲区的方式来做文件读取写入失败!&quot;, e);    }}</code></pre><h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><pre><code class="java">/** * 测试将内容写入到ByteArrayOutputStream中并打印出来，不需要关闭流. */private static void testByByteArrayStream() {    ByteArrayOutputStream byteOut = new ByteArrayOutputStream(8);    String str = &quot;Hello World!&quot;;    try {        byteOut.write(str.getBytes());    } catch (IOException e) {        log.error(&quot;写入字节数据出错!&quot;, e);    }    byte[] buf = byteOut.toByteArray();    for (byte b : buf) {        log.info(&quot;{}&quot;, (char) b);    }}</code></pre><h3 id="PipedInputStream-和-PipedOutputStream"><a href="#PipedInputStream-和-PipedOutputStream" class="headerlink" title="PipedInputStream 和 PipedOutputStream"></a>PipedInputStream 和 PipedOutputStream</h3><pre><code class="java">/** * 发送消息的线程. * * @author blinkfox on 2017/10/19. */public class Sender extends Thread {    private static final Logger log = LoggerFactory.getLogger(Sender.class);    /** 管道输出流对象,它和管道输入流(PipedInputStream)对象绑定.从而可以将数据发送给“管道输入流”. */    private PipedOutputStream pipedOut;    public Sender(PipedOutputStream pipedOut) {        this.pipedOut = pipedOut;    }    public PipedOutputStream getPipedOut() {        return pipedOut;    }    @Override    public void run() {        String strInfo = &quot;Hello World!&quot; ;        try {            pipedOut.write(strInfo.getBytes());            pipedOut.close();        } catch (IOException e) {            log.error(&quot;向管道中写入数据出错!&quot;, e);        }    }}</code></pre><pre><code class="java">/** * 接收消息的线程. * * @author blinkfox on 2017/10/19. */public class Receiver extends Thread {    private static final Logger log = LoggerFactory.getLogger(Receiver.class);    /** 管道输入流对象,它和管道输出流(PipedOutputStream)对象绑定.从而可以接收“管道输出流”的数据. */    private PipedInputStream pipedIn;    public Receiver(PipedInputStream pipedIn) {        this.pipedIn = pipedIn;    }    public PipedInputStream getPipedIn() {        return pipedIn;    }    @Override    public void run() {        byte[] buf = new byte[2048];        try {            int len = pipedIn.read(buf);            log.info(&quot;{}&quot;, new String(buf, 0, len));            pipedIn.close();        } catch (IOException e) {            log.error(&quot;从管道中读取数据出错!&quot;, e);        }    }}</code></pre><pre><code class="java">/** * PipedInputStream 和 PipedOutputStream 的测试类. * * @author blinkfox on 2017/10/19. */public class PipedStreamTest {    private static final Logger log = LoggerFactory.getLogger(PipedStreamTest.class);    /**     * 主入口方法.     * @param args 字符串数组参数     */    public static void main(String[] args) {        Sender sender = new Sender(new PipedOutputStream());        Receiver receiver = new Receiver(new PipedInputStream());        try {            // 将管道输入流和管道的输出流进行连接.            receiver.getPipedIn().connect(sender.getPipedOut());            // 启动线程            sender.start();            receiver.start();        } catch (IOException e) {            log.info(&quot;发送接收消息出错!&quot;, e);        }    }}</code></pre><h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><pre><code class="java">/** * 测试使用 testBySequenceStream 合并输入流来统一读取写入. */private static void testBySequenceStream() {    try (        InputStream in1 = new FileInputStream(&quot;G:/test/a.txt&quot;);        InputStream in2 = new FileInputStream(&quot;G:/test/b.txt&quot;);        OutputStream out = new FileOutputStream(&quot;G:/test/c.txt&quot;);        SequenceInputStream seqIn = new SequenceInputStream(in1, in2)    ) {        int len = 0;        while ((len = seqIn.read()) != -1) {            out.write(len);        }    } catch (IOException e) {        log.error(&quot;合并输入流写入失败!&quot;, e);    }}</code></pre><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><pre><code class="java">/** * 测试使用 PrintStream 将数据输出到指定的文件. */private static void testOutputByPrintStream() {    System.out.println(&quot;Hello World!&quot;);    File file = new File(&quot;G:/test/d.txt&quot;);    try {        System.setOut(new PrintStream(new FileOutputStream(file)));    } catch (FileNotFoundException e) {        e.printStackTrace();    }    System.out.println(&quot;这些内容在文件中才能看到哦！&quot;);}</code></pre><h2 id="遵循的设计原则"><a href="#遵循的设计原则" class="headerlink" title="遵循的设计原则"></a>遵循的设计原则</h2><ul><li>单一职责原则：每一个IO类的都具有单独的功能和职责，需要对某种类型的流做修改时，只需要修改具体对应的IO流类即可。</li><li>里氏替换原则：子类完全实现了父类的方法，且有自己的个性，子类覆盖或实现父类的方法时输入参数和返回结果的范围没有变化。</li><li>接口隔离原则：输入输出流所实现的接口有所不同，而且接口比较细化，接口中的方法少。</li><li>依赖倒置原则：Java IO中的各个具体的功能类，都继承或聚合了<code>InputStream/OutputStream</code>的抽象类，都共同依赖了抽象，而不是依赖了某个具体的功能的IO类。</li><li>开闭原则：当用户需要新增一种新特征、新方式的IO流时，可以直接新增一种类的流，让其继承或聚合<code>InputStream/OutputStream/FilterInputStream/FilterOutputStream</code>等类，从而来书写其特有的功能，减少。</li><li>聚合/组合复用原则：就比如<code>FileInputStream</code>中对<code>FileDescriptor</code>和<code>FileChannel</code>的使用，都是采用了聚合的方式，而非继承的方式，从而使类之间的耦合度降低，提高了灵活性。</li></ul><h2 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h2><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>由于java I/O库需要很多性能的各种组合，如果这些性能都是用继承来实现，那么每一种组合都需要一个类，这样就会造成大量行重复的类出现。如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是java I/O库基本模式。装饰模式的引进，造成灵活性和复杂性的提高。因此在使用java IO库时，必须理解java IO库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的。</p><p>以字节输入流为例。<code>InputStream</code>是需要被装饰的抽象构件，而其下的<code>FileInputStream</code>、<code>ByteArrayInputStream</code>等是被装饰的具体构件；<code>FilterInputStream</code>是装饰器的父类，<code>BufferedInputStream</code>、<code>DataInputStream</code>则是具体的装饰器类。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式是java IO库中第二个重要的设计模式。如：<code>StringBufferInputStream</code>就是一个适配器类。它继承了<code>InputStream</code>类型，同时持有一个对<code>String</code>类型的引用。这是将<code>String</code>对象适配成<code>InputStream</code>类型的对象形式的适配器模式。<code>PipedOutputStream</code>也是一个适配器类。<code>PipedOutputStream</code>总是和<code>PipedInputStream</code>一起使用，它接收一个类型为<code>PipedInputStream</code>的输入类型，并将之转换成<code>OutputStream</code>类型的输出流，这是一个对象形式的适配器模式应用。</p><h2 id="设计的优缺点"><a href="#设计的优缺点" class="headerlink" title="设计的优缺点"></a>设计的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>功能全面、强大和灵活，同时还防止了过多的类膨胀</li><li>符合开闭原则，开发可以通过各种装配能实现各种功能</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>复杂难记，API使用繁琐。如：<code>Jdk1.6</code>中，从文本文件中读取数据转换为字符串，就得至少10行代码。</li><li>IO流中的绝大多数方法都有<code>IOException</code>的检查异常，导致开发人员不得不在各个使用到的地方捕捉或再抛出异常，代码繁琐，不符合当前的主流设计思路。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之责任链模式</title>
      <link href="/2018/11/04/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ze-ren-lian-mo-shi/"/>
      <url>/2018/11/04/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ze-ren-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>定义</strong>：责任链模式(<code>Chain of Responsibility Pattern</code>)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。</p></blockquote><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Handler</code>（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(<code>nextHandler</code>)作为其对下家的引用，以便将处理者链成一条链；</li><li><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。</li></ul><p>在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。<strong>发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</strong>。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/chain_of_responsibility.png" alt="责任链模式UML类图"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为<strong>抽象类</strong>，其典型实现代码如下所示：</p><pre><code class="java">/** * 责任连模式的抽象处理者角色. * * Created by blinkfox on 16/7/11. */public abstract class Handler {    /** 后继处理者角色. */    protected Handler nextHandler;    /**     * 处理请求的抽象方法.     *     * @param condition 条件     */    public abstract void handle(String condition);    /**     * nextHandler的Setter方法.     *     * @param nextHandler 后继处理器     */    public void setNextHandler(Handler nextHandler) {        this.nextHandler = nextHandler;    }}</code></pre><p>其次，是若干个具体的处理角色类。</p><pre><code class="java">/** * 具体处理角色1. * * Created by blinkfox on 16/7/11. */public class ConcreteHandler1 extends Handler {    /**     * 具体处理角色1的处理方法.     *     * @param condition 条件     */    @Override    public void handle(String condition) {        // 如果是自己的责任，就自己处理，负责传给下家处理        if (&quot;ConcreteHandler1&quot;.equals(condition)) {            System.out.println( &quot;具体处理角色1的处理方法handled1...&quot;);        } else {            System.out.println( &quot;具体处理角色1 通过...&quot;);            nextHandler.handle(condition);        }    }}</code></pre><pre><code class="java">/** * 具体处理角色2. * * Created by blinkfox on 16/7/11. */public class ConcreteHandler2 extends Handler {    /**     * 具体处理角色2的处理方法.     *     * @param condition 条件     */    @Override    public void handle(String condition) {        // 如果是自己的责任，就自己处理，负责传给下家处理        if (&quot;ConcreteHandler2&quot;.equals(condition)) {            System.out.println( &quot;具体处理角色2的处理方法handled1...&quot;);        } else {            System.out.println( &quot;具体处理角色2 通过...&quot;);            nextHandler.handle(condition);        }    }}</code></pre><pre><code class="java">/** * 具体处理角色n. * * Created by blinkfox on 16/7/11. */public class ConcreteHandlerN extends Handler {    /**     * 这里假设n是链的最后一个节点必须处理掉.     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.     *     * @param condition 参数条件     */    @Override    public void handle(String condition) {        System.out.println( &quot;具体处理角色n的处理方法 结束...&quot;);    }}</code></pre><p>最后，是客户端场景类，代码调用示例如下：</p><pre><code class="java">/** * 责任连模式的客户端场景类. * * Created by blinkfox on 16/7/11. */public class ChainClient {    /**     * 主入口方法.     *     * @param args 数组参数     */    public static void main(String[] args) {        Handler handler1 = new ConcreteHandler1();        Handler handler2 = new ConcreteHandler2();        Handler handlern = new ConcreteHandlerN();        handler1.setNextHandler(handler2);        handler2.setNextHandler(handlern);        //假设这个请求是ConcreteHandler2的责任        handler1.handle(&quot;ConcreteHandler2&quot;);    }}</code></pre><blockquote><p><strong>注</strong>：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。</p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><ul><li><strong>纯的责任链模式</strong>要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；</li><li>在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；</li><li>在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li></ul><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；</li><li>简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；</li><li>可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；</li><li>职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；</li><li>增加新的请求处理类很方便。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；</li><li>该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript之再学习</title>
      <link href="/2018/10/30/qian-duan/javascript-zhi-zai-xue-xi/"/>
      <url>/2018/10/30/qian-duan/javascript-zhi-zai-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>JavaScript 是一种面向对象的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。需要注意的一个主要区别是 JavaScript 不支持类，类这一概念在 JavaScript 通过对象原型（object prototype）得到延续。另一个主要区别是 JavaScript 中的函数也是对象，JavaScript 允许函数在包含可执行代码的同时，能像其他对象一样被传递。</p><h2 id="数据类型和结构"><a href="#数据类型和结构" class="headerlink" title="数据类型和结构"></a>数据类型和结构</h2><h3 id="1-动态类型"><a href="#1-动态类型" class="headerlink" title="1. 动态类型"></a>1. 动态类型</h3><p><code>JavaScript</code>是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p><pre><code class="javascript">var foo = 42;    // foo is a Number nowvar foo = &quot;bar&quot;; // foo is a String nowvar foo = true;  // foo is a Boolean now</code></pre><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><p>最新的<code>ECMAScript</code>标准定义了 7 种数据类型:</p><ul><li>6 种原始类型<ul><li><code>Null</code> (空, 只有一个值<code>null</code>)</li><li><code>Undefined</code> (未定义, 一个没有被赋值的变量的默认值是<code>undefined</code>):</li><li><code>Boolean</code> (布尔, 可以有两个值：<code>true</code> 和 <code>false</code>)</li><li><code>Number</code> (数字)</li><li><code>String</code> (字符串)</li><li><code>Symbol</code> (符号, ECMAScript 6 新定义的类型，表示独一无二的值)</li></ul></li><li>和 <code>Object</code> (对象)<ul><li><code>Function</code> (函数)</li><li><code>Array</code> (数组)</li><li><code>Date</code> (日期)</li><li><code>JSON</code> (JS对象标识,来序列化对象、数组、数值、字符串、布尔值和 <code>null</code>)</li><li><code>Math</code> (数学方面的计算)</li><li><code>RegExp</code> (正则表达式)</li><li><code>Error</code> (错误)</li><li><code>Map</code></li><li><code>Set</code></li></ul></li></ul><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>这里的<strong>内置对象</strong>指的是在全局作用域(<code>global scope</code>)中的对象，由于很多，不再一一列出说明，更全面的解释在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">这里</a>。</p><p>全局对象本身可通过<code>this</code>操作符在全局作用域中获得。实际上，全局作用域就是由全局对象的各个属性组成的（包括继承来的属性）。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（<code>strict mode</code>）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p><p>严格模式可以应用到整个script标签或个别函数中。设立”严格模式”的目的，主要有以下几个：</p><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><h3 id="为某个script标签开启严格模式"><a href="#为某个script标签开启严格模式" class="headerlink" title="为某个script标签开启严格模式"></a>为某个script标签开启严格模式</h3><p>进入严格模式的标志，是下面这行语句：</p><pre><code class="javascript">&#39;use strict&#39;</code></pre><h3 id="为某个函数开启严格模式"><a href="#为某个函数开启严格模式" class="headerlink" title="为某个函数开启严格模式"></a>为某个函数开启严格模式</h3><pre><code class="javascript">function strict(){  // 函数级别严格模式语法  &#39;use strict&#39;;  return &quot;I&#39;m a strict mode function!  &quot; + nested();}function notStrict() {    return &quot;I&#39;m not strict.&quot;;}</code></pre><h2 id="相等性判断"><a href="#相等性判断" class="headerlink" title="相等性判断"></a>相等性判断</h2><p>JavaScript提供三种不同的值比较操作：</p><ul><li>严格相等 (“triple equals” 或 “identity”)，使用<code>===</code></li><li>宽松相等 (“double equals”) ，使用<code>==</code></li><li>以及<code>Object.is</code> (ECMAScript 2015/ ES6 新特性)</li></ul><p>简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false );  而<code>Object.is</code>的行为方式与三等号相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同，而<code>Object.is(NaN，NaN)</code>将为 true。</p><p><img src="http://static.blinkfox.com/js_equals.png" alt="各原始类型值的相等比较对照表"></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有<strong>全局作用域</strong>和<strong>局部作用域</strong>两种。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域。一般来说以下几种情形：</p><ul><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域。</li><li>所有未定义而直接赋值的变量自动声明为拥有全局作用域。</li><li>所有window对象的属性拥有全局作用域。如：<code>window.name</code>、<code>window.location</code>等。</li></ul><blockquote><p><strong>注</strong>：全局变量存在于程序的整个生命周期。没有块级作用域。</p></blockquote><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>局部作用域一般只在固定的代码片段内可访问到，最常见的是在函数内部，所有在一些地方也会看到有人把这种作用域称为<strong>函数作用域</strong>。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是<code>Scope</code>，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p><p>因为全局变量总是存在于<strong>运行时上下文</strong>作用域链的最末端。所以，在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：<strong>如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用</strong>。</p><p><code>with</code>语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。</p><pre><code class="javascript">person = {name: &quot;yhb&quot;, age: 22, height:175, wife: {name: &quot;lwy&quot;, age: 21}};with (person.wife) {    console.log(name);}</code></pre><p>with语句将<code>person.wife</code>添加到当前作用域链的头部，所以输出的就是：<code>lwy</code>；with语句结束后，作用域链恢复正常。</p><blockquote><p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。<br><strong>注</strong>：在程序中应避免使用with语句。</p></blockquote><h2 id="闭包-Closures"><a href="#闭包-Closures" class="headerlink" title="闭包(Closures)"></a>闭包(Closures)</h2><h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>如何从外部读取局部变量？</p><pre><code class="javascript">function f1() {    var n=999;    function f2() {        alert(n); // 999    }}</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（<code>chain scope</code>），子对象会一级一级地向上寻找所有父对象的变量。所以，<strong>父对象的所有变量，对子对象都是可见的，反之则不成立</strong>。</p><p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p><pre><code class="javascript">function f1() {    var n=999;    function f2() {        alert(n); // 999    }    return f2;}var result=f1();result(); // 999</code></pre><h3 id="闭包解释"><a href="#闭包解释" class="headerlink" title="闭包解释"></a>闭包解释</h3><blockquote><p><strong>闭包定义</strong>：闭包是一个函数和函数所声明的词法环境的结合。</p></blockquote><p>在上面的代码中，f2函数就是闭包。<strong>闭包</strong>（<code>closure</code>）定义非常抽象，很难看懂。我的理解是，<strong>闭包就是能够读取其他函数内部变量的函数</strong>。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>闭包最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用结束后被垃圾回收机制（<code>garbage collection</code>）回收。</p><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><p>有时你想模拟一个模拟块级作用域，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做<code>IIFE</code>(立即执行函数表达式(<code>Immediately Invoked Function Expression</code>))：</p><pre><code class="javascript">(function () {  // 块开始    var tmp = ...;  // 非全局变量}());  // 块结束</code></pre><h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>JavaScript 并不提供原生的支持私有方法，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p><pre><code class="javascript">var Counter = (function() {    var privateCounter = 0;    function changeBy(val) {        privateCounter += val;    }    return {        increment: function() {            changeBy(1);        },        decrement: function() {            changeBy(-1);        },        value: function() {            return privateCounter;        }    }})();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */</code></pre><p>上面创建了一个环境，为三个函数所共享：<code>Counter.increment</code>, <code>Counter.decrement</code>和<code>Counter.value</code>。该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为<code>privateCounter</code>的变量和名为<code>changeBy</code>的函数。这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。</p><p><strong>注意</strong>：</p><ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ul><h2 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h2><p>首先JavaScript中的变量分为<strong>基本类型</strong>和<strong>引用类型</strong>。</p><ul><li>基本类型就是保存在栈内存中的简单数据段。基本类型有<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>。这些类型在内存中分别占有固定大小的空间，他们的值保存在<strong>栈空间</strong>，我们通过按值来访问的。</li><li>引用类型指的是那些保存在堆内存中的对象。引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。</li></ul><h3 id="为什么会有栈内存和堆内存之分？"><a href="#为什么会有栈内存和堆内存之分？" class="headerlink" title="为什么会有栈内存和堆内存之分？"></a>为什么会有栈内存和堆内存之分？</h3><p>与垃圾回收机制有关，为了使程序运行时占用的内存最小。</p><p>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；</p><p>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>Javascript具有自动垃圾回收机制(<code>GC</code>:<code>Garbage Collecation</code>)，也就是说，执行环境会负责管理代码执行过程中使用的内存。</p><p>JavaScript垃圾回收的机制很简单：<strong>找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行</strong>。</p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。</p><h4 id="清除方式"><a href="#清除方式" class="headerlink" title="清除方式"></a>清除方式</h4><ul><li><strong>标记清除</strong>：垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li><li><strong>引用计数</strong>：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype)"></a>原型(prototype)</h2><p>原型是一个对象，其他对象可以通过它实现属性继承。JavaScript的对象中都包含了一个<code>Prototype</code>内部属性，这个属性所对应的就是该对象的原型。<code>Prototype</code>作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了<code>__proto__</code>这个非标准的访问器。</p><ul><li>所有的对象都有<code>__proto__</code>属性，该属性对应着该对象的原型。</li><li>所有的函数对象都有<code>prototype</code>属性，该属性的值会被赋值给该函数创建的对象的<code>__proto__</code>属性</li><li>所有的原型对象都有<code>constructor</code>属性，该属性对应创建所有指向该原型的实例的构造函数</li><li>函数对象和原型对象通过<code>prototype</code>和<code>constructor</code>属性进行相互关联</li><li><code>Object</code>实例对象的原型<code>obj.__proto__</code>就是<code>Object.prototype</code></li><li><code>hasOwnProperty</code>是<code>Object.prototype</code>的一个方法，该方法能判断一个对象是否包含自定义属性而不是原型链上的属性，因为”hasOwnProperty” 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>因为每个对象和原型都有原型，对象的原型指向对象的父，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。</p><p>当通过原型链查找一个属性的时候，首先查找的是对象本身的属性，如果找不到才会继续按照原型链进行查找。这样一来，如果想要覆盖原型链上的一些属性，我们就可以直接在对象中引入这些属性，达到属性隐藏的效果。</p><h2 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h2><h3 id="1-Object构造函数方式"><a href="#1-Object构造函数方式" class="headerlink" title="1. Object构造函数方式"></a>1. Object构造函数方式</h3><pre><code class="javascript">var Person = new Object();Person.name = &#39;Nike&#39;;Person.age = 29;</code></pre><p>这行代码创建了<code>Object</code>引用类型的一个新实例，然后把实例保存在变量<code>Person</code>中。</p><h3 id="2-对象字面量方式"><a href="#2-对象字面量方式" class="headerlink" title="2. 对象字面量方式"></a>2. 对象字面量方式</h3><pre><code class="javascript">var Person = { name: &#39;Nike&#39;; age: 29;};</code></pre><p>对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性对象的过程。</p><blockquote><p><strong>注</strong>：前两种方法的缺点在于：它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码。那我们有什么方法来避免过多的重复代码呢，就是把创建对象的过程封装在函数体内，通过函数的调用直接生成对象。</p></blockquote><h3 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h3><pre><code class="javascript">function createPerson(name, age, job) {    var o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function() {        alert(this.name);    };    return o;}var person1 = createPerson(&#39;Nike&#39;, 29, &#39;teacher&#39;);</code></pre><p>在使用工厂模式创建对象的时候，我们都可以注意到，在<code>createPerson</code>函数中，返回的是一个对象。但我们就无法判断返回的对象究竟是一个什么样的类型。于是就出现了第四种创建对象的模式。</p><h3 id="4-构造函数方式"><a href="#4-构造函数方式" class="headerlink" title="4. 构造函数方式"></a>4. 构造函数方式</h3><pre><code class="javascript">function Person(name, age, job) {    this.name = name;    this.age = age;    this.job = job;    this.sayName = function() {        alert(this.name);    };}var person1 = new Person(&#39;Nike&#39;, 29, &#39;teacher&#39;);alert(person1 instanceof Object); //ture</code></pre><p>对比工厂模式，我们可以发现以下区别：</p><ul><li>没有显示地创建对象</li><li>直接将属性和方法赋给了<code>this</code>对象</li><li>没有<code>return</code>语句</li><li>终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符，我们来进行自主检测：</li></ul><p>那么构造函数确实挺好用的，但是它也有它的缺点：就是每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存。于是出现了第五种创建对象的方法。</p><h3 id="5-原型创建对象模式"><a href="#5-原型创建对象模式" class="headerlink" title="5. 原型创建对象模式"></a>5. 原型创建对象模式</h3><pre><code class="javascript">function Person(){}Person.prototype.name = &#39;Nike&#39;;Person.prototype.age = 20;Person.prototype.jbo = &#39;teacher&#39;;Person.prototype.sayName = function() {    alert(this.name);};var person1 = new Person();var person2 = new Person();person1.name = &#39;Greg&#39;;alert(person1.name); //&#39;Greg&#39; --来自实例alert(person2.name); //&#39;Nike&#39; --来自原型</code></pre><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。</p><p>这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><h3 id="6-组合使用构造函数模式和原型模式"><a href="#6-组合使用构造函数模式和原型模式" class="headerlink" title="6. 组合使用构造函数模式和原型模式"></a>6. 组合使用构造函数模式和原型模式</h3><pre><code class="javascript">function Person(name, age, job) {    this.name = name;    this.age = age;    this.job = job;}Person.prototype = {    constructor: Person,    sayName: function(){        alert(this.name);    };}var person1 = new Person(&#39;Nike&#39;, 20, &#39;teacher&#39;);</code></pre><h3 id="7-动态原型模式"><a href="#7-动态原型模式" class="headerlink" title="7. 动态原型模式"></a>7. 动态原型模式</h3><pre><code class="javascript">function Person(name, age, job) {    this.name = name;    this.age = age;    this.job = job;    if (typeof this.sayName != &#39;function&#39;) {        Person.prototype.sayName = function() {            alert(this.name);        }    }}var person1 = new Person(&#39;Nike&#39;, 20, &#39;teacher&#39;);person1.sayName();</code></pre><p>动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），这个可以通过判断该方法是否有效而选择是否需要初始化原型。</p><h3 id="8-寄生构造函数方式"><a href="#8-寄生构造函数方式" class="headerlink" title="8. 寄生构造函数方式"></a>8. 寄生构造函数方式</h3><pre><code class="javascript">function Person(name, age, job) {    var o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function() {        alert(this.name);    };    return o;}var person1 = new Person(&#39;Nike&#39;, 29, &#39;teacher&#39;);</code></pre><p>寄生模式和工厂模式几乎一样，寄生模式和工厂模式的区别：</p><ul><li>寄生模式创建对象时使用了<code>new</code>关键字</li><li>寄生模式的外部包装函数是一个构造函数</li></ul><blockquote><p><strong>作用</strong>:寄生模式可以在特殊的情况下为对象来创建构造函数,原因在于我们可以通过构造函数重写对象的值，并通过return返回。重写调用构造函数(创建的对象的实例)之后的对象实例的新的值。</p></blockquote><h3 id="9-稳妥构造函数方式"><a href="#9-稳妥构造函数方式" class="headerlink" title="9. 稳妥构造函数方式"></a>9. 稳妥构造函数方式</h3><pre><code class="javascript">function Person(name, age, job) {    var o = new Object();    o.sayName = function() {        alert(this.name);    };    return o;}var person = new Person(&#39;Nike&#39;, 29, &#39;teacher&#39;);person.sayName(); // 使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值</code></pre><p>道格拉斯·克拉克福德发明了JavaScript中的稳妥对象这个概念。所谓稳妥对象，是指没有公共属性，而且其方法也不引用<code>this</code>对象。稳妥对象最适合在一些安全环境中（这些环境会禁止使用<code>this</code>和<code>new</code>），或者在防止数据被其他应用程序改动时使用。稳妥构造函数遵循的与寄生构造函数类似的模式，但又两点不同：</p><ul><li>一是新创建对象的实例方法不引用<code>this</code>；</li><li>二是不使用<code>new</code>操作符调用构造函数。</li></ul><blockquote><p><strong>注</strong>：与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象也没有意义。</p></blockquote><h2 id="并发模型和事件循环-event-loop"><a href="#并发模型和事件循环-event-loop" class="headerlink" title="并发模型和事件循环(event loop)"></a>并发模型和事件循环(event loop)</h2><p>JavaScript 的并发模型基于<strong>事件循环</strong>。</p><p><img src="http://static.blinkfox.com/js_event.png" alt="Js堆栈队列图"></p><h3 id="1-运行时概念"><a href="#1-运行时概念" class="headerlink" title="1. 运行时概念"></a>1. 运行时概念</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>函数调用形成了一个栈帧。</p><pre><code class="javascript">function foo(b) {  var a = 10;  return a + b + 11;}function bar(x) {  var y = 3;  return foo(x * y);}console.log(bar(7));</code></pre><p>当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都与一个函数相关联。当栈拥有足够内存时，从队列中取出一个消息进行处理。这个处理过程包含了调用与这个消息相关联的函数（以及因而创建了一个初始堆栈帧）。当栈再次为空的时候，也就意味着消息处理结束。</p><h3 id="2-事件循环"><a href="#2-事件循环" class="headerlink" title="2. 事件循环"></a>2. 事件循环</h3><p>之所以称为<strong>事件循环</strong>，是因为它经常被用于类似如下的方式来实现：</p><pre><code class="javascript">while (queue.waitForMessage()) {  queue.processNextMessage();}</code></pre><p>如果当前没有任何消息，queue.waitForMessage 会等待着同步将要到来的消息。</p><p>每一个消息完整的执行后，其它消息才会被执行。这个模型的一个缺点在于当一个消息的完成耗时过长，网络应用无法处理用户的交互如点击或者滚动。浏览器用“程序需要过长时间运行”的对话框来缓解这个问题。一个比较好的解决方案是使消息处理变短且如果可能的话，将一个消息拆分成几个消息。</p><p>在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。</p><h3 id="3-绝不阻塞"><a href="#3-绝不阻塞" class="headerlink" title="3. 绝不阻塞"></a>3. 绝不阻塞</h3><p>事件循环(event loop)模型特性在于它<strong>永不阻塞</strong>。通常由事件或者回调函数进行 I/O (input/output)处理 。</p><hr><p>参考文档：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">MDN</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之单例模式</title>
      <link href="/2018/10/29/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dan-li-mo-shi/"/>
      <url>/2018/10/29/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>单例模式(<code>Singleton Pattern</code>)</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种<strong>对象创建型模式</strong>。单例模式又名单件模式或单态模式。</p></blockquote><p>单例模式的要点有三个：</p><ul><li>一是某个类只能有一个实例；</li><li>二是它必须自行创建这个实例；</li><li>三是它必须自行向整个系统提供这个实例。</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Singleton</code>: 单例</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_uml.jpg" alt="单例模式UML类图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h2><h3 id="1-饿汉式（推荐使用）"><a href="#1-饿汉式（推荐使用）" class="headerlink" title="1. 饿汉式（推荐使用）"></a>1. 饿汉式（推荐使用）</h3><pre><code class="java">/** * 饿汉式单例模式. * * @author blinkfox on 2017-10-23. */public class Singleton {    /** 全局唯一实例. */    private static final Singleton singleton = new Singleton();    private Singleton() {}    public static Singleton getSingleton() {        return singleton;    }}</code></pre><blockquote><p><strong>注</strong>：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="2-非线程安全懒汉式（不推荐使用）"><a href="#2-非线程安全懒汉式（不推荐使用）" class="headerlink" title="2. 非线程安全懒汉式（不推荐使用）"></a>2. 非线程安全懒汉式（不推荐使用）</h3><pre><code class="java">/** * 非线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */public class Singleton {    private static Singleton singleton;    private Singleton() {}    /**     * 通过懒加载的方式获取实例，但是非线程安全.     * @return Singleton实例     */    public static Singleton getSingleton() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，但非线程安全。不推荐使用。</p></blockquote><h3 id="3-低效的线程安全懒汉式（不推荐使用）"><a href="#3-低效的线程安全懒汉式（不推荐使用）" class="headerlink" title="3. 低效的线程安全懒汉式（不推荐使用）"></a>3. 低效的线程安全懒汉式（不推荐使用）</h3><pre><code class="java">/** * 低效的线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */public class Singleton {    private static Singleton singleton;    private Singleton() {}    /**     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */    public static synchronized Singleton getSingleton() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。</p></blockquote><h3 id="4-双重校验锁线程安全懒汉式（不推荐使用）"><a href="#4-双重校验锁线程安全懒汉式（不推荐使用）" class="headerlink" title="4. 双重校验锁线程安全懒汉式（不推荐使用）"></a>4. 双重校验锁线程安全懒汉式（不推荐使用）</h3><pre><code class="java">/** * 双重校验锁线程安全懒汉式. * * @author blinkfox on 2017-10-23. */public class Singleton {    private static Singleton singleton;    private Singleton() {}    /**     * 通过&#39;双重校验锁&#39;来更高效的保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */    public static Singleton getSingleton() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}</code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。</p></blockquote><h3 id="5-枚举式（强烈推荐使用）"><a href="#5-枚举式（强烈推荐使用）" class="headerlink" title="5. 枚举式（强烈推荐使用）"></a>5. 枚举式（强烈推荐使用）</h3><pre><code class="java">/** * 枚举方式的单例. * * @author blinkfox on 2017-10-23. */public enum Singleton {    INSTANCE;}</code></pre><blockquote><p><strong>注</strong>：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。</p></blockquote><h3 id="6-静态内部类（推荐使用）"><a href="#6-静态内部类（推荐使用）" class="headerlink" title="6. 静态内部类（推荐使用）"></a>6. 静态内部类（推荐使用）</h3><pre><code class="java">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author blinkfox on 2017-10-23. */public class Singleton {    private Singleton() {}    /**     * 静态内部类.     */    private static final class SingletonHolder {        private SingletonHolder() {}        private static Singleton4 instance = new Singleton();    }    /**     * 通过懒加载的方式获取Singleton唯一实例的方法.     * @return Singleton实例     */    public static Singleton getInstance() {        return SingletonHolder.instance;    }}</code></pre><blockquote><p><strong>注</strong>：这种方式利用了<code>ClassLoader</code>的机制保证初始化<code>instance</code>时只有一个线程，其只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java异常知识汇总</title>
      <link href="/2018/10/28/hou-duan/java/java-yi-chang-zhi-shi-hui-zong/"/>
      <url>/2018/10/28/hou-duan/java/java-yi-chang-zhi-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么要使用异常"><a href="#为什么要使用异常" class="headerlink" title="为什么要使用异常"></a>为什么要使用异常</h3><p>在我们的程序中，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p><ul><li>容易混淆。如果约定返回值为 -1 时表示出现异常，那么当程序最后的计算结果真的为 -1 呢？</li><li>代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。</li><li>由调用函数来分析异常，这要求程序员对库函数有很深的了解。</li></ul><blockquote><p>在面向对象编程中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。</p></blockquote><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><blockquote><p>异常情形是指阻止当前方法或者作用域继续执行的问题。——《Think in java》</p></blockquote><p>总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>在Java中，所有的事件都能由类描述，Java中的异常就是由<code>java.lang</code>包下的异常类来描述的。Java定义了一个异常类的层次结构，其以<code>Throwable</code>（万物即可抛）开始，派生出了<code>Error</code>和<code>Exception</code>，而<code>Exception</code>又派生出了<code>CheckedException</code>和<code>RuntimeException</code>。如下图所示：</p><p><img src="http://static.blinkfox.com/java_exception.png" alt="Java异常体系"></p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable（可抛出）是异常类的最终父类，它有两个子类，<code>Error</code>与<code>Exception</code>。</p><p>Throwable 中常用方法有：</p><ul><li><code>synchronized Throwable getCause()</code>：此方法返回异常产生的原因，如果不知道原因的话返回<code>null</code>。</li><li><code>String getMessage()</code>：方法返回<code>Throwable</code>的<code>String</code>型信息，当异常通过构造器创建后可用。</li><li><code>String getLocalizedMessage()</code>：此方法通过被重写来得到用本地语言表示的异常信息返回给调用程序。<code>Throwable</code>类通常只是用<code>getMessage()</code>方法来实现返回异常信息。</li><li><code>void printStackTrace()</code>：该方法打印栈轨迹信息到标准错误流。该方法能接受<code>PrintStream</code>和<code>PrintWriter</code>作为参数实现重载，这样就能实现打印栈轨迹到文件或流中。</li><li><code>String toString()</code>：方法返回<code>String</code>格式的<code>Throwable</code>信息，此信息包括<code>Throwable</code>的名字和本地化信息。</li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error（错误）：表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以 Error 不是<code>try-catch</code>的处理对象，而 JVM 一般的处理方式是终止发生错误的线程。Error 类常见子类有<code>VirtualMachineError</code>、<code>StackOverFlowError</code>、<code>OutOfMemoryError</code>等。</p><p>在Java运行时内存中，除程序计数器外的虚拟机栈、堆、方法区在请求的内存无法被满足时都会抛出<code>OutOfMemoryError</code>；而如果线程请求的栈深度超出虚拟机允许的深度时，就会抛出<code>StackOverFlowError</code>。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Exception（异常）：出现原因取决于程序，所以程序也理应通过<code>try-catch</code>处理。Exception 异常分为两类：<code>CheckedException</code>和<code>RuntimeException</code>，即<strong>检查异常</strong>与<strong>运行时异常</strong>。</p><ul><li>检查异常：编译器要求必须处理，否则不能通过编译，使用<code>try-catch</code>捕获或者<code>throws</code>抛出。常见的检查异常有<code>IOException</code>及其子类、<code>EOFExcption</code>(文件已结束异常)、<code>FileNotFoundException</code>（文件未找到异常）。</li><li>运行时异常（也叫非检查异常）：编译期不会检查，所以在程序中可不处理，但如果发生，会在运行时抛出。</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h3><p>在 Java 应用程序中，异常处理机制为：<strong>抛出异常</strong>、<strong>捕捉异常</strong>。</p><ul><li><strong>抛出异常</strong>：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li><li><strong>捕获异常</strong>：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li></ul><p>对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p><ul><li>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</li><li>对于所有的检查异常，Java规定：<strong>一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常</strong>。</li><li>对于所有运行时异常，Java规定：<strong>运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常</strong>。</li></ul><p>能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，<strong>一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的</strong>。</p><p>任何Java代码都可以通过 Java 的<code>throw</code>语句抛出异常。</p><p>从方法中抛出的任何异常都必须使用<code>throws</code>子句。</p><p>捕捉异常通过<code>try-catch</code>语句或者<code>try-catch-finally</code>语句实现。</p><blockquote><p>总体来说，Java规定：对于检查异常必须捕捉、或者声明抛出。允许忽略非检查的<code>RuntimeException</code>和<code>Error</code>。</p></blockquote><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p><code>try-catch</code>语句还可以包括第三部分，就是<code>finally</code>子句。它表示无论是否出现异常，都应当执行的内容。<code>try-catch-finally</code>语句的一般语法形式为：</p><pre><code class="java">try {    // 可能会发生异常的程序代码} catch (Exception1 e1) {    // 捕获并处理try抛出的异常类型Type1} catch (Exception2 e2) {    // 捕获并处理try抛出的异常类型Type2} finally {    // 无论是否发生异常，都将执行的语句块}</code></pre><p>Java7及之后的版本可这样使用：</p><pre><code class="java">try (MyResource mr = new MyResource()) {    System.out.println(&quot;MyResource created in try-with-resources&quot;);} catch (Exception1 | Exception2 e) {    // 捕获并统一处理 try 抛出的多种异常类型，不需要finally块}</code></pre><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个<code>catch</code>块，如果没有<code>catch</code>块，则必须跟一个<code>finally</code>块。</li><li><code>catch</code>块：用于处理<code>try</code>捕获到的异常。</li><li><code>finally</code>块：无论是否捕获或处理异常，<code>finally</code>块里的语句都会被执行。当在<code>try</code>块或<code>catch</code>块中遇到<code>return</code>语句时，<code>finally</code>语句块将在方法返回之前被执行。在以下 4 种特殊情况下，<code>finally</code>块不会被执行：<ul><li>在<code>finally</code>语句块中发生了异常</li><li>在前面的代码中用了<code>System.exit()</code>退出程序</li><li>程序所在的线程死亡</li><li>关闭<code>CPU</code></li></ul></li></ul><h3 id="异常处理语句的语法规则"><a href="#异常处理语句的语法规则" class="headerlink" title="异常处理语句的语法规则"></a>异常处理语句的语法规则</h3><ul><li>必须在<code>try</code>之后添加<code>catch</code>或<code>finally</code>块。<code>try</code>块后可同时接<code>catch</code>和<code>finally</code>块，但至少有一个块。</li><li>必须遵循块顺序：若代码同时使用<code>catch</code>和<code>finally</code>块，则必须将<code>catch</code>块放在<code>try</code>块之后。</li><li><code>catch</code>块与相应的异常类的类型相关。</li><li>一个<code>try</code>块可能有多个<code>catch</code>块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个<code>catch</code>代码块，不会再执行其他的<code>catch</code>代码块。</li><li>可嵌套<code>try-catch-finally</code>结构。</li><li>在<code>try-catch-finally</code>结构中，可重新抛出异常。</li><li>除了下列情况，总将执行<code>finally</code>做为结束：<ul><li>JVM 过早终止（调用 System.exit(int)）；</li><li>在<code>finally</code>块中抛出一个未处理的异常；</li><li>计算机断电、失火、或遭遇病毒攻击。</li></ul></li></ul><h2 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h2><p>任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的<code>throw</code>语句抛出异常。从方法中抛出的任何异常都必须使用<code>throws</code>子句。</p><h3 id="throws抛出异常"><a href="#throws抛出异常" class="headerlink" title="throws抛出异常"></a>throws抛出异常</h3><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用<code>throws</code>子句来声明抛出异常。<code>throws</code>语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是<code>Exception</code>异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。<code>throws</code>语句的语法格式为：</p><pre><code class="java">methodname throws Exception1, Exception2, ... , ExceptionN {}</code></pre><p>方法名后的<code>throws Exception1, Exception2, ... , ExceptionN</code>为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。使用<code>throws</code>关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。</p><p>throws抛出异常的规则：</p><ul><li>如果是非检查异常（<code>unchecked exception</code>），即<code>Error</code>、<code>RuntimeException</code>或它们的子类，那么可以不使用<code>throws</code>关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何检查异常（<code>checked exception</code>）。即如果一个方法可能出现受检查异常，要么用<code>try-catch</code>语句捕获，要么用<code>throws</code>子句声明将它抛出，否则会导致编译错误。</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何检查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h3 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h3><p><code>throw</code>总是出现在函数体中，用来抛出一个<code>Throwable</code>类型的异常。程序会在<code>throw</code>语句后立即终止，它后面的语句执行不到，然后在包含它的所有<code>try</code>块中（可能在上层调用函数中）从里向外寻找含有与其匹配的<code>catch</code>子句的<code>try</code>块。异常是异常类的实例对象，我们可以创建异常类的实例对象通过<code>throw</code>语句抛出。该语句的语法格式为：</p><pre><code class="java">throw new ExceptionName();</code></pre><blockquote><p><strong>注</strong>：如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。</p></blockquote><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>在设计模式中有一个设计模式叫做<strong>责任链模式</strong>，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：<strong>异常链</strong>。</p><p>我们知道每遇到一个异常信息，我们都需要进行<code>try-catch-finally</code>,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个<code>Exception</code>解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。</p><p>我们有两种方式处理异常，一是<code>throws</code>抛出交给上级处理，二是<code>try-catch</code>做具体处理。但是这个与上面有什么关联呢？<code>try-catch</code>的<code>catch</code>块我们可以不需要做任何处理，仅仅只用<code>throw</code>这个关键字将我们封装异常信息主动抛出来。然后在通过关键字<code>throws</code>继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p><p><strong>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性</strong>。</p><p>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。</p><p>在异常链的使用中，<code>throw</code>抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在<code>Throwable</code>及其子类中的构造器中都可以接受一个<code>cause</code>参数，该参数保存了原有的异常信息，通过<code>getCause()</code>就可以获取该原始异常信息。使用方式如下：</p><pre><code class="java">public class Test {    public void f() throws MyException{         try {             FileReader reader = new FileReader(&quot;test.txt&quot;);             Scanner in = new Scanner(reader);             System.out.println(in.next());        } catch (FileNotFoundException e) {            //e 保存异常信息            throw new MyException(&quot;文件没有找到--01&quot;, e);        }    }    public void g() throws MyException{        try {            f();        } catch (MyException e) {            //e 保存异常信息            throw new MyException(&quot;文件没有找到--02&quot;, e);        }    }    public static void main(String[] args) {        Test t = new Test();        try {            t.g();        } catch (MyException e) {            e.printStackTrace();        }    }}</code></pre><p>如果在程序中,去掉<code>e</code>，也就是：<code>throw new MyException(“文件没有找到–02″);</code>那么异常信息就保存不了。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误。所以，Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。</p><p>Java自定义异常的使用要经历如下四个步骤：</p><ul><li>定义一个类继承<code>Throwable</code>或其子类。</li><li>添加构造方法(当然也可以不用添加，使用默认构造方法)。</li><li>在某个方法类抛出该异常。</li><li>捕捉该异常。</li></ul><p>示例如下：</p><pre><code class="java">/** *自定义异常 继承Exception类. */public class MyException extends Exception {    public MyException(){    }    public MyException(String message){        super(message);    }}/** * 测试抛出和捕捉异常的类. */public class Test {    public void display(int i) throws MyException{        if (i == 0) {            throw new MyException(&quot;该值不能为0.......&quot;);        } else{            System.out.println( i / 2);        }    }    public static void main(String[] args) {        Test test = new Test();        try {            test.display(0);            System.out.println(&quot;---------------------&quot;);        } catch (MyException e) {            e.printStackTrace();        }    }}</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>尽可能的减小<code>try</code>块。</li><li>不要在构造函数中抛出异常。</li><li>如果使用Java7及以后的版本，一个catch子句中可以捕获多个异常。</li><li>充分使用<code>finally</code>块，保证所有资源都被正确释放；如果使用Java7及以后的版本，那么更推荐使用<code>try-with-resource</code>语法。</li><li><code>catch</code>语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的<code>Exception</code>类。 不要一个<code>Exception</code>试图处理所有可能出现的异常。</li><li>不要忽略异常。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。</li><li>在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。</li><li>减轻<code>finally</code>的任务，finally块仅仅用来释放资源是最合适的。不要在<code>finally</code>中使用<code>return</code>、抛出异常等。</li><li>为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。对异常进行Javadoc文档说明，并且描述抛出异常的场景。</li><li>不要捕获<code>Throwable</code>。<code>Throwable</code>是所有异常和错误的父类。如果<code>catch</code>了<code>throwable</code>，那么不仅仅会捕获所有<code>Exception</code>，还会捕获<code>Error</code>。而<code>Error</code>是表明无法恢复的JVM错误。因此除非绝对肯定能够处理或者被要求处理<code>Error</code>，不要捕获<code>Throwable</code>。</li><li>包装异常时要包含原始的异常。包装异常时，一定要把原始的异常设置为<code>cause</code>(<code>Exception</code>有构造方法可以传入<code>cause</code>)。否则，丢失了原始的异常信息会让错误的分析变得困难。</li></ul><h2 id="常见异常及解释"><a href="#常见异常及解释" class="headerlink" title="常见异常及解释"></a>常见异常及解释</h2><p>以下是常见<a href="http://rymden.nu/exceptions.html" target="_blank" rel="noopener">Java异常</a>的<strong>非技术角度</strong>的理解。阅读有风险，理解需谨慎。</p><h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h3><ul><li><code>ArithmeticException</code>：你正在试图使用电脑解决一个自己解决不了的数学问题，请重新阅读你的算术表达式并再次尝试。</li><li><code>ArrayIndexOutOfBoundsException</code>：请查看<a href="http://rymden.nu/exceptions.html#IndexOutOfBoundsException" target="_blank" rel="noopener">IndexOutOfBoundsException</a>。不同之处在于这个异常越界的元素不止一个。</li><li><code>ArrayStoreException</code>：你已用光了所有数组，需要从数组商店中购买更多的数组。</li><li><code>ClassCastException</code>：你需要呆在自己出生的种姓或阶级。Java 不会允许达利特人表现得像刹帝利或者高贵种族的人假装成为工人阶级。为了保持向前兼容，Java 1.0中把Caste误写为Cast保留到了现在。</li><li><code>ClassNotFoundException</code>：你似乎创造了自己的类。这也是目前 Java 还未实现的种姓制度，但是 Java 明显使用了巴厘岛的种姓制度。也就是说，如果你是一个武士，也就相当于印度种姓制度中的第三层——吠舍。</li><li><code>CloneNotSupportedException</code>：你是一名克隆人。找到你的原型，告诉他你想做什么，然后自杀。</li><li><code>IllegalAccessException</code>：你是一个正在运行 Java 程序入室盗窃的小偷，请结束对电脑的盗窃行为，离开房子，然后再试一次。</li><li><code>IllegalArgumentException</code>：你试图反对之前的异常。</li><li><code>IllegalMonitorStateException</code>：请打开你的电脑屏幕背面。</li><li><code>IllegalStateException</code>：你来自一个尚未被联合国承认的国家，也许是库尔德斯坦或者巴勒斯坦。拿到真正的国籍后重新编译你的 Java 代码，然后再试一次。</li><li><code>IllegalThreadStateException</code>：你电脑的一颗螺丝上到了错误的螺纹孔里，请联系你的硬盘供应商。</li><li><code>IndexOutOfBoundsException</code>：你把食指放在了无法接收的地方，重新放置，再试一次。</li><li><code>InstantiationException</code>：不是每件事都会立即发生，请更耐心一点。</li><li><code>InterruptedException</code>：告诉你的同事、室友等，当你工作的时候，请勿打扰。</li><li><code>NegativeArraySizeException</code>：你创建了一个负数长度的数组。这会丢失信息，长期发展将会毁灭宇宙。不过放宽心，Java 发现了你正在做的事，不要再这么干了。</li><li><code>NoSuchFieldException</code>：你正试图去一个不存在的区域游览。如果你试图去参观一个事实上不存在，其实已经是最高机密的飞机场时，也会得到这个异常。我可以给你示例，然后不得不杀了你。</li><li><code>NoSuchMethodException</code>：不要使用那个方法！拜托了，就像我们一直做的那样去解决事情吧。</li><li><code>NullPointerException</code>：你没有狗。请你先找一只狗，比如一只布烈塔尼獵犬，然后再试一次。</li><li><code>NumberFormatException</code>：你正在使用过时的测量单位，比如英寸或者品脱。请转换成国际基本单位。有一个已知的 bug 会导致 Java 抛出这个异常，那就是你太矮了或者太高了。</li><li><code>RuntimeException</code>：你不能跑得足够快，可能因为你太胖了。关掉你的电脑，出门锻炼吧。</li><li><code>SecurityException</code>：你已被认为是国家安全的一个威胁。请你呆在原地别动，然后等着警察来并带你走。</li><li><code>StringIndexOutOfBoundsException</code>：你的内裤和这个地方格格不入。换掉它们，再试一次。另外如果你根本不穿任何内裤，也会得到这个异常。</li><li><code>UnsupportedOperationException</code>：因为一些原因，你正试图做一个在道德上不被 Java 支持的手术。包括不必要的截肢，例如割包皮。请停止滥用你的身体，不要移除你的孩子，该死的！</li></ul><h3 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h3><ul><li><code>ConcurrentModificationException</code>：有人修改了你的 Java 代码。你应该更改密码。</li><li><code>EmptyStackException</code>：为了让 Java 工作，你必须在桌子上放一叠 Java 书籍。当然，如果书很厚的话，一本就够了。</li><li><code>MissingResourceException</code>：你太穷了，不配使用 Java。换一个更便宜的语言吧（比如 Whitespace、Shakesperre、Cow、Spaghetti 或者 C#）。</li><li><code>NoSuchElementException</code>：这里只存在四种元素（地球、水、空气、火）。《第五元素》只是部电影而已。</li><li><code>TooManyListenersException</code>：你被太多秘密机构窃听了，SecurityException 马上就到。</li></ul><h3 id="java-awt"><a href="#java-awt" class="headerlink" title="java.awt"></a>java.awt</h3><ul><li><code>AWTException</code>：你正在使用AWT，也就是说你的图形界面会很丑。这个异常只是一个警告可以被忽略。</li><li><code>FontFormatException</code>：你的布局很丑陋，或者你选择了一个糟糕的字体，或者太多的字体。请咨询一名专业的设计师。</li><li><code>HeadlessException</code>：Java 认为身为一名程序员，你实在是太蠢了。</li><li><code>IllegalComponentStateException</code>：你的一个硬件（例如硬盘、CPU、内存）坏掉了。请联系你的硬件供应商。</li></ul><h3 id="java-awt-color"><a href="#java-awt-color" class="headerlink" title="java.awt.color"></a>java.awt.color</h3><ul><li><code>CMMException</code>：你的 CMM 坏掉了，真是见鬼了。我经常烧毁自己的房子，然后去一个新的城市重新开始。</li><li><code>ProfileDataException</code>：你的个人档案包含可疑信息。如果你不是一名共产主义者、恐怖分子或者无神论者，请联系 CIA 修正错误。</li></ul><h3 id="java-awt-datatransfer"><a href="#java-awt-datatransfer" class="headerlink" title="java.awt.datatransfer"></a>java.awt.datatransfer</h3><ul><li><code>MimeTypeParseException</code>：你的哑剧（Mime）糟透了，没人能够理解你到底想表达什么。尝试一些更简单的事情吧，比如迎风散步，或者被困在一个看不见的盒子里。</li><li><code>UnsupportedFlavorException</code>：你正试图使用一种 Java 不知道的香料。大部分人似乎只知道使用香草和樱桃。</li></ul><h3 id="java-beans"><a href="#java-beans" class="headerlink" title="java.beans"></a>java.beans</h3><ul><li><code>IntrospectionException</code>：你太内向了，你应该变得外向一些。 别再当一个呆子，出门去见见人吧！</li><li><code>PropertyVetoException</code>：你的一部分财产被冻结了。这条信息应该已经告诉你谁干的和原因。如果没看见，你可能也不该询问。</li></ul><h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><ul><li><code>CharConversionException</code>：你一直试图焚烧一些不燃物。也可能是因为你试着把自己变成一条鱼，但这不可能发生。</li><li><code>EOFException</code>：你得到这条异常是因为你不知道EOF是什么意思。但是，我并不打算告诉你，因为你是一个不学无术的人。</li><li><code>FileNotFoundException</code>：一名木匠应该总是知道他的工具放在哪里。</li><li><code>InterruptedIOException</code>：你不顾之前的 IOException，一直在使用 IO，然后你的活动就被中断了。</li><li><code>InvalidClassException</code>：查看 ClassNotFoundException。</li><li><code>InvalidObjectException</code>：反对无效，就像他们在法庭上说的一样。</li><li><code>IOException</code>：IO 代表输入、输出，并且不得不做收发数据的事。IO 是一个安全问题，不应使用。</li><li><code>NotActiveException</code>：这个异常意味着两件事。要么是未激活，需要激活；要么是已激活，需要停止。到开始工作为止，激活与未激活都是随机的。</li><li><code>NotSerializableException</code>：你正试图把一部电影改成电视剧。</li><li><code>ObjectStreamException</code>：你提出了一连串的反对（Object）意见。提出新的意见前，请限制自己一下，等待法官作出判决。查看 InvalidObjectException。</li><li><code>OptionalDataException</code>：你似乎认为一些可选数据是必须的。不要让事情变得复杂。</li><li><code>StreamCorruptedException</code>：你的数据流被损坏了，这意味着它已经被截包，并在黑市上贩卖。</li><li><code>SyncFailedException</code>：你试图与其他人同步你的失败，然后被证明比他人更加失败。去找一些跟你同等水平的人吧。</li><li><code>UnsupportedEncodingException</code>：如果你想在网上发送自己的代码，必须与美国国家安全局核对你的加密密匙。如果不这么做，将把你视为恐怖分子，并以适当方式处理。如果你得到这个异常，能跑多快跑多快。</li><li><code>UTFDataFormatException</code>：UTF 代表通用传输格式，是一种无论你使用哪种格式都会用到的数据传输方式。你试图通过 UTF 传输错误格式的数据。</li><li><code>WriteAbortedException</code>：你需要在程序中的某处写上“aborted”。这通常没什么意义，但你就得这样做。</li></ul><h3 id="java-net"><a href="#java-net" class="headerlink" title="java.net"></a>java.net</h3><ul><li><code>BindException</code>：Java编程和束缚不能混为一谈。</li><li><code>ConnectException</code>：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。</li><li><code>MalformedURLException</code>：你正在制作一个形状错误的壶（例如一个“L”状），或者你有拼写错误的单词“urn”（例如“url”）。</li><li><code>NoRouteToHostException</code>：没有通往主机的“道路”，请联系公路管理员。</li><li><code>PortUnreachableException</code>：港口必须正确地放置在水边。如果在内陆，它们将会无法接触。</li><li><code>ProtocolException</code>：这是一个严重违反规定的结果（例如在你主机上的“puk韓g”）。解决方法很简单：不要那样做！</li><li><code>SocketException</code>：你把电脑连接到了错误的电源插座。大部分情况下你不得不寻找其它插座，但一些电脑背部有一个开关，可以设置电源插座类型。</li><li><code>SocketTimeoutException</code>：你的电脑连接了一个带计时器的电源插座，并且时间已经走完。只有烙铁和相似的东西才会使用这种插座。</li><li><code>UnknownHostException</code>：你的父母没有教过你不要和陌生人说话么？</li><li><code>UnknownServiceException</code>：你正试图进入接近一个未知服务。众所周知，未知服务或许是特工组织。</li><li><code>URISyntaxException</code>：“You are I”是一个语法错误的句子。将其改为“You are me”，别管那到底啥意思。</li></ul><h3 id="java-rmi"><a href="#java-rmi" class="headerlink" title="java.rmi"></a>java.rmi</h3><ul><li><code>AccessException</code>：你正在使用“Microsoft Access”。请不要这样做。</li><li><code>AlreadyBoundException</code>：不管在 java.net.BindException 的描述中是什么状况，RMI 都提供捆绑服务。然而，你不能绑一个已经被捆绑的人。</li><li><code>ConnectException</code>：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。</li><li><code>ConnectIOException</code>：你正试图通过 IO 与另一个不能被连接的事物建立连接。尝试连接其他事物吧。或许你可以通过一个特殊的连接对象实现想要的连接。</li><li><code>MarshalException</code>：你的“marshal”出问题了。你应做的事取决于我们正在讨论的是哪种“marshal”。他可以是陆军元帅、警察、消防队员或者只不过是一名普通的司仪。注意这个异常与马绍尔群岛共和国没有任何关系，也称为 RMI。</li><li><code>NoSuchObjectException</code>：你正试图使用一个不存在的对象。以爱因斯坦之名，创造它或者不要使用它！</li><li><code>NotBoundException</code>：如果你正在使用奴隶，请确认至少有一个人被绑住了。</li><li><code>RemoteException</code>：这是一条远程抛出的特殊异常。如果其他人的应用变得不稳定，以致于不能产生一条异常，相反地，你可能会得到这条异常。请找到源头并提醒那位程序员这个错误。</li><li><code>RMISecurityException</code>：马绍尔群岛共和国变得不稳定了。如果你住在这儿，你最好离开，直到安全得到保障为止都别回来。如果你住在其他地方，可以无视这个异常。</li><li><code>ServerException</code>：第二发球（或者双发失误同样适用）。</li><li><code>ServerRuntimeException</code>：只要是网球比赛都很长。当你花太长时间发球时，就会得到这条异常。</li><li><code>StubNotFoundException</code>：当你去看电影的时候，你应该一直保留自己的票根。如果不这么做，并且离开了电影院，你就不能重新进去，不得不去买张新票。所以保留你的票根！</li><li><code>UnexpectedException</code>：这个异常对你来说应该会成为一个大惊喜。如果发生了，所有事都变成它应该的样子。</li><li><code>UnknownHostException</code>：你父母没有教过你不要和陌生人说话吗？</li><li><code>UnmarshalException</code>：.你没有完成一名法律工作人员的职责（例如你曾经的法官工作）。注意这个正确的术语是“曾经”（used to）。你已经被解雇（fire）了（如果你是一名消防队员（firefighter），这可真是讽刺啊）。</li></ul><h3 id="java-security"><a href="#java-security" class="headerlink" title="java.security"></a>java.security</h3><ul><li><code>AccessControlException</code>：你失去了对 Microsoft Access 的控制。如果你无法重获控制或者通过其他方式停止程序，你应该尽快切断电脑电源。</li><li><code>DigestException</code>：你应该注意自己的食物，消化不良也能变成严重的问题。</li><li><code>GeneralSecurityException</code>：在某些地方做一些事情并不安全。如果你有足够的权力，你应该随机入侵一个国家（最好在中东地区）。如果你没有那种权力，至少应该有一把枪。</li><li><code>InvalidAlgorithmParameterException</code>：你向一位残疾人用他不能理解的方式解释你的算法。简单一点！</li><li><code>InvalidKeyException</code>：这个异常有两种不同的原因：1、你正在使用错误的钥匙。我的建议是在你的钥匙上画不同颜色的小点来帮助你记住哪一把对应哪一个锁。2、 你不能锁住残疾人却不给他们钥匙，如果他们足够聪明发现如何使用钥匙，他们就有自由移动的权- 利。</li><li><code>InvalidParameterException</code>：你使用了蔑视的术语去描述一名残疾人。</li><li><code>KeyException</code>：不要尝试不用钥匙就能开锁。</li><li><code>KeyManagementException</code>：你遗失了自己的钥匙。很可能忘在办公室（如果你正试图进入你家）或者忘在家里（如果你正试图进入办公室）。</li><li><code>KeyStoreException</code>：延续之前 KeyManagementException 的解释就是你的钱包有个洞。</li><li><code>NoSuchAlgorithmException</code>：你试图用以前未知的方法解决问题。停止创新吧，用老算法重写一遍。你也可以为自己的想法申请专利，然后等待未来 Java 发布新版本的时候纳入其中。</li><li><code>NoSuchProviderException</code>：如果你是一名单亲妈妈，你没法成为家庭主妇。首先，你得为家庭找到一名供养者。</li><li><code>PrivilegedActionException</code>：你试图采取一个行动，但是没有得到权限。比如，只有名人才可以做到地从谋杀中逃脱，只有天主教神父和耶和华的高级见证人才能做地猥亵儿童，只有在私人企业担任管理职位的人才能被允许地偷钱。</li><li><code>ProviderException</code>：你是一名妇女并试图供养一个家庭。显而易见，你的丈夫不能成为一名“家庭主妇”，所以你得让他供养个家庭。想象一下，Java固执且不肯改变，事情就是这样工作的，解决它。</li><li><code>SignatureException</code>：要么你是伪造的其他人的签名，要么是无法接受你的签名。一个签名不能太丑陋、太易读或太大。</li><li><code>UnrecoverableKeyException</code>：该死。你把你的钥匙扔进了下水沟。我唯一能安慰你的就是其他人也无法恢复钥匙，所以倒不是必须换掉你的锁。</li></ul><h3 id="java-text"><a href="#java-text" class="headerlink" title="java.text"></a>java.text</h3><ul><li><code>ParseException</code>：你做的没有任何意义，冷静下来，再试一次。</li></ul><hr><p>参考文档：</p><ul><li><a href="http://www.importnew.com/20629.html" target="_blank" rel="noopener">java提高篇之异常（上）</a></li><li><a href="http://www.importnew.com/20645.html" target="_blank" rel="noopener">java提高篇之异常（下）</a></li><li><a href="http://www.importnew.com/14688.html" target="_blank" rel="noopener">深入理解java异常处理机制</a></li><li><a href="http://www.importnew.com/26775.html" target="_blank" rel="noopener">Java 中 9 个处理 Exception 的最佳实践</a></li><li><a href="http://www.importnew.com/16725.html" target="_blank" rel="noopener">Java常见异常及解释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你需要知道的Java枚举知识</title>
      <link href="/2018/10/27/hou-duan/java/ni-xu-yao-zhi-dao-de-java-mei-ju-zhi-shi/"/>
      <url>/2018/10/27/hou-duan/java/ni-xu-yao-zhi-dao-de-java-mei-ju-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>枚举</strong>（<code>enum</code>全称为<code>enumeration</code>）类型是<code>Java 5</code>新增的类型，存放在<code>java.lang</code>包中，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。</p><h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><p> 创建枚举类型要使用<code>enum</code>关键字，隐含了所创建的类型都是<code>java.lang.Enum</code>类的子类（<code>java.lang.Enum</code>是一个抽象类）。枚举类型符合通用模式<code>Class Enum&lt;E extends Enum&lt;E&gt;&gt;</code>，而<code>E</code>表示枚举类型的名称。枚举类型的每一个值都将映射到<code>protected Enum(String name, int ordinal)</code>构造函数中。在这里每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</p><p>枚举类的定义格式如下：</p><pre><code class="java">enum 类名 {//枚举值}</code></pre><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>需要的数据不能是任意的，而必须是一定范围内的值</li><li>枚举类也是一个特殊的类，构造方法默认的修饰符是<code>private</code>的</li><li>枚举值默认的修饰符是<code>public static final</code>，必须要位于枚举类的第一个语句</li><li>枚举类可以定义自己的成员变量、成员函数和带参构造方法，自定义带参构造方法时，枚举值需要传参</li><li>枚举类可以存在抽象的方法，但是枚举值必须要实现抽象的方法</li><li>可以使用<code>==</code>来比较枚举实例</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>枚举中的一些常用方法如下：</p><ul><li><code>int ordinal()</code>：返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）。</li><li><code>String name()</code>：返回此枚举常量的名称。</li><li><code>String toString()</code>：返回覆盖枚举常量的<code>toString()</code>方法的值。</li><li><code>int compareTo(E o)</code>：比较此枚举与指定对象的顺序。</li><li><code>Class&lt;E&gt; getDeclaringClass()</code>：返回与此枚举常量的枚举类型相对应的 Class 对象。</li><li><code>static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)</code>：返回指定名称的枚举常量指定的enumtype的方法。如：<code>ColorEnum color = ColorEnum.valueOf(&quot;RED&quot;);</code>。</li></ul><h2 id="主要应用"><a href="#主要应用" class="headerlink" title="主要应用"></a>主要应用</h2><h3 id="表达常量"><a href="#表达常量" class="headerlink" title="表达常量"></a>表达常量</h3><p>在<code>Java 5</code>之前，定义常量的最佳方式是在<code>final</code>修饰的常量类中定义：<code>public static fianl...</code>修饰的属性，且须将构造方法设为<code>private</code>。代码示例如下：</p><pre><code class="java">public final class ColorConst {    public static final int RED = 1;    public static final int GREEN = 2;    public static final int BLUE = 3;    private ColorConst() {}}</code></pre><p>但，<strong>不建议在接口中定义常量</strong>。在<code>《Effective Java》</code>一书中提到过：</p><blockquote><p><strong>The constant interface pattern is a poor use of interfaces</strong>. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.There are several constant interfaces in the java platform libraries, such as java.io.ObjectStreamConstants. These interfaces should be regarded as anomalies and should not be emulated.</p></blockquote><p>大意是：<strong>如果某个实现了常量接口的类被修改不再需要常量了，也会因为序列化兼容原因不得不保持该实现，而且非<code>final</code>类实现常量接口会导致所有子类被污染</strong>。</p><p>现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。</p><pre><code class="java">public enum ColorEnum {    RED, GREEN, BLUE}</code></pre><blockquote><p><strong>注意</strong>：枚举类的名称一般以<code>Enum</code>结尾，比如<code>ColorEnum</code>等。如果你写个枚举类，取名为<code>Color</code>，那么没人能快速知道它是一个枚举类。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Java 中使用<code>values()</code>方法将枚举所有元素item转换成一个数组。这样就可以通过<code>foreach</code>语法来遍历枚举中的所有元素了。</p><pre><code class="java">for (ColorEnum color: ColorEnum.values()) {    log.info(&quot;ordinal:{}, name:{}&quot;, color.ordinal(), color.name());}</code></pre><p>输出结果；</p><pre><code class="bash">ordinal:0, name:REDordinal:1, name:GREENordinal:2, name:BLUE</code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>在<code>JDK7</code>之前，String字符串是不支持通过<code>switch</code>语法来筛选数据，但是 Java 为枚举提供了<code>switch</code>语法的支持。使用示例如下：</p><pre><code class="java">// 客户端传来的枚举itemColorEnum color = ColorEnum.GREEN;switch (color) {    case RED: log.info(&quot;进入了 RED 的分支&quot;);        break;    case GREEN: log.info(&quot;进入了 GREEN 的分支&quot;);        break;    case BLUE: log.info(&quot;进入了 BLUE 的分支&quot;);        break;    default: log.info(&quot;进入了 default 的分支&quot;);}</code></pre><p>输出结果：</p><pre><code class="bash">进入了 GREEN 的分支</code></pre><blockquote><p><strong>注意</strong>：<code>switch</code>后已经指定了枚举的类型，<code>case</code>后无须再使用全名<code>ColorEnum</code>。</p></blockquote><h3 id="自定义属性和方法"><a href="#自定义属性和方法" class="headerlink" title="自定义属性和方法"></a>自定义属性和方法</h3><p>Java枚举中允许定义属性和方法，但必须在枚举实例序列的最后一个分号后再添加。Java 要求必须先定义枚举实例在前面，使用示例如下：</p><pre><code class="java">/** * 关于颜色的枚举. * @author blinkfox on 2017/9/17. */public enum ColorEnum {    RED(1, &quot;红色&quot;), GREEN(2, &quot;绿色&quot;), BLUE(3, &quot;蓝色&quot;);    /** 颜色的code. */    private int code;    /** 颜色的名称. */    private String name;    /**     * 枚举的构造方法默认且只能是private的.     * @param code 代码值     * @param name 名称     */    ColorEnum(int code, String name) {        this.code = code;        this.name = name;    }    /**     * 根据颜色的code值获取到对应的名称.     * @param code 颜色code     * @return 颜色名称     */    public static String getNameByCode(int code) {        for (ColorEnum color: ColorEnum.values()) {            if (color.code == code) {                return color.name;            }        }        return null;    }    /**     * 覆盖的toString方法.     * @return 字符串     */    @Override    public String toString() {        return this.code + &quot;:&quot; + this.name;    }    /* getter方法. */    public int getCode() {        return code;    }    public String getName() {        return name;    }}</code></pre><blockquote><p><strong>注意</strong>：枚举的构造方法默认且只能是<code>private</code>的。</p></blockquote><h3 id="使用枚举来表达多态"><a href="#使用枚举来表达多态" class="headerlink" title="使用枚举来表达多态"></a>使用枚举来表达多态</h3><p>所有的枚举都继承自<code>java.lang.Enum</code>类。由于 Java 不支持多继承，所以枚举不能再继承其他类。但枚举类中可以定义抽象方法，也可以实现一个或者多个接口。由于每一个枚举值会呈现出不同的行为方式，则须要让每个枚举值分别实现方法。</p><pre><code class="java">/** * 关于颜色的枚举. * @author blinkfox on 2017/9/17. */public enum ColorEnum {    RED(1, &quot;红色&quot;) {        @Override        public void paint() {            log.info(&quot;使用了&#39;红色&#39;颜料来喷漆&quot;);        }    },    GREEN(2, &quot;绿色&quot;) {        @Override        public void paint() {            log.info(&quot;使用了&#39;绿色&#39;颜料来喷漆&quot;);        }    },    BLUE(3, &quot;蓝色&quot;) {        @Override        public void paint() {            log.info(&quot;使用了&#39;蓝色&#39;颜料来喷漆&quot;);        }    };    private static final Logger log = LoggerFactory.getLogger(ColorEnum.class);    /** 颜色的code. */    private int code;    /** 颜色的名称. */    private String name;    /**     * 枚举的构造方法默认且只能是private的.     * @param code 代码值     * @param name 名称     */    ColorEnum(int code, String name) {        this.code = code;        this.name = name;    }    /**     * 使用不同的颜色来喷漆的抽象方法.     */    public abstract void paint();    /**     * 根据颜色的code值获取到对应的名称.     * @param code 颜色code     * @return 颜色名称     */    public static String getNameByCode(int code) {        for (ColorEnum color: ColorEnum.values()) {            if (color.code == code) {                return color.name;            }        }        return null;    }    /* getter方法. */    public int getCode() {        return code;    }    public String getName() {        return name;    }    /**     * 覆盖的toString方法.     * @return 字符串     */    @Override    public String toString() {        return this.code + &quot;:&quot; + this.name;    }}</code></pre><h3 id="枚举集合的使用"><a href="#枚举集合的使用" class="headerlink" title="枚举集合的使用"></a>枚举集合的使用</h3><p>Java 中提供了两个方便操作<code>enum</code>的集合类：<code>java.util.EnumSet</code>和<code>java.util.EnumMap</code>。<code>EnumSet</code>保证集合中的元素不重复；<code>EnumMap</code>中的<code>key</code>是<code>enum</code>类型且不能为<code>null</code>，而<code>value</code>则可以是任意类型。<code>EnumSet</code>和<code>EnumMap</code>内部以数组来实现，性能更好。</p><p>以下是<code>EnumMap</code>的使用示例：</p><pre><code class="java">EnumMap&lt;ColorEnum, String&gt; colorEnumMap = new EnumMap&lt;ColorEnum, String&gt;(ColorEnum.class);colorEnumMap.put(ColorEnum.RED, &quot;这是EnumMap中的&#39;RED&#39;&quot;);colorEnumMap.put(ColorEnum.GREEN, &quot;这是EnumMap中的&#39;GREEN&#39;&quot;);colorEnumMap.put(ColorEnum.BLUE, &quot;这是EnumMap中的&#39;BLUE&#39;&quot;);log.info(&quot;{}&quot;, colorEnumMap);</code></pre><p>输出结果：</p><pre><code class="bash">{1:红色=这是EnumMap中的&#39;RED&#39;, 2:绿色=这是EnumMap中的&#39;GREEN&#39;, 3:蓝色=这是EnumMap中的&#39;BLUE&#39;}</code></pre><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>在<code>《Effective Java》</code>一书中强烈推荐<strong>使用枚举来实现单例模式</strong>，同时枚举单例代码也最为简单：</p><pre><code class="java">public enum ColorEnumSingleton {    INSTANCE;    public static void doSomething(){        // do something    }}</code></pre><p>使用枚举单例有以下好处：</p><ul><li>自由序列化</li><li>保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）</li><li>线程安全</li></ul><blockquote><p><strong>注意</strong>：枚举单例是<strong>饿汉</strong>式的。</p></blockquote><h3 id="枚举策略"><a href="#枚举策略" class="headerlink" title="枚举策略"></a>枚举策略</h3><p>在使用 Java 的枚举时往往会结合<code>Switch</code>来进行判断以实现不同值的处理，但是我们知道多用<code>switch</code>不是一种很好的代码风格，不利用维护和适应变化，因为这不符合<strong>开闭原则</strong>。为此一种方法是用<strong>策略模式</strong>来重构原有的枚举实现。在<code>《Effective Java》</code>一书中提出了一种<strong>枚举策略模式</strong>很好的解决了这个问题。</p><p>具体使用方法和前面所讲的<strong>使用枚举来表达多态</strong>一节中的示例一样，这里就不再举例说明了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>枚举类也是一个特殊的类，构造方法默认的修饰符是<code>private</code>（不管写不写）的，它们都可以定义一些属性和方法，但是不能使用<code>extends</code>关键字继承其他类，因为<code>enum</code>已经继承了<code>java.lang.Enum</code>（java是单一继承）。</li><li>枚举类中可以定义抽象方法，也可以实现一个或者多个接口。</li><li>使用枚举大大加强了程序的可读性、易用性和可维护性，并且可在此基础之上进行了扩展，使之可以像类一样去使用，更是为 Java 对离散量的表示上升了一个台阶。</li><li>枚举最大的缺点是：<strong>相对于普通的常量会占用更多的内存</strong>。所以，我还是不建议大面积的使用枚举来替代整形常量。但是如果这些常量还有关联属性或者行为等，那么强烈推荐使用枚举类型。<strong>使用枚举类型的性能几乎是使用静态类的16倍</strong>。</li><li>枚举类型对象之间的值比较，可以使用<code>==</code>直接来比较值是否相等的，不是必须使用<code>equals</code>方法。</li><li>推荐使用<strong>枚举单例</strong>来实现单例模式，可以使用<strong>枚举策略</strong>来简化策略模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java集合框架知识整理</title>
      <link href="/2018/10/24/hou-duan/java/java-ji-he-kuang-jia-zhi-shi-zheng-li/"/>
      <url>/2018/10/24/hou-duan/java/java-ji-he-kuang-jia-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>Java集合框架主要由<code>Collection</code>和<code>Map</code>两个根接口及其子接口、实现类组成。</p><h2 id="集合类关系梳理"><a href="#集合类关系梳理" class="headerlink" title="集合类关系梳理"></a>集合类关系梳理</h2><ul><li><code>Collection</code>接口继承了<code>Iterable</code>接口，依赖了<code>Predicate</code>、<code>Spliterator</code>、<code>Stream</code>接口（这些均为<code>Java8</code>新增），<code>Iterable</code>接口依赖了<code>Iterator</code>接口。<ul><li><code>List</code>接口继承自<code>Collection</code>接口,依赖了<code>UnaryOperator</code>接口（<code>Java8</code>新增）、<code>ListIterator</code>、<code>Comparator</code>接口</li><li><code>Queue</code>接口继承了<code>Collection</code>接口<ul><li><code>Deque</code>接口继承了<code>Queue</code>接口</li><li><code>BlockingQueue</code>接口继承了<code>Queue</code>接口<ul><li><code>BlockingDeque</code>接口继承了<code>BlockingQueue</code>、<code>Deque</code>接口</li><li><code>TransferQueue</code>接口继承了<code>BlockingQueue</code>接口</li></ul></li></ul></li><li><code>AbstractCollection</code>抽象类实现了<code>Collection</code>接口，<ul><li><code>AbstractList</code>抽象类继承了<code>AbstractCollection</code>抽象类，实现了<code>List</code>接口，依赖了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口<ul><li><code>ArrayList</code>类继承了<code>AbstractList</code>抽象类，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>AbstractSequentialList</code>抽象类继承了<code>AbstractList</code>抽象类<ul><li><code>LinkedList</code>类继承了<code>AbstractSequentialList</code>抽象类，实现了<code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li></ul></li><li><code>CopyOnWriteArrayList</code>实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>Vector</code>类继承了<code>AbstractList</code>抽象类，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code>接口<ul><li><code>Stack</code>类继承了<code>Vector</code>类</li></ul></li></ul></li><li><code>AbstractQueue</code>抽象类继承了<code>AbstractCollection</code>接口，实现了<code>Queue</code>接口<ul><li><code>SynchronousQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口，依赖了<code>Collection</code>、<code>Spliterator</code>接口</li><li><code>ArrayBlockingQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口</li><li><code>LinkedBlockingQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口</li><li><code>PriorityBlockingQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>、<code>Serializable</code>接口，聚合了<code>Comparator</code>接口，依赖了<code>Collection</code>、<code>Comparator</code>、<code>Comparable</code>接口</li><li><code>DelayQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingQueue</code>接口</li><li><code>LinkedBlockingDeque</code>类继承了<code>AbstractQueue</code>接口，实现了<code>BlockingDeque</code>、<code>Serializable</code>接口</li><li><code>PriorityQueue</code>类继承了<code>AbstractQueue</code>接口</li><li><code>LinkedTransferQueue</code>类继承了<code>AbstractQueue</code>接口，实现了<code>TransferQueue</code>、<code>Serializable</code>接口（Java7新增）</li></ul></li><li><code>ConcurrentLinkedDeque</code>类继承了<code>AbstractCollection</code>抽象类，实现了<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>ArrayDeque</code>类继承了<code>AbstractCollection</code>抽象类，实现了<code>Deque</code>、<code>Serializable</code>接口</li></ul></li><li><code>Set</code>接口继承自<code>Collection</code>接口<ul><li><code>AbstractSet</code>抽象类继承了<code>AbstractCollection</code>抽象类，实现了<code>Set</code>接口<ul><li><code>HashSet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>HashMap</code><ul><li><code>LinkedHashSet</code>类继承了<code>HashSet</code>类，实现了<code>Set</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li></ul></li><li><code>TreeSet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>NavigableMap</code>，依赖了<code>Comparator</code>、<code>SortedSet</code>接口</li><li><code>EnumSet</code>抽象类继承了<code>AbstractSet</code>抽象类，实现了<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>Comparator</code>、<code>SortedSet</code>接口<ul><li><code>RegularEnumSet</code>类继承了<code>EnumSet</code>抽象类</li><li><code>JumboEnumSet</code>类继承了<code>EnumSet</code>抽象类</li></ul></li><li><code>ConcurrentSkipListSet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code>接口</li><li><code>CopyOnWriteArraySet</code>类继承了<code>AbstractSet</code>抽象类，实现了<code>Serializable</code>接口，聚合了<code>CopyOnWriteArrayList</code>类，依赖了<code>Predicate</code>、<code>Consumer</code>接口</li></ul></li><li><code>SortedSet</code>接口继承自<code>Set</code>接口，依赖了<code>Comparator</code>接口<ul><li><code>NavigableSet</code>接口继承自<code>SortedSet</code>接口(Java6新增)</li></ul></li></ul></li></ul></li><li><code>Map</code>接口依赖了<code>Set</code>、<code>Collection</code>、<code>BiConsumer</code>、<code>Function</code>、<code>BiFunction</code>接口，<code>Map.Entry</code>是Map中的内部接口<ul><li><code>AbstractMap</code>抽象类实现了<code>Map</code>接口，聚合了<code>Collection</code>、<code>Set</code>接口<ul><li><code>HashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>Collection</code>、<code>Set</code>接口<ul><li><code>LinkedHashMap</code>继承了<code>HashMap</code>类，实现了<code>Map</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>接口</li></ul></li><li><code>TreeMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>NavigableMap</code>、<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>Comparator</code>、<code>SortedMap</code>、<code>Collection</code>、<code>Set</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>EnumMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Cloneable</code>、<code>Serializable</code>接口，依赖了<code>AbstractSet</code>类，<code>Collection</code>、<code>Set</code>接口</li><li><code>WeakHashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Map</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>IdentityHashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>Map</code>、<code>Serializable</code>、<code>Cloneable</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>ConcurrentHashMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>ConcurrentMap</code>、<code>Serializable</code>接口，依赖了<code>Comparable</code>、<code>ParameterizedType</code>、<code>Collection</code>、<code>Set</code>、<code>Spliterator</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>Function</code>、<code>BiFunction</code>、<code>ToDoubleFunction</code>、<code>DoubleBinaryOperator</code>等接口</li><li><code>ConcurrentSkipListMap</code>类继承了<code>AbstractMap</code>抽象类，实现了<code>ConcurrentNavigableMap</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>Comparator</code>接口，依赖了<code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>、<code>NavigableSet</code>接口</li></ul></li><li><code>SortedMap</code>接口继承自<code>Map</code>接口，依赖了<code>Set</code>、<code>Collection</code>、<code>Comparator</code>接口<ul><li><code>NavigableMap</code>接口继承了<code>SortedMap</code>接口，依赖了<code>NavigableSet</code>接口</li><li><code>ConcurrentNavigableMap</code>接口继承了<code>ConcurrentMap</code>、<code>NavigableMap</code>接口，聚合了<code>NavigableSet</code>接口</li></ul></li><li><code>ConcurrentMap</code>接口继承了<code>Map</code>接口，依赖了<code>BiConsumer</code>、<code>BiFunction</code>接口</li><li><code>Hashtable</code>类继承了<code>Dictionary</code>抽象类，实现了<code>Map</code>、<code>Cloneable</code>、<code>Serializable</code>接口，聚合了<code>Collection</code>、<code>Set</code>接口，依赖了<code>Enumeration</code>、<code>BiConsumer</code>、<code>BiFunction</code>接口<ul><li><code>Properties</code>类继承了<code>Hashtable</code>类</li></ul></li></ul></li><li><code>Collections</code>是<code>Collection</code>的辅助工具类，依赖了上述大多数接口和类</li><li><code>Arrays</code>是数组的辅助工具类，依赖了上述一些接口和类</li></ul><h2 id="集合UML关系图"><a href="#集合UML关系图" class="headerlink" title="集合UML关系图"></a>集合UML关系图</h2><p>Java Collection UML类关系图如下：</p><p><img src="http://static.blinkfox.com/Java_Collection_UML.png" alt="Java Collection UML类关系图"></p><p>Java Map UML类关系图如下：</p><p><img src="http://static.blinkfox.com/Java_Map_UML.png" alt="Java Map UML类关系图"></p><h2 id="各集合接口、类的介绍"><a href="#各集合接口、类的介绍" class="headerlink" title="各集合接口、类的介绍"></a>各集合接口、类的介绍</h2><ul><li><code>Collection</code>：<code>Collection</code>是最基本集合接口，它定义了一组允许重复的对象。<code>Collection</code>接口派生了三个子接口<code>List</code>、<code>Set</code>和<code>Queue</code>。<code>Collection</code>所有实现类的遍历都可以使用<code>Iterator</code>接口或者是<code>foreach</code>来循环。<ul><li><code>List</code>：<code>List</code>代表有序、可重复的集合。<ul><li><code>ArrayList</code>：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程不安全，效率高。<code>ArrayList</code>创建时的大小为<code>0</code>；当加入第一个元素时，进行第一次扩容时，默认容量大小为<code>10</code>，每次扩容都以当前数组大小的1.5倍去扩容。</li><li><code>Vector</code>：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程安全，效率低。<code>Vector</code>创建时的默认大小为<code>10</code>；<code>Vector</code>每次扩容都以当前数组大小的<code>2</code>倍去扩容。当指定了<code>capacityIncrement</code>之后，每次扩容仅在原先基础上增加<code>capacityIncrement</code>个单位空间。<code>ArrayList</code>和<code>Vector</code>的<code>add</code>、<code>get</code>、<code>size</code>方法的复杂度都为<code>O(1)</code>，<code>remove</code>方法的复杂度为<code>O(n)</code>。<ul><li><code>Stack</code>：<code>Vector</code>的一个子类，是标准的<strong>先进后出</strong>(FILO, First In Last Out)的栈。底层通过数组实现的，线程安全。</li></ul></li><li><code>LinkedList</code>：底层使用双向循环链表的数据结构来实现，排列有序可重复，查询速度慢、增删数据快，线程不安全。</li><li><code>CopyOnWriteArrayList</code>：底层使用<code>Copy-On-Write</code>的优化策略实现，适用于<strong>读多写少</strong>的场景，同<code>ArrayList</code>功能相似，线程安全。<code>CopyOnWriteArrayList</code>在某些情况下比<code>Collections.synchronizedList(List list)</code>有更好的性能。缺点是：内存占用大和数据一致性问题，只能保证最终一致性。</li></ul></li><li><code>Set</code>：<code>Set</code>代表无序、不可重复的集合。<ul><li><code>HastSet</code>：底层使用<code>Hash</code>表来实现，内部使用了<code>HashMap</code>，排列无序不可重复，存取速度快，线程不安全。<ul><li><code>LinkedHashSet</code>：底层采用<code>Hash</code>表存储，并用双向链表记录插入顺序，排列有序不可重复，存取速度较<code>HashSet</code>略慢，比<code>TreeSet</code>快，线程不安全。</li></ul></li><li><code>TreeSet</code>：底层使用红黑树来实现，内部使用了<code>NavigableMap</code>，按自然顺序或者自定义顺序存放、不可重复，线程不安全。</li><li><code>CopyOnWriteArraySet</code>：底层使用<code>Copy-On-Write</code>的优化策略实现，适用于<strong>读多写少</strong>的场景，内部使用了<code>CopyOnWriteArrayList</code>，同<code>HastSet</code>功能相似，线程安全。</li><li><code>ConcurrentSkipListSet</code>：底层使用<strong>跳跃列表</strong>来实现，适用于<strong>高并发</strong>的场景，内部使用了<code>ConcurrentNavigableMap</code>，同<code>TreeSet</code>功能相似，线程安全。</li><li><code>EnumSet</code>：是抽象类，只能用来存储Enum常量或其子类，不能存储其它类型，<code>EnumSet</code>有两种实现方式，<code>RegularEnumSet</code>和<code>JumboEnumSet</code>，但是这两种实现方式是包<strong>私有</strong>的，不能在包外访问，因此必须使用工厂方法来创建并返回<code>EnumSet</code>实例，不能通过构造函数来创建。<code>EnumSet</code>中提供了多种创建<code>EnumSet</code>实例的静态工厂方法，例如<code>of</code>方法（进行了函数重载），<code>copyOf</code>方法，<code>noneOf</code>方法等。存储效率快，线程不安全。存储枚举常量时使用<code>EnumSet</code>而不要用<code>HashSet</code>。</li></ul></li><li><code>Queue</code>：<code>Queue</code>是Java 5之后增加的集合体系，表示<strong>队列</strong>集合的相关实现，大多遵循<strong>先进先出</strong>(FIFO, First-In-First-Out)的模式。<ul><li><code>PriorityQueue</code>：即优先队列，底层基于<strong>优先堆的一个无界队列</strong>来实现，无界但可选容量界限。这个优先队列中的元素可以默认自然排序或者通过提供的<code>Comparator</code>（比较器）在队列实例化的时排序，而不是先进先出。不允许空值、不支持<code>non-comparable</code>（不可比较）的对象，每次从队列中取出的是具有最高优先权的元素，线程不安全。</li><li><code>ArrayBlockingQueue</code>：底层基于<strong>定长数组</strong>的阻塞队列实现，即是线程安全的有界阻塞队列。<code>ArrayBlockingQueue</code>内部通过<strong>互斥锁</strong>保护竞争资源，实现了多线程对竞争资源的互斥访问。队列中的锁是没有分离的，所以在添加的同时就不能读取，读取的同时就不能添加，所以锁方面性能不如<code>LinkedBlockingQueue</code>。</li><li><code>LinkedBlockingQueue</code>：即链接队列，底层基于<strong>单向链表</strong>的阻塞队列实现，无界但可选容量界限，线程安全。队列中的锁是分离的，即添加用的是<code>putLock</code>，获取是<code>takeLock</code>，所以在添加获取方面理论上性能会高于<code>ArrayBlockingQueue</code>。所以<code>LinkedBlockingQueue</code>更适合实现生产者-消费者队列。</li><li><code>PriorityBlockingQueue</code>：即优先阻塞队列，底层基于<strong>优先堆的一个无界队列</strong>来实现，无界但可选容量界限的阻塞队列，线程安全，功能同<code>PriorityQueue</code>、<code>LinkedBlockQueue</code>相似。其所含对象的排序不是先进先出，而是依据对象的自然排序顺序或者是构造函数的<code>Comparator</code>决定的顺序。</li><li><code>SynchronousQueue</code>：即同步队列，是一种线程安全无缓冲的无界阻塞队列。其操作必须是放和取交替完成的，即每个<code>put</code>必须等待一个<code>take</code>，反之亦然。</li><li><code>DelayQueue</code>：即延迟队列，是一种有序无界阻塞队列，只有在延迟期满时才能从中提取元素，线程安全。</li><li><code>ArrayDeque</code>：底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用<code>Stack</code>，而是推荐使用更高效的<code>ArrayDeque</code>来实现栈的功能，非线程安全。</li><li><code>LinkedBlockingDeque</code>：底层采用了<strong>双向链表</strong>实现的<strong>双端阻塞并发</strong>队列，无限扩展且可选容量。该阻塞队列同时支持<code>FIFO</code>和<code>FILO</code>两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>ConcurrentLinkedDeque</code>：底层采用了<strong>双向链表</strong>实现的<strong>双端非阻塞并发</strong>队列，无限扩展且可选容量。该队列同时支持<code>FIFO</code>和<code>FILO</code>两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>LinkedTransferQueue</code>：底层采用了<strong>单向链表</strong>实现的<strong>无界传输阻塞</strong>队列，先进先出，无限扩展且可选容量线程安全。</li></ul></li></ul></li><li><code>Map</code>：<code>Map</code>代表具有映射关系的集合。<ul><li><code>HashMap</code>：底层是用<strong>链表数组</strong>，<code>Java8</code>后又加了<strong>红黑树</strong>来实现，键无序不可重复可为null、值可重复可为null，存取速度快，线程不安全。<ul><li><code>LinkedHashMap</code>：底层是用<strong>链表数组</strong>存储，并用双向链表记录插入顺序，键有序不可重复可为null、值可重复可为null，存取速度快较<code>HashMap</code>略慢，比<code>TreeMap</code>快，线程不安全。</li></ul></li><li><code>HashTable</code>：底层是用<strong>链表数组</strong>，键无序不可重复可为null、值可重复可为null，存取速度较<code>HashMap</code>慢，线程安全。<ul><li><code>Properties</code>：是<code>HashTable</code>的子类，是&lt;String,String&gt;的映射，比<code>HashTable</code>多了<code>load</code>、<code>store</code>两个方法，线程安全。</li></ul></li><li><code>TreeMap</code>：底层使用红黑树来实现，内部使用了<code>Comparator</code>，按自然顺序或自定义顺序存放键，键不可重复不可为null、值可重复可为null，存取速度较<code>HashMap</code>慢，线程不安全。</li><li><code>EnumMap</code>：底层使用数组来实现，是专门为枚举类型量身定做的Map，性能更好。只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以<code>EnumMap</code>使用数组来存放与枚举类型对应的值，线程不安全。</li><li><code>WeakHashMap</code>：同<code>HashMap</code>基本相似。区别在于，<code>HashMap</code>的<code>key</code>保留对象的强引用，这意味着只要该<code>HashMap</code>对象不被销毁，该<code>HashMap</code>对象所有key所引用的对象不会被垃圾回收，<code>HashMap</code>也不会自动删除这些<code>key</code>所对应的<code>key-value</code>对象；但<code>WeakHashMap</code>的<code>key</code>只保留对实际对象的弱引用，这意味着当垃圾回收了该<code>key</code>所对应的实际对象后，<code>WeakHashMap</code>会自动删除该<code>key</code>对应的<code>key-value</code>对象。</li><li><code>IdentityHashMap</code>：同<code>HashMap</code>基本相似。区别在于，在处理两个<code>key</code>相等时，对于普通<code>HashMap</code>而言，只要<code>key1</code>和<code>key2</code>通过<code>equals</code>比较返回<code>true</code>时就认为key相同；在<code>IdentityHashMap</code>中，当且仅当两个<code>key</code>严格相等时(<code>key1 = key2</code>)时才认为两个<code>key</code>相同。</li><li><code>ConcurrentHashMap</code>：底层使用<strong>锁分段</strong>技术来实现线程安全，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。<code>Segment</code>是一种可重入锁<code>ReentrantLock</code>，在<code>ConcurrentHashMap</code>里扮演锁的角色，<code>HashEntry</code>则用于存储键值对数据。一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组，<code>Segment</code>的结构和<code>HashMap</code>类似，是一种数组和链表结构， 一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每个<code>HashEntry</code>是一个链表结构的元素， 每个<code>Segment</code>守护者一个<code>HashEntry</code>数组里的元素,当对<code>HashEntry</code>数组的数据进行修改时，必须首先获得它对应的<code>Segment</code>锁。</li><li><code>ConcurrentSkipListMap</code>：底层使用<strong>跳跃列表</strong>来实现，适用于<strong>高并发</strong>的场景，内部使用了<code>ConcurrentNavigableMap</code>，同<code>TreeMap</code>功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补<code>ConcurrentHashMap</code>不支持排序的问题。</li></ul></li></ul><p>Java集合框架功能介绍思维导图如下：</p><p><img src="http://static.blinkfox.com/Java_collections_mind.png" alt="Java集合框架功能介绍思维导图"></p><h3 id="一些概念解释"><a href="#一些概念解释" class="headerlink" title="一些概念解释"></a>一些概念解释</h3><ul><li><strong>跳表</strong>：是一种采用了用空间换时间思想的数据结构。它会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。</li><li><strong>阻塞队列和非阻塞的区别</strong>：如果队列里面已经放满了，如果是阻塞队列那么线程会一直阻塞，而非阻塞对垒则会抛出异常。</li></ul><h3 id="一些数据结构的优缺点"><a href="#一些数据结构的优缺点" class="headerlink" title="一些数据结构的优缺点"></a>一些数据结构的优缺点</h3><ul><li><strong>Hash表</strong>：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。</li><li><strong>红黑树</strong>：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。</li><li><strong>SkipList</strong>：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。</li></ul><h2 id="一些接口的主要方法梳理"><a href="#一些接口的主要方法梳理" class="headerlink" title="一些接口的主要方法梳理"></a>一些接口的主要方法梳理</h2><h3 id="Collection接口中的抽象方法"><a href="#Collection接口中的抽象方法" class="headerlink" title="Collection接口中的抽象方法"></a>Collection接口中的抽象方法</h3><ul><li><code>int size()</code>，返回集合的大小</li><li><code>boolean isEmpty()</code>，返回集合是否为空的布尔值</li><li><code>boolean contains(Object o)</code>，返回集合是否包含元素<code>o</code>的布尔值</li><li><code>Iterator&lt;E&gt; iterator()</code>，返回该集合中元素的迭代器，继承自<code>Iterable</code>接口</li><li><code>Object[] toArray()</code>，返回一个包含此集合中所有元素的数组</li><li><code>&lt;T&gt; T[] toArray(T[] a)</code>，<code>toArray()</code>方法的泛型版本，返回一个包含此集合中所有元素的数组，返回类型由传入数组参数的类型决定</li><li><code>boolean add(E e)</code>，返回向集合中插入元素<code>e</code>是否成功的布尔值</li><li><code>boolean remove(Object o)</code>，返回从集合中删除元素<code>o</code>是否成功的布尔值</li><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>，返回本集合中是否完全包含集合<code>c</code>的布尔值，即判断集合<code>c</code>是否是本集合子集</li><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>，将集合<code>c</code>中的所有元素添加到本集合中并返回</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>，移除本集合中所有包含集合<code>c</code>的所有元素</li><li><code>default boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，Java8新增的接口默认方法。将会批量删除符合filter条件的所有元素，该方法需要一个Predicate对象作为作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。</li><li><code>boolean retainAll(Collection&lt;?&gt; c)</code>，返回本集合和集合<code>c</code>中相同的元素并存到本集合中,集合<code>c</code>保持不变，返回值表示的是本集合是否发生过改变。即该方法是用来求两个集合的交集，交集的结果存到本集合中，如果本集合没发生变化则返回<code>true</code></li><li><code>void clear()</code>，清空本集合中的所有元素</li><li><code>boolean equals(Object o)</code>，返回本集合是否和对象<code>o</code>相等的布尔值</li><li><code>int hashCode()</code>，返回此集合的<code>Hash</code>码值</li><li><code>default Spliterator&lt;E&gt; spliterator()</code>，在集合中创建<code>Spliterator</code>对象<ul><li><code>Spliterator</code>是Java 8引入的新接口，顾名思义，<code>Spliterator</code>可以理解<code>Iterator</code>的<code>Split</code>版本（但用途要丰富很多）。使用<code>Iterator</code>的时候，我们可以顺序地遍历容器中的元素，使用<code>Spliterator</code>的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用<code>Spliterator</code>每次可以处理某个元素集合中的一个元素 — 不是从<code>Spliterator</code>中获取元素，而是使用<code>tryAdvance()</code>或<code>forEachRemaining()</code>方法对元素应用操作。但<code>Spliterator</code>还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成。</li></ul></li><li><code>default Stream&lt;E&gt; stream()</code>，返回一个顺序的<code>Stream</code>对象。Java8引入了Stream以实现对集合更方便地进行函数式编程。</li><li><code>default Stream&lt;E&gt; parallelStream()</code>，返回一个可能并行的<code>Stream</code>对象。Java8新增的方法。流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。</li></ul><h3 id="List接口中的额外抽象方法"><a href="#List接口中的额外抽象方法" class="headerlink" title="List接口中的额外抽象方法"></a>List接口中的额外抽象方法</h3><ul><li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>，将指定集合<code>c</code>中的所有元素插入到指定索引位置处</li><li><code>default void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，Java8新增的使用<code>Lambda</code>的方式，通过应用<code>UnaryOperator</code>获得的结果来替换列表中的每个元素</li><li><code>default void sort(Comparator&lt;? super E&gt; c)</code>，在比较器的基础上将本列表排序</li><li><code>E get(int index)</code>，获取本集合中指定索引位置处的元素</li><li><code>E set(int index, E element)</code>，设置或替换本集合中指定索引位置处的元素</li><li><code>void add(int index, E element)</code>，在本集合中的指定索引位置处插入指定的元素</li><li><code>E remove(int index)</code>，移除本集合中指定索引位置处的元素</li><li><code>int indexOf(Object o)</code>，返回指定元素第一次出现的索引位置</li><li><code>int lastIndexOf(Object o)</code>，返回指定元素最后出现的索引位置</li><li><code>ListIterator&lt;E&gt; listIterator()</code>，返回本集合中的<code>ListIterator</code>迭代器</li><li><code>ListIterator&lt;E&gt; listIterator(int index)</code>，返回本集合中从指定索引位置开始的<code>ListIterator</code>迭代器</li><li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>，返回指定开始和结束索引位置的子集合</li></ul><h3 id="Set接口中的额外抽象方法"><a href="#Set接口中的额外抽象方法" class="headerlink" title="Set接口中的额外抽象方法"></a>Set接口中的额外抽象方法</h3><p>无</p><h3 id="Map接口中的抽象方法"><a href="#Map接口中的抽象方法" class="headerlink" title="Map接口中的抽象方法"></a>Map接口中的抽象方法</h3><ul><li><code>boolean containsKey</code>，判断本Map集合中是否包含指定的key键</li><li><code>boolean containsValue</code>，判断本Map集合中是否包含指定的value值</li><li><code>V get(Object key)</code>，根据key获取本Map集合中的value值</li><li><code>V get(Object key)</code>，向本Map集合中存放key键和value值,返回value值</li><li><code>V remove(Object key)</code>，根据key删除本Map集合中的key和value值，并返回删除的value值</li><li><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code>，将指定的Map集合添加到本的Map集合当中</li><li><code>Set&lt;K&gt; keySet()</code>，获取本Map集合中的所有key值，并以Set接口的结果作为返回</li><li><code>Collection&lt;V&gt; values()</code>，获取本Map集合中的所有value值，并以Collection接口的结果作为返回</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>，获取本Map集合中的所有key和value值，并以<code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>的结果作为返回</li><li><code>default V getOrDefault(Object key, V defaultValue)</code>，根据key获取本Map集合中的value值，如果没找到对应的值或者value值是null,则返回<code>defaultValue</code>的值</li><li><code>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code>，Java8新增的使用<code>Lambda</code>的方式遍历操作Map中的元素的默认接口方法</li><li><code>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code>，Java8新增的使用<code>Lambda</code>的方式遍历替换Map中的元素的默认接口方法</li><li><code>default V putIfAbsent(K key, V value)</code>，Java8新增的不用写是否为null值的检测语句向Map中保存key和value的元素的默认接口方法，即如果通过key获取到的value是空的，则在调用<code>put(key, value)</code>方法并返回value值</li><li><code>default boolean remove(Object key, Object value)</code>，Java8新增的默认接口方法，删除给定key所对应的元素，如果value不存在、为null或者与参数中的value不等，则不能删除。即删除操作需要满足给定的值需要和map中的值相等的条件</li><li><code>default boolean replace(K key, V oldValue, V newValue)</code>，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不存在、为null或者与参数中的oldValue不等，则不能替换。即替换操作需要满足给定的值需要和map中的值相等的条件</li><li><code>default V replace(K key, V value)</code>，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不为null，则value值与参数中的value值做替换。</li><li><code>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>，Java8新增的默认接口方法，根据key获取到的value如果不为null，则直接返回value值，否则将<code>Lambda</code>表达式中的结果值存放到Map中</li><li><code>default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，Java8新增的默认接口方法，根据key获取到的value和新计算的值如果不为null，则直接新计算的值，否则移除该key，且返回null</li><li><code>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，Java8新增的默认接口方法，将<code>Lambda</code>表达式中的结果值存放到Map中，如果计算的新值为null则返回null，且移除以前有的key和value值</li><li><code>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>，Java8新增的默认接口方法，将新计算的值覆盖Map中原key对应的value值</li></ul><h3 id="SortedSet接口中的额外抽象方法"><a href="#SortedSet接口中的额外抽象方法" class="headerlink" title="SortedSet接口中的额外抽象方法"></a>SortedSet接口中的额外抽象方法</h3><ul><li><code>Comparator&lt;? super E&gt; comparator()</code>，返回本SortedSet集合中的<code>Comparator</code>比较器</li><li><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code>，获取开始元素和结束元素之间的子SortedSet集合</li><li><code>SortedSet&lt;E&gt; headSet(E toElement)</code>，获取开始元素和<code>toElement</code>元素之间的子SortedSet集合</li><li><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code>，获取<code>fromElement</code>元素和结束元素之间的子SortedSet集合</li><li><code>E first()</code>，获取本SortedSet集合中的第一个元素</li><li><code>E last()</code>，获取本SortedSet集合中的最后一个元素</li></ul><h3 id="SortedMap接口中的额外抽象方法"><a href="#SortedMap接口中的额外抽象方法" class="headerlink" title="SortedMap接口中的额外抽象方法"></a>SortedMap接口中的额外抽象方法</h3><ul><li><code>Comparator&lt;? super K&gt; comparator()</code>，返回本SortedMap集合中的<code>Comparator</code>比较器</li><li><code>SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)</code>，获取开始key和结束key之间的子SortedMap集合</li><li><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code>，获取开始key和<code>toKey</code>元素之间的子SortedMap集合</li><li><code>SortedMap&lt;K,V&gt; tailMap(K fromKey)</code>，获取<code>fromKey</code>元素和结束key之间的子SortedMap集合</li><li><code>K firstKey()</code>，获取本SortedMap集合中的第一个key</li><li><code>K lastKey()</code>，获取本SortedMap集合中的最后一个key</li><li><code>Set&lt;K&gt; keySet()</code>，获取本SortedMap集合中所有key的Set集合</li><li><code>Collection&lt;V&gt; values()</code>，获取本SortedMap集合中所有value的Collection集合</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>，获取本SortedMap集合中所有key和value的Map集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UML各类关系介绍</title>
      <link href="/2018/10/22/ruan-jian-she-ji/uml-ge-lei-guan-xi-jie-shao/"/>
      <url>/2018/10/22/ruan-jian-she-ji/uml-ge-lei-guan-xi-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="继承关系（generalization）"><a href="#继承关系（generalization）" class="headerlink" title="继承关系（generalization）"></a>继承关系（generalization）</h2><p><strong>继承</strong>关系用一条带<strong>空心箭头的直线</strong>表示。如下图所示（A继承自B）：</p><p><img src="http://static.blinkfox.com/uml_demo_1.png" alt="A继承自B"></p><p><strong>继承</strong>指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。<strong>继承关系为<code>is-a</code>的关系</strong>，是类与类或者接口与接口之间最常见的关系之一，在Java中此类关系通过关键字<code>extends</code>来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，继承关系表现为<strong>一个类继承另一个类或者一个接口继承另一个接口</strong>。</p></blockquote><h2 id="实现关系（realization）"><a href="#实现关系（realization）" class="headerlink" title="实现关系（realization）"></a>实现关系（realization）</h2><p><strong>实现</strong>关系是用一条带<strong>空心箭头的虚线</strong>表示。如下图所示（A实现B）：：</p><p><img src="http://static.blinkfox.com/uml_demo_2.png" alt="A实现B"></p><p><strong>实现</strong>指的是一个<code>class</code>类实现<code>interface</code>接口（可以是多个）的功能。实现是类与接口之间最常见的关系之一，在Java中此类关系通过关键字<code>implements</code>来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，实现关系表现为<strong>普通类实现某个接口</strong>。</p></blockquote><h2 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h2><p><strong>关联</strong>关系是用一条<strong>可能会有方向的直线</strong>表示的。关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如上图，表示A关联B，但B不关联A；如下图所示：</p><p><img src="http://static.blinkfox.com/uml_demo_3.png" alt="A关联B"></p><p><strong>关联</strong>关系体现的是两个类、或者类与接口之间语义级别的一种强依赖的结构关系，是一种长期的静态稳定的关系，通常与运行状态无关，一般由常识等因素决定的。</p><p>例如：乘车人和车票之间就是一种关联关系。</p><blockquote><p><strong>注意</strong>：表现在代码中，<strong>被关联类以类属性的形式出现在关联类中，也可能是关联类引用了一个类型为被关联类的全局变量</strong>。</p></blockquote><h2 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h2><p><strong>聚合</strong>关系用一条带<strong>空心菱形箭头的直线</strong>表示，如下图所示A聚合到B，或者说B由A组成。</p><p><img src="http://static.blinkfox.com/uml_demo_4.png" alt="A聚合到B"></p><p><strong>聚合</strong>关系用于表示实体对象之间的关系，表示整体由部分构成的意思。<strong>聚合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即<code>has-a</code>的关系</strong>，此时整体与部分之间是<strong>可分离</strong>的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。例如一个部门由多个员工组成。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。聚合与组合不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在。</p></blockquote><h2 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h2><p><strong>组合</strong>关系用一条带<strong>实心菱形箭头的直线</strong>表示，如下图表示A组成B，或者B由A组成。</p><p><img src="http://static.blinkfox.com/uml_demo_5.png" alt="A组合到B"></p><p><strong>组合</strong>关系同样表示整体由部分组成的意思。与聚合关系一样，<strong>组合也是关联关系的一种特例，它体现的是一种整体与部分不可分割的关系，即<code>contains-a</code>的关系，这种关系比聚合更强，也称为强聚合</strong>。例如公司由多个部门组成组合，但此时整体与部分是<strong>不可分离</strong>的，整体的生命周期结束也就意味着部分的生命周期结束。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也就不存在了。例如，公司不存在了，部门也将不存在了。</p></blockquote><h2 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h2><p><strong>依赖</strong>关系是用一套<strong>带箭头的虚线</strong>表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系。</p><p><img src="http://static.blinkfox.com/uml_demo_6.png" alt="A依赖于B"></p><p><strong>依赖</strong>关系是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A，与关联关系不同的是，它是一种<strong>临时性</strong>的关系，通常在运行期间产生，并且随着运行时的变化依赖关系也可能发生变化。</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p><blockquote><p><strong>注意</strong>：表现在代码中，依赖关系体现为<strong>类的构造方法及类方法的传入参数</strong>。</p></blockquote><h2 id="UML类关系图示例"><a href="#UML类关系图示例" class="headerlink" title="UML类关系图示例"></a>UML类关系图示例</h2><p>请看以下这个UML类关系图：</p><p><img src="http://static.blinkfox.com/uml_demo_0.png" alt="UML示例"></p><ul><li>开车的类图结构表示的是一个接口</li><li>有一个自行车的抽象类，实现了开车的接口，它们之间的关系为实现关系，使用带空心三角箭头的虚线表示</li><li>自行车与摩拜单车之间是继承关系，使用带空心三角箭头的实线表示</li><li>学生上学需要用到摩拜单车，与摩拜单车是一种依赖关系，使用带箭头的虚线表示</li><li>学生与身份证之间为关联关系，使用一根实线表示，如果两个类之间互相通过属性引用，则是双向关联关系</li><li>学生与班级、学生与学校之间是聚合关系，使用带空心菱形箭头的实线表示</li><li>学校与班级是组合关系，使用带实心菱形箭头的实线表示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象编程的理解</title>
      <link href="/2018/10/21/bian-cheng-zhi-dao/mian-xiang-dui-xiang-bian-cheng-de-li-jie/"/>
      <url>/2018/10/21/bian-cheng-zhi-dao/mian-xiang-dui-xiang-bian-cheng-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><h3 id="面向过程思想概述"><a href="#面向过程思想概述" class="headerlink" title="面向过程思想概述"></a>面向过程思想概述</h3><p>面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</p><h3 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h3><p>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。</p><h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul><li>抽象</li><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：</p><ul><li>数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)</li><li>过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。</p><h4 id="封装的原则"><a href="#封装的原则" class="headerlink" title="封装的原则"></a>封装的原则</h4><ul><li>将不需要对外提供的内容都隐藏起来</li><li>把属性都隐藏，提供公共方法对其访问</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。</p><h4 id="继承概念的实现方式"><a href="#继承概念的实现方式" class="headerlink" title="继承概念的实现方式"></a>继承概念的实现方式</h4><ul><li>类继承：类继承是指直接使用基类的属性和方法而无需额外编码。</li><li>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h4 id="实现多态的方式"><a href="#实现多态的方式" class="headerlink" title="实现多态的方式"></a>实现多态的方式</h4><ul><li>重载</li><li>重写</li><li>实现接口</li></ul><h2 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h2><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了<strong>代码重用</strong>。而多态则是为了实现另一个目的：<strong>接口重用</strong>！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><h3 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h3><p>就是不断的创建对象，使用对象，指挥对象做事情。</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>更好的管理和维护对象之间的关系。</p><h3 id="面向对象优点"><a href="#面向对象优点" class="headerlink" title="面向对象优点"></a>面向对象优点</h3><ul><li>更符合我们思想习惯的思想</li><li>将复杂的事情简单化</li><li>将我们从执行者变成了指挥者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之建造者模式</title>
      <link href="/2018/10/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-jian-zao-zhe-mo-shi/"/>
      <url>/2018/10/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><code>Builder</code>：抽象建造者</li><li><code>ConcreteBuilder</code>：具体建造者</li><li><code>Director</code>：导演者</li><li><code>Product</code>：产品角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Builder.jpg" alt="建造者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是产品类：</p><pre><code class="java">/** * 产品类. * * Created by blinkfox on 2016/10/8. */public class Product {    private String part1;    private String part2;    /* getter 和 setter方法. */    public String getPart1() {        return part1;    }    public void setPart1(String part1) {        this.part1 = part1;    }    public String getPart2() {        return part2;    }    public void setPart2(String part2) {        this.part2 = part2;    }}</code></pre><p>其实，是抽象的建造者<code>Builder</code>接口和具体的建造者<code>ConcreteBuilder</code>类：</p><pre><code class="java">/** * 抽象的建造者. * * Created by blinkfox on 2016/10/8. */public interface Builder {    /**     * 产品建造部分1.     */    void buildPart1();    /**     * 产品建造部分2.     */    void buildPart2();    /**     * 得到建造的产品.     *     * @return 产品     */    Product getResult();}</code></pre><pre><code class="java">/** * 具体的建造者实现类. * * Created by blinkfox on 2016/10/8. */public class ConcreteBuilder implements Builder {    /** 产品. */    private Product product = new Product();    /**     * 产品建造部分1.     */    @Override    public void buildPart1() {        product.setPart1(&quot;编号：95757&quot;);    }    /**     * 产品建造部分2.     */    @Override    public void buildPart2() {        product.setPart2(&quot;名称：小机器人&quot;);    }    /**     * 得到建造的产品.     *     * @return 产品     */    @Override    public Product getResult() {        return product;    }}</code></pre><p>最后，导演者<code>Director</code>类：</p><pre><code class="java">/** * 导演者类. * * Created by blinkfox on 2016/10/8. */public class Director {    /** 当前需要的建造者对象. */    private Builder builder;    /**     * 构造方法.     *     * @param builder     */    public Director(Builder builder) {        this.builder = builder;    }    /**     * 产品构造方法，负责调用各个零件建造方法.     */    public void construct() {        builder.buildPart1();        builder.buildPart2();    }}</code></pre><p>以下是建造者模式的客户端场景类：</p><pre><code class="java">/** * 建造者模式的客户端场景类. * * Created by blinkfox on 2016/10/8. */public class BuilderClient {    /**     * 主入口方法.     *     * @param args 数组参数     */    public static void main(String[] args) {        Builder builder = new ConcreteBuilder();        Director director = new Director(builder);        director.construct();        Product product = builder.getResult();        System.out.println(product.getPart1());        System.out.println(product.getPart2());    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类<code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>建造者模式的优点：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>建造者模式的缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="4-建造者模式与抽象工厂模式的比较"><a href="#4-建造者模式与抽象工厂模式的比较" class="headerlink" title="4. 建造者模式与抽象工厂模式的比较"></a>4. 建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之外观模式</title>
      <link href="/2018/10/18/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-wai-guan-mo-shi/"/>
      <url>/2018/10/18/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-wai-guan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><blockquote><p><strong>外观模式</strong>(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p></blockquote><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>外观模式包含如下角色：</p><ul><li><code>Facade</code>: 外观角色</li><li><code>SubSystem</code>: 子系统角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Facade.jpg" alt="命令模式结构图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是各个子系统角色类，分别如下：</p><pre><code class="java">/** * 子系统类A. * * Created by blinkfox on 16/8/25. */public class ClassA {    public void doSomethingA() {        System.out.println(&quot;----业务方法A...&quot;);    }}</code></pre><pre><code class="java">/** * 子系统类B. * * Created by blinkfox on 16/8/25. */public class ClassB {    public void doSomethingB() {        System.out.println(&quot;----业务方法B...&quot;);    }}</code></pre><pre><code class="java">/** * 子系统类C. * * Created by blinkfox on 16/8/25. */public class ClassC {    public void doSomethingC() {        System.out.println(&quot;----业务方法C...&quot;);    }}</code></pre><p>以下是外观模式的外观类：</p><pre><code class="java">/** * 外观门面类. * * Created by blinkfox on 16/8/25. */public class Facade {    private ClassA a = new ClassA();    private ClassB b = new ClassB();    private ClassC c = new ClassC();    // 以下是提供给外部访问的方法.    public void methodA() {        this.a.doSomethingA();    }    public void methodB() {        this.b.doSomethingB();    }    public void methodC() {        this.c.doSomethingC();    }}</code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“<strong>迪米特法则</strong>”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><ul><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>外观模式的优点k：</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>外观模式的缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“<strong>开闭原则</strong>”。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="五、模式总结"><a href="#五、模式总结" class="headerlink" title="五、模式总结"></a>五、模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之中介者模式</title>
      <link href="/2018/10/17/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhong-jie-zhe-mo-shi/"/>
      <url>/2018/10/17/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>中介者模式(<code>Mediator Pattern</code>)</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为<strong>调停者模式</strong>，它是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><code>Mediator</code>: 抽象中介者</li><li><code>ConcreteMediator</code>: 具体中介者</li><li><code>Colleague</code>: 抽象同事类</li><li><code>ConcreteColleague</code>: 具体同事类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Mediator.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Mediator</code>类和具体的<code>ConcreteMediator</code>类：</p><pre><code class="java">/** * 通用抽象中介者类. * * Created by blinkfox on 16/8/21. */public abstract class Mediator {    /** 定义同事类1. */    protected ConcreteColleague1 colleague1;    /** 定义同事类2. */    protected ConcreteColleague2 colleague2;    /* getter 和 setter 方法 */    public ConcreteColleague1 getColleague1() {        return colleague1;    }    public void setColleague1(ConcreteColleague1 colleague1) {        this.colleague1 = colleague1;    }    public ConcreteColleague2 getColleague2() {        return colleague2;    }    public void setColleague2(ConcreteColleague2 colleague2) {        this.colleague2 = colleague2;    }    /**     * 中介者模式的抽象业务逻辑1.     */    public abstract void doSomething1();    /**     * 中介者模式的抽象业务逻辑2.     */    public abstract void doSomething2();}</code></pre><pre><code class="java">/** * 具体的通用中介者类. * * Created by blinkfox on 16/8/21. */public class ConcreteMediator extends Mediator {    /**     * 中介者模式的具体业务逻辑1.     */    @Override    public void doSomething1() {        super.colleague1.selfMethod1();        super.colleague2.selfMethod2();    }    /**     * 中介者模式的具体业务逻辑2.     */    @Override    public void doSomething2() {        super.colleague1.selfMethod1();        super.colleague2.selfMethod2();    }}</code></pre><p>其实，是抽象的<code>Colleague</code>类和具体的<code>ConcreteColleague</code>类：</p><pre><code class="java">/** * 抽象的同事类. * * Created by blinkfox on 16/8/21. */public abstract class Colleague {    /** 中介者. */    protected Mediator mediator;    public Colleague(Mediator mediator) {        this.mediator = mediator;    }}</code></pre><pre><code class="java">/** * 具体的同事类1. * * Created by blinkfox on 16/8/21. */public class ConcreteColleague1 extends Colleague {    public ConcreteColleague1(Mediator mediator) {        super(mediator);    }    /**     * 自有方法.     */    public void selfMethod1() {        System.out.println(&quot;------ConcreteColleague1-处理自己的业务逻辑1--------&quot;);    }    /**     * 依赖方法.     */    public void depMethod1() {        System.out.println(&quot;------ConcreteColleague1-委托给中介者的业务逻辑1--------&quot;);        super.mediator.doSomething1();    }}</code></pre><pre><code class="java">/** * 具体的同事类2. * * Created by blinkfox on 16/8/21. */public class ConcreteColleague2 extends Colleague {    public ConcreteColleague2(Mediator mediator) {        super(mediator);    }    /**     * 自有方法2.     */    public void selfMethod2() {        System.out.println(&quot;------ConcreteColleague2-处理自己的业务逻辑2--------&quot;);    }    /**     * 依赖方法2.     */    public void depMethod2() {        System.out.println(&quot;------ConcreteColleague2-委托给中介者的业务逻辑2--------&quot;);        super.mediator.doSomething2();    }}</code></pre><p>以下是中介者模式的客户端场景类：</p><pre><code class="java">/** * 中介者模式的场景类 * Created by blinkfox on 16/8/21. */public class MediatorClient {    public static void main(String[] args) {        Mediator mediator = new ConcreteMediator();        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);        mediator.setColleague1(colleague1);        mediator.setColleague2(colleague2);        colleague1.depMethod1();        colleague2.depMethod2();        mediator.doSomething1();        mediator.doSomething2();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>中介者模式的优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>中介者模式的缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂，使得系统难以维护</strong>。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之命令模式</title>
      <link href="/2018/10/16/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ming-ling-mo-shi/"/>
      <url>/2018/10/16/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ming-ling-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>命令模式(<code>Command Pattern</code>)</strong>：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>命令模式包含如下角色：</p><ul><li><code>Command</code>: 抽象命令类</li><li><code>ConcreteCommand</code>: 具体命令类</li><li><code>Invoker</code>: 调用者</li><li><code>Receiver</code>: 接收者</li><li><code>Client</code>: 客户类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Command.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Receiver</code>类和具体的<code>Receiver</code>类：</p><pre><code class="java">/** * 通用的抽象 Receiver 接收者. * * Created by blinkfox on 16/8/17. */public abstract class Receiver {    /**     * 定义每个接收者都必须完成的业务.     */    public abstract void doSomething();}</code></pre><pre><code class="java">/** * 具体的 Receiver 类1. * * Created by blinkfox on 16/8/17. */public class ConcreteReceiver1 extends Receiver {    @Override    public void doSomething() {        System.out.println(&quot;ConcreteReceiver1 处理的业务逻辑...&quot;);    }}</code></pre><pre><code class="java">/** * 具体的 Receiver 类2. * * Created by blinkfox on 16/8/17. */public class ConcreteReceiver2 extends Receiver {    @Override    public void doSomething() {        System.out.println(&quot;ConcreteReceiver2 处理的业务逻辑...&quot;);    }}</code></pre><p>其实，是抽象的<code>Command</code>类和具体的<code>Command</code>类：</p><pre><code class="java">/** * 抽象的 Command 类. * * Created by blinkfox on 16/8/17. */public abstract class Command {    /**     * 命令的抽象执行命令的方法.     */    public abstract void execute();}</code></pre><pre><code class="java">/** * 具体的 Command 命令类1. * * Created by blinkfox on 16/8/17. */public class ConcreteCommand1 extends Command {    /** 对哪个receiver类进行处理. */    private Receiver receiver;    public ConcreteCommand1(Receiver receiver) {        this.receiver = receiver;    }    /**     * 必须实现的一个命令.     */    @Override    public void execute() {        this.receiver.doSomething();    }}</code></pre><pre><code class="java">/** * 具体的 Command 命令类2. * * Created by blinkfox on 16/8/17. */public class ConcreteCommand2 extends Command {    /** 对哪个receiver类进行处理. */    private Receiver receiver;    public ConcreteCommand2(Receiver receiver) {        this.receiver = receiver;    }    /**     * 必须实现的命令.     */    @Override    public void execute() {        this.receiver.doSomething();    }}</code></pre><p>最后，调用者<code>Invoker</code>类：</p><pre><code class="java">/** * 调用者 Invoker 类. * * Created by blinkfox on 16/8/17. */public class Invoker {    private Command command;    public void setCommand(Command command) {        this.command = command;    }    /**     * 执行命令.     */    public void action() {        this.command.execute();    }}</code></pre><p>以下是命令模式的客户端场景类：</p><pre><code class="java">/** * 命令模式的场景类. * * Created by blinkfox on 16/8/17. */public class CommandClient {    public static void main(String[] args) {        Invoker invoker = new Invoker();        Receiver receiver = new ConcreteReceiver1();        Command command = new ConcreteCommand1(receiver);        // 把命令交给调用者执行        invoker.setCommand(command);        invoker.action();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>命令模式的优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的<code>Undo</code>和<code>Redo</code>。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>命令模式的缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代码整洁之道内容概要</title>
      <link href="/2018/10/15/bian-cheng-zhi-dao/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/"/>
      <url>/2018/10/15/bian-cheng-zhi-dao/dai-ma-zheng-ji-zhi-dao-nei-rong-gai-yao/</url>
      
        <content type="html"><![CDATA[<p>读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！</p><h2 id="一、在正式开始之前，我们先思考几个几个问题："><a href="#一、在正式开始之前，我们先思考几个几个问题：" class="headerlink" title="一、在正式开始之前，我们先思考几个几个问题："></a>一、在正式开始之前，我们先思考几个几个问题：</h2><h3 id="1-需求与代码哪个重要？"><a href="#1-需求与代码哪个重要？" class="headerlink" title="1.需求与代码哪个重要？"></a>1.需求与代码哪个重要？</h3><p>答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。</p><h3 id="2-易读和易懂是一回事吗？"><a href="#2-易读和易懂是一回事吗？" class="headerlink" title="2.易读和易懂是一回事吗？"></a>2.易读和易懂是一回事吗？</h3><p>答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。</p><h3 id="3-什么是测试驱动代码？"><a href="#3-什么是测试驱动代码？" class="headerlink" title="3.什么是测试驱动代码？"></a>3.什么是测试驱动代码？</h3><p>答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。</p><h3 id="4-什么是简单的代码？"><a href="#4-什么是简单的代码？" class="headerlink" title="4.什么是简单的代码？"></a>4.什么是简单的代码？</h3><p>答：<br>1.能通过所有测试<br>2.没有重复代码<br>3.体现系统中全部设计理念<br>4.包含尽量少的实体，包括，类，函数，方法等</p><p>如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。</p><h2 id="二、第二章-有意义的命名"><a href="#二、第二章-有意义的命名" class="headerlink" title="二、第二章 有意义的命名"></a>二、第二章 有意义的命名</h2><h3 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1.名副其实"></a>1.名副其实</h3><p>变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。</p><h3 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2.避免误导"></a>2.避免误导</h3><p>必须避免留下掩藏代码本意的错误线索。</p><h3 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3.做有意义的区分"></a>3.做有意义的区分</h3><p>只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。</p><h3 id="4-使用读得出来的名称"><a href="#4-使用读得出来的名称" class="headerlink" title="4.使用读得出来的名称"></a>4.使用读得出来的名称</h3><p>不要用傻乎乎的自造词，而不是恰当的英语词。</p><h3 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5.使用可搜索的名称"></a>5.使用可搜索的名称</h3><p>使用便于搜索的名字。</p><h3 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6.避免使用编码"></a>6.避免使用编码</h3><p>把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。</p><h3 id="7-避免思维映射"><a href="#7-避免思维映射" class="headerlink" title="7.避免思维映射"></a>7.避免思维映射</h3><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。</p><h3 id="8-类名或对象名最好使用名词或者名词短语"><a href="#8-类名或对象名最好使用名词或者名词短语" class="headerlink" title="8.类名或对象名最好使用名词或者名词短语"></a>8.类名或对象名最好使用名词或者名词短语</h3><h3 id="9-方法名最好使用动词或者动词短语"><a href="#9-方法名最好使用动词或者动词短语" class="headerlink" title="9.方法名最好使用动词或者动词短语"></a>9.方法名最好使用动词或者动词短语</h3><h3 id="10-别扮可爱"><a href="#10-别扮可爱" class="headerlink" title="10.别扮可爱"></a>10.别扮可爱</h3><p>命名一定要通俗易懂。</p><h3 id="11-每一个概念对应一个词"><a href="#11-每一个概念对应一个词" class="headerlink" title="11.每一个概念对应一个词"></a>11.每一个概念对应一个词</h3><p>给每个抽象概念选择一个词，并一以贯之</p><h3 id="12-别用双关语词"><a href="#12-别用双关语词" class="headerlink" title="12.别用双关语词"></a>12.别用双关语词</h3><p>避免将同一个词用于不同目的，遵循一词一义的原则</p><h3 id="13-使用解决方案领域名"><a href="#13-使用解决方案领域名" class="headerlink" title="13.使用解决方案领域名"></a>13.使用解决方案领域名</h3><h3 id="14-使用源自所涉领域名"><a href="#14-使用源自所涉领域名" class="headerlink" title="14.使用源自所涉领域名"></a>14.使用源自所涉领域名</h3><h3 id="15-添加有意义的语境"><a href="#15-添加有意义的语境" class="headerlink" title="15.添加有意义的语境"></a>15.添加有意义的语境</h3><p>在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。</p><h3 id="16-不要添加没用的语境"><a href="#16-不要添加没用的语境" class="headerlink" title="16.不要添加没用的语境"></a>16.不要添加没用的语境</h3><h2 id="三、第三章-函数"><a href="#三、第三章-函数" class="headerlink" title="三、第三章 函数"></a>三、第三章 函数</h2><h3 id="1-短小"><a href="#1-短小" class="headerlink" title="1.短小"></a>1.短小</h3><p>函数第一规则是要短小。第二条规则是还要更短小。</p><h3 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2.只做一件事"></a>2.只做一件事</h3><ul><li>函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。</li><li>函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。</li></ul><h3 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3.每个函数一个抽象层级"></a>3.每个函数一个抽象层级</h3><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h3 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5.使用描述性的名称"></a>5.使用描述性的名称</h3><p>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。</p><h3 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6.函数参数"></a>6.函数参数</h3><ul><li>最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。</li><li>如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数和函数的参数命名一般是动名词比较好。</li></ul><h3 id="7-无副作用"><a href="#7-无副作用" class="headerlink" title="7.无副作用"></a>7.无副作用</h3><h3 id="8-分割指令与查询"><a href="#8-分割指令与查询" class="headerlink" title="8.分割指令与查询"></a>8.分割指令与查询</h3><p>函数要么做什么事，要么回答什么事，但二者不可兼得</p><h3 id="9-使用异常替代返回错误码"><a href="#9-使用异常替代返回错误码" class="headerlink" title="9.使用异常替代返回错误码"></a>9.使用异常替代返回错误码</h3><ul><li>返回错误码的时候，就是在要求调用者立刻处理错误。</li><li>如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。</li><li>抽离try/catch代码块</li></ul><h3 id="10-别重复自己"><a href="#10-别重复自己" class="headerlink" title="10.别重复自己"></a>10.别重复自己</h3><h3 id="11-结构化编程"><a href="#11-结构化编程" class="headerlink" title="11.结构化编程"></a>11.结构化编程</h3><h2 id="四、第四章-注释"><a href="#四、第四章-注释" class="headerlink" title="四、第四章 注释"></a>四、第四章 注释</h2><h3 id="1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"><a href="#1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。" class="headerlink" title="1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"></a>1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。</h3><h3 id="2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"><a href="#2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？" class="headerlink" title="2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"></a>2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？</h3><ul><li>法律信息</li><li>提供信息的注释</li><li>提供意图的解释</li><li>阐释</li><li>警告</li><li>TODO注释</li><li>TODO是一种程序要认为应该要做的，但是由于某种原因没有做的</li><li>放大,放大某些看似不合理的地方</li></ul><h2 id="五、第六章-对象和数据结构"><a href="#五、第六章-对象和数据结构" class="headerlink" title="五、第六章 对象和数据结构"></a>五、第六章 对象和数据结构</h2><h3 id="1-得墨忒定律"><a href="#1-得墨忒定律" class="headerlink" title="1.得墨忒定律"></a>1.得墨忒定律</h3><p>模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。</p><h2 id="六、第七章-错误处理"><a href="#六、第七章-错误处理" class="headerlink" title="六、第七章 错误处理"></a>六、第七章 错误处理</h2><h3 id="1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"><a href="#1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。" class="headerlink" title="1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"></a>1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。</h3><h3 id="2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"><a href="#2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。" class="headerlink" title="2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"></a>2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。</h3><h2 id="七、第八章-边界"><a href="#七、第八章-边界" class="headerlink" title="七、第八章 边界"></a>七、第八章 边界</h2><h3 id="1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"><a href="#1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。" class="headerlink" title="1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"></a>1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。</h3><h2 id="八、第九章-单元测试"><a href="#八、第九章-单元测试" class="headerlink" title="八、第九章 单元测试"></a>八、第九章 单元测试</h2><h3 id="1-TDD三定律"><a href="#1-TDD三定律" class="headerlink" title="1.TDD三定律"></a>1.TDD三定律</h3><ul><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ul><h3 id="2-整洁测试三要素"><a href="#2-整洁测试三要素" class="headerlink" title="2.整洁测试三要素"></a>2.整洁测试三要素</h3><ul><li>可读性</li><li>可读性</li><li>可读性</li></ul><h3 id="3-整洁测试的五条原则："><a href="#3-整洁测试的五条原则：" class="headerlink" title="3.整洁测试的五条原则："></a>3.整洁测试的五条原则：</h3><ul><li>快速，测试应该够快</li><li>独立，测试应该相互独立</li><li>可重复，测试应当可在任何环境中重复通过。</li><li>自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。</li><li>及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h2 id="九、第十章-类"><a href="#九、第十章-类" class="headerlink" title="九、第十章 类"></a>九、第十章 类</h2><h3 id="1-单一权责原则，类或者模块应有且只有一条加以修改的理由。"><a href="#1-单一权责原则，类或者模块应有且只有一条加以修改的理由。" class="headerlink" title="1.单一权责原则，类或者模块应有且只有一条加以修改的理由。"></a>1.单一权责原则，类或者模块应有且只有一条加以修改的理由。</h3><h3 id="2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"><a href="#2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。" class="headerlink" title="2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"></a>2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。</h3><h2 id="十、第十一章-系统"><a href="#十、第十一章-系统" class="headerlink" title="十、第十一章 系统"></a>十、第十一章 系统</h2><h3 id="1-将系统的构造与使用分开"><a href="#1-将系统的构造与使用分开" class="headerlink" title="1.将系统的构造与使用分开"></a>1.将系统的构造与使用分开</h3><p>软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度）</p><h4 id="1-1分解main"><a href="#1-1分解main" class="headerlink" title="1.1分解main"></a>1.1分解main</h4><p>将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。</p><h4 id="1-2工厂模式"><a href="#1-2工厂模式" class="headerlink" title="1.2工厂模式"></a>1.2工厂模式</h4><p>使用该模式可以将系统构造和系统运行时逻辑分开。</p><h4 id="1-3依赖注入（需要强化理解）"><a href="#1-3依赖注入（需要强化理解）" class="headerlink" title="1.3依赖注入（需要强化理解）"></a>1.3依赖注入（需要强化理解）</h4><h4 id="1-4扩容"><a href="#1-4扩容" class="headerlink" title="1.4扩容"></a>1.4扩容</h4><p>“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。</p><h4 id="1-5测试驱动系统架构"><a href="#1-5测试驱动系统架构" class="headerlink" title="1.5测试驱动系统架构"></a>1.5测试驱动系统架构</h4><p>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO))</p><h4 id="1-6优化决策"><a href="#1-6优化决策" class="headerlink" title="1.6优化决策"></a>1.6优化决策</h4><p>模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。</p><h2 id="十一、第十二章-迭进"><a href="#十一、第十二章-迭进" class="headerlink" title="十一、第十二章 迭进"></a>十一、第十二章 迭进</h2><h3 id="1-通过迭进设计达到代码整洁的目的："><a href="#1-通过迭进设计达到代码整洁的目的：" class="headerlink" title="1. 通过迭进设计达到代码整洁的目的："></a>1. 通过迭进设计达到代码整洁的目的：</h3><p>通过这几个原则可以让你的设计变简单（DIP，SRP）</p><ul><li>运行所有测试</li><li>不可重复，</li><li>表达了程序员的意图</li><li>尽可能减少类和方法的数量</li><li>以上规则按其重要程度排序</li></ul><h3 id="2-简单设计规则1-运行所有测试"><a href="#2-简单设计规则1-运行所有测试" class="headerlink" title="2. 简单设计规则1:运行所有测试"></a>2. 简单设计规则1:运行所有测试</h3><p>编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。</p><h3 id="3-简单设计规则2-4：重构"><a href="#3-简单设计规则2-4：重构" class="headerlink" title="3. 简单设计规则2-4：重构"></a>3. 简单设计规则2-4：重构</h3><p>在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。</p><h3 id="4-不可重复"><a href="#4-不可重复" class="headerlink" title="4. 不可重复"></a>4. 不可重复</h3><h3 id="5-表达力"><a href="#5-表达力" class="headerlink" title="5. 表达力"></a>5. 表达力</h3><h3 id="6-尽可能少的类和方法"><a href="#6-尽可能少的类和方法" class="headerlink" title="6. 尽可能少的类和方法"></a>6. 尽可能少的类和方法</h3><h2 id="十二、第十三章-并发编程"><a href="#十二、第十三章-并发编程" class="headerlink" title="十二、第十三章 并发编程"></a>十二、第十三章 并发编程</h2><h3 id="1-为什么要并发"><a href="#1-为什么要并发" class="headerlink" title="1. 为什么要并发"></a>1. 为什么要并发</h3><p>并发是一种解耦策略。它帮我们把做什么和何时做分解开。</p><h3 id="2-并发的防御原则"><a href="#2-并发的防御原则" class="headerlink" title="2. 并发的防御原则"></a>2. 并发的防御原则</h3><h3 id="13-1-单一权责原则（SRP）"><a href="#13-1-单一权责原则（SRP）" class="headerlink" title="13.1 单一权责原则（SRP）"></a>13.1 单一权责原则（SRP）</h3><p>并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑，</p><ul><li>并发相关代码由自己的开发，修改和调优生命周期</li><li>开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难</li><li>即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。</li></ul><blockquote><p>建议：分离并发相关代码与其他代码。</p></blockquote><h3 id="13-2-限制数据作用域"><a href="#13-2-限制数据作用域" class="headerlink" title="13.2 限制数据作用域"></a>13.2 限制数据作用域</h3><p>两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用<code>synchronized</code>关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。</p><blockquote><p>建议：谨记数据封装，严格限制对可能被共享的数据的访问。</p></blockquote><h3 id="13-3-使用数据副本"><a href="#13-3-使用数据副本" class="headerlink" title="13.3 使用数据副本"></a>13.3 使用数据副本</h3><p>避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。</p><h3 id="13-4-线程尽可能地独立"><a href="#13-4-线程尽可能地独立" class="headerlink" title="13.4　线程尽可能地独立"></a>13.4　线程尽可能地独立</h3><p>让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。</p><p>建议：尝试将数据分解到可被独立线程操作的独立子集。</p><h3 id="13-5-了解执行模型"><a href="#13-5-了解执行模型" class="headerlink" title="13.5 了解执行模型"></a>13.5 了解执行模型</h3><h4 id="13-5-1-生产者－－－消费者模型"><a href="#13-5-1-生产者－－－消费者模型" class="headerlink" title="13.5.1 生产者－－－消费者模型"></a>13.5.1 生产者－－－消费者模型</h4><p>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p><h4 id="13-5-2-读者－－－作者模型"><a href="#13-5-2-读者－－－作者模型" class="headerlink" title="13.5.2 读者－－－作者模型"></a>13.5.2 读者－－－作者模型</h4><p>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。</p><p>挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。</p><h4 id="13-5-3哲学家问题（故事内容不在这里描述）"><a href="#13-5-3哲学家问题（故事内容不在这里描述）" class="headerlink" title="13.5.3哲学家问题（故事内容不在这里描述）"></a>13.5.3哲学家问题（故事内容不在这里描述）</h4><p>从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。</p><h3 id="13-6-警惕同步方法之间的依赖"><a href="#13-6-警惕同步方法之间的依赖" class="headerlink" title="13.6 警惕同步方法之间的依赖"></a>13.6 警惕同步方法之间的依赖</h3><p>同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。</p><blockquote><p>建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段：</p></blockquote><ul><li>基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。</li><li>基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。</li><li>适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。</li></ul><h3 id="13-7保持同步区域微小"><a href="#13-7保持同步区域微小" class="headerlink" title="13.7保持同步区域微小"></a>13.7保持同步区域微小</h3><p>应该尽可能少地设计临界区，如果有请尽可能减小同步区域。</p><h3 id="13-8-编写线程需要注意的几点："><a href="#13-8-编写线程需要注意的几点：" class="headerlink" title="13.8　编写线程需要注意的几点："></a>13.8　编写线程需要注意的几点：</h3><h4 id="1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"><a href="#1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。" class="headerlink" title="(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"></a>(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。</h4><h4 id="2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"><a href="#2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。" class="headerlink" title="(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"></a>(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。</h4><h4 id="3-编写可插拔的线程代码。编写在数个环境下运行的线程代码"><a href="#3-编写可插拔的线程代码。编写在数个环境下运行的线程代码" class="headerlink" title="(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码"></a>(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码</h4><ul><li>1.单线程与多线程在执行时不同的情况</li><li>2.线程代码与实物或测试替身互动</li><li>3.用运行速度,缓慢和有变动的测试替身执行</li><li>4.将测试配置为能运行一定数量的迭代</li></ul><blockquote><p>建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。</p></blockquote><h4 id="4-编写可调整的线程代码"><a href="#4-编写可调整的线程代码" class="headerlink" title="(4). 编写可调整的线程代码"></a>(4). 编写可调整的线程代码</h4><p>在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。</p><h4 id="5-运行多余处理器数量的线程"><a href="#5-运行多余处理器数量的线程" class="headerlink" title="(5). 运行多余处理器数量的线程"></a>(5). 运行多余处理器数量的线程</h4><p>任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。</p><h4 id="6-在不同平台上运行"><a href="#6-在不同平台上运行" class="headerlink" title="(6). 在不同平台上运行"></a>(6). 在不同平台上运行</h4><h4 id="7-调整代码并强迫错误发生"><a href="#7-调整代码并强迫错误发生" class="headerlink" title="(7). 调整代码并强迫错误发生"></a>(7). 调整代码并强迫错误发生</h4><h2 id="十三、第14章-逐步改进"><a href="#十三、第14章-逐步改进" class="headerlink" title="十三、第14章 逐步改进"></a>十三、第14章 逐步改进</h2><p>代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。</p><h2 id="十四、第17章-味道与启发"><a href="#十四、第17章-味道与启发" class="headerlink" title="十四、第17章 味道与启发"></a>十四、第17章 味道与启发</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><h4 id="1-不恰当的注释信息"><a href="#1-不恰当的注释信息" class="headerlink" title="(1). 不恰当的注释信息"></a>(1). 不恰当的注释信息</h4><p>让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。</p><h4 id="2-废弃的注释"><a href="#2-废弃的注释" class="headerlink" title="(2). 废弃的注释"></a>(2). 废弃的注释</h4><p>过时，无关或不正确的注释就是废弃的注释。</p><h4 id="3-冗余注释"><a href="#3-冗余注释" class="headerlink" title="(3). 冗余注释"></a>(3). 冗余注释</h4><p>如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。</p><h4 id="4-注释要写就要写最好的注释，别画蛇添足"><a href="#4-注释要写就要写最好的注释，别画蛇添足" class="headerlink" title="(4). 注释要写就要写最好的注释，别画蛇添足"></a>(4). 注释要写就要写最好的注释，别画蛇添足</h4><h4 id="5-注释掉的代码，看到注释掉的代码就删。"><a href="#5-注释掉的代码，看到注释掉的代码就删。" class="headerlink" title="(5). 注释掉的代码，看到注释掉的代码就删。"></a>(5). 注释掉的代码，看到注释掉的代码就删。</h4><h3 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h3><h4 id="1-需要多步才能实现的构建"><a href="#1-需要多步才能实现的构建" class="headerlink" title="(1). 需要多步才能实现的构建"></a>(1). 需要多步才能实现的构建</h4><p>构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。</p><h4 id="2-需要多步才能做到测试"><a href="#2-需要多步才能做到测试" class="headerlink" title="(2). 需要多步才能做到测试"></a>(2). 需要多步才能做到测试</h4><p>你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。</p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li>函数的参数应该少。</li><li>输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。</li><li>标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。</li><li>永不被调用的方法应该丢弃。</li></ul><h3 id="4-一般性问题"><a href="#4-一般性问题" class="headerlink" title="4. 一般性问题"></a>4. 一般性问题</h3><p>(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。</p><p>(2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。</p><p>(3). 不正确的边界行为，追索每种边界条件，编写测试。</p><p>(4). 忽视安全</p><p>(5). 重复，尽可能找到并消除重复。</p><p>(6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。</p><p>(7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。</p><p>(8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。</p><p>优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。</p><p>(9). 死代码一定要删除。</p><p>(10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。</p><p>(11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。</p><p>(12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。</p><p>(13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。</p><p>(14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。</p><p>(15). 选择算子参数，尽量不要把boolean作为函数参数</p><p>(16). 晦涩意图，代码要尽可能具有表达力。</p><p>(17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。</p><p>(18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。</p><p>(19). 使用解释性变量，命名要有意义。</p><p>(20). 函数名称应该表达其行为</p><p>(21). 理解算法</p><p>(22). 把逻辑依赖改为物理依赖：</p><ul><li>1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。</li><li>2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。</li></ul><p>(23). 用多态替代<code>if/else</code> 或 <code>switch/case</code></p><p>(24). 遵循标准约定</p><p>(25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。</p><p>(26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。</p><p>(27). 结构甚于约定，坚守结构甚于约定的设计决策。</p><p>(28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。</p><p>例如：</p><pre><code class="java">if(shouldBeDeleted(timer))</code></pre><p>要好于</p><pre><code class="java">if(timer.hasExpired() &amp;&amp; !timer.isRecurrent())</code></pre><p>(29). 避免否定性条件，尽可能将条件表示为肯定形式。</p><p>(30). 函数只该做一件事</p><p>(31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。</p><p>(32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。</p><p>(33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。</p><p>(34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。</p><p>(35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。</p><p>(36). 避免传递浏览，编写害羞代码。</p><p>(37). 不要继承常量</p><h3 id="17-5-测试"><a href="#17-5-测试" class="headerlink" title="17.5 测试"></a>17.5 测试</h3><ol><li>使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。</li><li>别略过小测试</li><li>被忽略的测试就是对不确定事物的疑问。</li><li>测试边界条件</li><li>全面测试相近的缺陷，缺陷趋向于扎堆。</li><li>测试失败的模式有启发性。</li><li>测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。</li><li>测试应该快速。</li></ol><p>来自：<a href="http://www.uml.org.cn/codeNorms/201701162.asp" target="_blank" rel="noopener">代码整洁之道内容概要</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整洁代码 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之观察者模式</title>
      <link href="/2018/10/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-guan-cha-zhe-mo-shi/"/>
      <url>/2018/10/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>观察者模式(<code>Observer Pattern</code>)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（<code>Publish</code>/<code>Subscribe</code>）模式、模型-视图（<code>Model</code>/<code>View</code>）模式、源-监听器（<code>Source</code>/<code>Listener</code>）模式或从属者（<code>Dependents</code>）模式。</p></blockquote><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>观察者模式包含如下角色：</p><ul><li><code>Subject</code>: 目标（抽象的被观察着）</li><li><code>ConcreteSubject</code>: 具体目标（具体的被观察者）</li><li><code>Observer</code>: 观察者</li><li><code>ConcreteObserver</code>: 具体观察者</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/Obeserver.jpg" alt="观察者模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_Obeserver.jpg" alt="观察者模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是观察者接口：</p><pre><code class="java">/** * 观察者接口 * Created by blinkfox on 16/7/14. */public interface Observer {    // 更新的方法    public void update();}</code></pre><p>接下来，是具体的观察者类：</p><pre><code class="java">/** * 具体的观察者. * * Created by blinkfox on 16/7/15. */public class ConcreteObserver implements Observer {    /**     * 实现更新方法.     */    @Override    public void update() {        System.out.println(&quot;接收到信息,并进行处理...&quot;);    }}</code></pre><p>然后，是被观察者的抽象类：</p><pre><code class="java">/** * 被观察者的抽象类. * * Created by blinkfox on 16/7/14. */public abstract class Subject {    /** 定义一个观察者的集合. */    private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();    /**     * 增加一个观察者.     *     * @param o     */    public void addObserver(Observer o) {        this.observers.add(o);    }    /**     * 删除一个观察者.     *     * @param o     */    public void delObserver(Observer o) {        this.observers.remove(o);    }    /**     * 通知所有观察者.     */    public void notifyObservers() {        for (Observer o: observers) {            o.update();        }    }}</code></pre><p>具体的被观察者：</p><pre><code class="java">/** * 具体的被观察者. * * Created by blinkfox on 16/7/15. */public class ConcreteSubject extends Subject {    /**     * 具体的业务.     */    public void doSomething() {        super.notifyObservers();    }}</code></pre><p>最后，是用于测试观察者模式的客户端场景类：</p><pre><code class="java">/** * 观察者模式客户端场景类. * * Created by blinkfox on 16/7/15. */public class ObserverClient {    public static void main(String[] args) {        // 创建一个被观察者和观察者.        ConcreteSubject sub = new ConcreteSubject();        Observer obs = new ConcreteObserver();        // 观察者观察被观察者.        sub.addObserver(obs);        // 观察者开始活动了.        sub.doSomething();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>观察者模式的优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>观察者模式的缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在JDK的<code>java.util</code>包中，提供了<code>Observable</code>类以及<code>Observer</code>接口，它们构成了Java语言对观察者模式的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之其他常用命令</title>
      <link href="/2018/10/13/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/"/>
      <url>/2018/10/13/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1-hostname-查看主机名"><a href="#1-hostname-查看主机名" class="headerlink" title="1. hostname - 查看主机名"></a>1. hostname - 查看主机名</h2><p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p><p><code>hostname</code>的常用命令如下：</p><pre><code class="bash"># 显示系统的当前主机名hostname# 修改你系统的主机名hostname blinkfox-system# 使用 -F 选项，从指定的文件中读取主机名hostname -F /root/hostname.txt</code></pre><h2 id="2-uptime-查看系统运行时间"><a href="#2-uptime-查看系统运行时间" class="headerlink" title="2. uptime - 查看系统运行时间"></a>2. uptime - 查看系统运行时间</h2><p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p><pre><code class="bash">uptime</code></pre><h2 id="3-w、who-列出登录的用户"><a href="#3-w、who-列出登录的用户" class="headerlink" title="3. w、who - 列出登录的用户"></a>3. w、who - 列出登录的用户</h2><p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p><pre><code class="bash">w# 打印如下22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER     TTY      FROM              LOGIN@  IDLE WHATblinkfox console  -                日19   6days -blinkfox s000     -                五23       - w</code></pre><p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p><pre><code class="bash">who [OPTION]... [FILE | ARG1 ARG2]</code></pre><p><code>who</code>常用命令如下：</p><pre><code class="bash"># 显示当前登录的所有用户信息who# 显示系统的启动时间who -b# 显示系统登录进程who -l# 显示与当前标准输入关联的用户信息who -m# 显示系统的运行级别who -r# 显示所有登录用户的用户名和登录用户数who -q</code></pre><h2 id="4-uname-查看系统信息"><a href="#4-uname-查看系统信息" class="headerlink" title="4. uname - 查看系统信息"></a>4. uname - 查看系统信息</h2><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre><code class="bash">uname [OPTION]...</code></pre><p>常用使用方式如下：</p><pre><code class="bash"># 只打印内核的名称uname# 使用 -n 选项，只打印系统的主机名uname -n# 使用 -r 选项，打印内核版本信息uname -r# 使用 -m 选项，打印系统的硬件名称uname -m# 使用 -p 选项，打印系统的处理器类型信息uname -p# 使用 -i 选项，打印系统的硬件平台信息uname -i# 使用 -a 选项，打印上述所有示例中的信息uname -a</code></pre><h2 id="5-date-显示和设置系统日期和时间"><a href="#5-date-显示和设置系统日期和时间" class="headerlink" title="5. date - 显示和设置系统日期和时间"></a>5. date - 显示和设置系统日期和时间</h2><p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p><pre><code class="bash">date [OPTION]... [+FORMAT]date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</code></pre><p>常用使用命令如下：</p><pre><code class="bash"># 以默认格式显示系统的当前日期时间date# 格式化当前日期date +&quot;%Y-%m-%d&quot;# 格式化输出昨天的日期date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d&quot;# 2秒后格式化输出date -d &quot;2 second&quot; +&quot;%Y-%m-%d %H:%M.%S&quot;# 普通格式化转出date -d &quot;2009-12-12&quot; +&quot;%Y/%m/%d %H:%M.%S&quot;# apache格式转换date -d &quot;Dec 5, 2009 12:00:37 AM&quot; +&quot;%Y-%m-%d %H:%M.%S&quot;# 日期加减操作date +%Y%m%d #显示前天年月日date -d &quot;+1 day&quot; +%Y%m%d #显示前一天的日期date -d &quot;-1 day&quot; +%Y%m%d #显示后一天的日期date -d &quot;-1 month&quot; +%Y%m%d #显示上一月的日期date -d &quot;+1 month&quot; +%Y%m%d #显示下一月的日期date -d &quot;-1 year&quot; +%Y%m%d #显示前一年的日期date -d &quot;+1 year&quot; +%Y%m%d #显示下一年的日期# 设定时间date -s # 设置当前时间，只有root权限才能设置，其他只能查看date -s 20160816 # 设置成20160816，这样会把具体时间设置成空00:00:00date -s 01:01:01 # 设置具体时间，不会对日期做更改date -s &quot;01:01:01 2012-05-23&quot; # 这样可以设置全部时间 date -s &quot;01:01:01 20120523&quot; # 这样可以设置全部时间date -s &quot;2012-05-23 01:01:01&quot; # 这样可以设置全部时间 date -s &quot;20120523 01:01:01&quot; # 这样可以设置全部时间</code></pre><h2 id="6-id-显示用户属性"><a href="#6-id-显示用户属性" class="headerlink" title="6. id - 显示用户属性"></a>6. id - 显示用户属性</h2><p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p><pre><code class="bash">id [OPTION]... [USERNAME]</code></pre><p>常见使用命令如下：</p><pre><code class="bash"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息id# 使用 -u 选项，输出用户的 uidid -u#-u 选项和 -n 选项结合使用，输出账户的用户名id -un# 使用 -g 选项，输出帐号当前起作用的gidid -g# -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名id -gn# 使用 -G 选项，输出帐号所属的所有群组idid -G root# -G 与 -n 选项结合使用，输出账号所属的所有群组的名称id -Gn root</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之文本处理</title>
      <link href="/2018/10/11/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/"/>
      <url>/2018/10/11/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-sort-文本排序"><a href="#1-sort-文本排序" class="headerlink" title="1. sort - 文本排序"></a>1. sort - 文本排序</h2><p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p><p>sort 的常用命令如下：</p><pre><code class="bash"># 将文本内容按字母顺序排序sort example.txt# 使用 -u 选项，移除所有重复行后排序sort -u example.txt# 使用 -n 选项，将令数字按数值的大小排序sort -n example.txt# 使用 -r 选项，以倒序方式排序sort -n -r example.txt# 同时将 file1、file2 的内容排序sort file1 file2</code></pre><h2 id="2-uniq-文本去重"><a href="#2-uniq-文本去重" class="headerlink" title="2.uniq - 文本去重"></a>2.uniq - 文本去重</h2><p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p><pre><code class="bash"># 它将移除文件中重复的行并显示单一行uniq example.txt# 可以统计重复行出现的次数uniq -c example.txt# 使用 -d 选项，只显示文件中有重复的行并只显示一次uniq -d example.txt# 使用 -D 选项，显示文件中所有重复的行uniq -D example.txt# 使用 -u 选项，只显示文件中不重复的行uniq -u example.txt# 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复uniq -w 3 example.txt# 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复uniq -s 3 example.txt# 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复uniq -f 1 example.txt</code></pre><h2 id="3-tr-替换或删除字符"><a href="#3-tr-替换或删除字符" class="headerlink" title="3.tr - 替换或删除字符"></a>3.tr - 替换或删除字符</h2><p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p><p><code>tr</code>命令的语法如下所示：</p><pre><code class="bash">tr [OPTION]... SET1 [SET2]</code></pre><p>常用命令示例：</p><pre><code class="bash"># 若要将大括号转换为小括号tr &#39;{}&#39; &#39;()&#39; &lt; textfile &gt; newfile# 若要将大括号转换成方括号tr &#39;{}&#39; &#39;\[]&#39; &lt; textfile &gt; newfile# 若要将小写字符转换成大写，请输入：tr &#39;a-z&#39; &#39;A-Z&#39; &lt; textfile &gt; newfile# 若要创建一个文件中的单词列表tr -cs &#39;[:lower:][:upper:]&#39; &#39;[\n*]&#39; &lt; textfile &gt; newfile# 若要从某个文件中删除所有空字符tr -d &#39;\0&#39; &lt; textfile &gt; newfile# 若要用单独的换行替换每一序列的一个或多个换行，请输入：tr -s &#39;\n&#39; &lt; textfile &gt; newfile# 要以单个“#”字符替换 &lt;space&gt; 字符类中的每个字符序列tr -s &#39;[:space:]&#39; &#39;[#*]&#39;</code></pre><h2 id="4-grep-查找字符串"><a href="#4-grep-查找字符串" class="headerlink" title="4.grep - 查找字符串"></a>4.grep - 查找字符串</h2><p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p><p><code>grep</code>命令的语法如下所示：</p><pre><code class="bash">grep [OPTION]... PATTERN [FILE]...grep [OPTION]... [-e PATTERN | -f FILE] [FILE]...</code></pre><pre><code class="bash"># `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息grep blinkfox /etc/passwd# 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写grep -i blinkfox /etc/passwd# 使用 -r 选项，可以递归搜索指定目录下的所有文件grep -r blinkfox /etc/# 使用 -w 选项，只匹配包含指定单词的行grep -w blinkfox /etc/# 使用 -c 选项，报告文件或文本中模式被匹配的次数grep -c blinkfox /etc/passwd# 使用 -n 选项，显示每一个匹配的行的行号grep -n blinkfox /etc/passwd# 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行grep -v blinkfox /etc/passwd# 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出grep --color blinkfox /etc/passwd</code></pre><h2 id="5-diff-比较两个文件"><a href="#5-diff-比较两个文件" class="headerlink" title="5.diff - 比较两个文件"></a>5.diff - 比较两个文件</h2><p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p><pre><code class="bash">diff [OPTION]... from-file to-file</code></pre><p>常用使用方式如下：</p><pre><code class="bash"># 比较两个文件diff nsswitch.conf nsswitch.conf.org# 使用 -w 选项，比较时忽略空格diff -w nsswitch.conf nsswitch.conf.org# 使用 -y 选项，以并排的格式输出两个文件的比较结果diff -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果diff -c nsswitch.conf nsswitch.conf.org</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之操作文件和目录</title>
      <link href="/2018/10/10/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-cao-zuo-wen-jian-he-mu-lu/"/>
      <url>/2018/10/10/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-cao-zuo-wen-jian-he-mu-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-touch-创建文件"><a href="#1-touch-创建文件" class="headerlink" title="1. touch - 创建文件"></a>1. touch - 创建文件</h2><p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p><pre><code class="bash">-a: 只改变访问时间 -c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 [[CC]YY]MMDDhhmm[.ss] 替代当前时间</code></pre><p>touch 命令的常见用法如下：</p><pre><code class="bash"># 创建一个名为 effyl 的新空文件touch effyl# 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件touch effyl myeffyl lueffyl# 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个touch -a effyl# 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳touch -c effyl# 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变touch -m effyl# 使用 -c 和 -t 选项，来明确设置文件的时间touch -c -t YYMMDDHHMM filename# 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项touch -r myeffyl effyl</code></pre><h2 id="2-mkdir-创建目录"><a href="#2-mkdir-创建目录" class="headerlink" title="2.mkdir - 创建目录"></a>2.mkdir - 创建目录</h2><p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p><pre><code class="bash"># 在当前目录下创建一个给定的目录名mkdir &lt;dirname&gt;# 在 backup 中的相对路径创建一个名为 old 的目录mkdir backup/old# 在 backup 中的绝对路径中创建一个名为 old 的目录mkdir /home/blinkfox/backup/old# 使用 -p 选项，会自动创建所有还不存在的父目录mkdir -p backup/old# 使用 -m 选项，可以设置将要创建目录的权限# 如：创建一个任何人都有读写访问权限的目录mkdir -p -m 777 backup/old</code></pre><h2 id="3-cp-复制文件或目录"><a href="#3-cp-复制文件或目录" class="headerlink" title="3.cp - 复制文件或目录"></a>3.cp - 复制文件或目录</h2><p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p><p>使用 cp 命令复制文件和目录的语法有以下几种：</p><pre><code class="bash"># 复制源文件到目标文件cp [OPTION] SOURCE DEST# 复制一个或多个源文件到一个目录cp [OPTION] SOURCE... DIRECTORY# 同上cp [OPTION] -t DIRECTORY SOURCE... </code></pre><p>常用使用示例如下：</p><pre><code class="bash"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txtcp file.txt newfile.txt# 复制当前目录下的 file.txt 文件到 /tmp 目录下cp file.txt /tmp# 复制当前目录下的所有文件到 /tmp 目录下cp * /tmp# 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息cp -p filename /path/to/new/location/myfile# 使用 -R 或 -r 选项，恶意递归地复制一个目录# 即将一个目录及其下的所有文件和子目录都复制到另一个目录cp -R * /home/blinkfox/backup</code></pre><h2 id="4-ln-链接文件或目录"><a href="#4-ln-链接文件或目录" class="headerlink" title="4.ln - 链接文件或目录"></a>4.ln - 链接文件或目录</h2><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre><code class="bash"># 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.soln -s /home/blinkfox/src/library.so /home/blinkfox/lib# 创建目录的软链接ln -s /home/blinkfox/src source</code></pre><h2 id="5-mv-移动文件或目录"><a href="#5-mv-移动文件或目录" class="headerlink" title="5. mv - 移动文件或目录"></a>5. mv - 移动文件或目录</h2><p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p><p>mv 命令的基本语法如下所示：</p><pre><code class="bash">mv SOURCE... DIRECTORY</code></pre><p>常用命令如下：</p><pre><code class="bash"># 将当前目录下的文件 source.txt 移到目录 /tmp 下mv source.txt /tmp# 将目录 dir1、dir2 移到目录 dir_dist 下mv dir1 dir2 dir_dist# 将当前目录下的 old.txt 文件更名为 new.txtmv old.txt new.txt# 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息mv -i old.txt new.txt# 将当前目录下的所有文件移动到目录 /tmp 下mv * /tmp/# 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录mv -u dir1/* dir2/</code></pre><h2 id="6-rm-删除文件或目录"><a href="#6-rm-删除文件或目录" class="headerlink" title="6.rm - 删除文件或目录"></a>6.rm - 删除文件或目录</h2><p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p><pre><code class="bash">rm [OPTIONS]... FILE...</code></pre><p><code>rm</code>的常用命令如下：</p><pre><code class="bash"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txtrm file1.txt file2.txt file3.txt# 删除当前目录下的所有文件rm *# 删除你当前帐号主目录下的 temp 目录中的所有文件rm ~/temp/*# 使用 -i 选项，可以在删除每个文件或目录前提示用户确认rm -i *# 删除当前目录下所有以&quot;.doc&quot;结尾的文件rm *.doc# 删除当前目录下所有文件名中包含&quot;movie&quot;字符串的文件rm *movie*# 删除当前目录下所有以&quot;a&quot;开头的文件rm a*# 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件rm ???# 删除当前目录下文件扩展名有两个字符的所有文件rm *.??# 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件rm *[abc]*# 删除当前目录下文件名中包含 0~9 的所有文件rm *[0-9]*# 删除当前目录下文件扩展名是字母 c 或 h 的所有文件rm *.[ch]# 删除 /tmp 目录下的所有文件及其子目录rm -rf /tmp/*</code></pre><blockquote><p>-f 删除前不提示用户确认，并忽略不存在的文件</p></blockquote><blockquote><p>-r 递归地删除目录及其下的内容</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Bash命令整理之查看文件和目录</title>
      <link href="/2018/10/09/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/"/>
      <url>/2018/10/09/ruan-jian-gong-ju/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ls-列出文件名和目录"><a href="#1-ls-列出文件名和目录" class="headerlink" title="1. ls - 列出文件名和目录"></a>1. ls - 列出文件名和目录</h2><p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p><p>以下便是<code>ls</code>命令及其选项的作用说明：</p><pre><code class="bash"># 仅列出当前目录下所有文件和目录ls# 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等ls -l# 将文件大小显示符合人类阅读习惯的格式ls -lh# 将使用不同的特殊字符归类不同的文件类型ls -F# 以长列表格式列出某个目录的信息ls -ld /var/log# 将递归地列出子目录的内容ls -R /etc/sysconfig/# 以长列表格式按文件或目录的修改时间倒序地列出文件和目录ls -ltr# 以长列表格式按文件大小顺序列出文件和目录ls -ls# 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）ls -a# 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）ls -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组ls -n</code></pre><h2 id="2-cat-连接显示文件内容"><a href="#2-cat-连接显示文件内容" class="headerlink" title="2. cat - 连接显示文件内容"></a>2. cat - 连接显示文件内容</h2><p><code>cat</code> 命令也是Linux系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><p><code>cat</code>命令的语法如下所示：</p><pre><code class="bash">cat [OPTION] [FILE]...</code></pre><p><code>cat</code>常用命令如下：</p><pre><code class="bash"># 使用 cat 命令查看文件 /etc/group 的内容cat /etc/group# 显示多个文件的内容cat /etc/redhat-release /etc/issue# -n 选项，可以显示文件内容的行号cat -n /etc/fstab# -b 选项和 -n 选项类似，但只标识非空白行的行号cat -b /etc/fstab# -e 选项，将在每一行的结尾显示“$”字符cat -e /etc/fstab</code></pre><blockquote><p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p></blockquote><h2 id="3-less、more-分屏显示文件"><a href="#3-less、more-分屏显示文件" class="headerlink" title="3.less、more - 分屏显示文件"></a>3.less、more - 分屏显示文件</h2><p><code>more</code>命令在你使用小的xterm窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more命令是一个用于一次翻阅一整屏文件的过滤器。</p><pre><code class="bash"># 查看一个文件，自动清空屏幕并显示文件开头部分more /etc/inittab# 指定一次显示num行more -num /etc/inittab</code></pre><p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p><p><code>less</code>常用命令参数如下：</p><pre><code class="bash">-b  &lt;缓冲区大小&gt; 设置缓冲区的大小-e  当文件显示结束后，自动离开-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g  只标志最后搜索的关键词-i  忽略搜索时的大小写-m  显示类似more命令的百分比-N  显示每行的行号-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q  不使用警告音-s  显示连续空行为一行-S  行过长时间将超出部分舍弃-x  &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]：   向上翻动一页</code></pre><h2 id="4-head-显示文件头部"><a href="#4-head-显示文件头部" class="headerlink" title="4.head - 显示文件头部"></a>4.head - 显示文件头部</h2><p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的前N行：</p><pre><code class="bash"># 指定打印文件的前5行head -n 5 /etc/inittab（或）head -5 /etc/inittab# 打印文件的前N个字节的数据head -c 10 /etc/inittab</code></pre><h2 id="5-tail-显示文件尾部"><a href="#5-tail-显示文件尾部" class="headerlink" title="5.tail - 显示文件尾部"></a>5.tail - 显示文件尾部</h2><p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的最后N行：</p><pre><code class="bash"># 指定打印文件的后10行tail -n 10 /etc/inittabtail -10 /etc/inittab# 即时打印文件中新写入的行tail -f /var/log/messages# --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件tail -f /tmp/debug.log --retry</code></pre><h2 id="6-file-查看文件类型"><a href="#6-file-查看文件类型" class="headerlink" title="6.file - 查看文件类型"></a>6.file - 查看文件类型</h2><p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p><pre><code class="bash"># 查看文件类型file /etc/inittab# 可以MIME类型的格式显示文件类型的信息file -i  /etc/inittab# 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示file -N *</code></pre><h2 id="7-wc-查看文件统计信息"><a href="#7-wc-查看文件统计信息" class="headerlink" title="7.wc - 查看文件统计信息"></a>7.wc - 查看文件统计信息</h2><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p><pre><code class="bash">wc filenameX Y Z /etc/inittab</code></pre><p>其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。</p><pre><code class="bash"># -l选项，可以只统计文件的行数信息wc -l /etc/inittab# -w选项，可以只统计文件的单词数信息wc -w /etc/inittab# -c选项，可以只统计文件的字节数信息wc -c /etc/inittab# -L选项，可以只统计文件中最长的行的长度wc -L /etc/inittab</code></pre><h2 id="8-find-查找文件或目录"><a href="#8-find-查找文件或目录" class="headerlink" title="8.find - 查找文件或目录"></a>8.find - 查找文件或目录</h2><p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p><p><code>find</code>命令常用使用和说明如下：</p><pre><code class="bash"># 查找指定目录下的某个文件find /etc/ -name inittab# 在当前目录下查找名称为 inittab 的文件find . -name inittab# 在当前目录下，文件不区分大小写是example的所有文件find . -iname example# 找出当前目录下所有以 sh 结尾的文件find . -type f -name &quot;*.sh&quot;# 找出当前目录下，文件权限是 777 的所有文件find . -type f -perm 777# 找出当前目录下，文件权限不是 777 的所有文件find . -type f ! -perm 777# 找出当前目录下所有只读文件find . -type f ! -perm /a+w# 找出你帐号主目录下的所有可执行文件find ~ -type f -perm /a+w# 找出 /tmp 目录下的.log文件并将其删除：find /tmp/ -type f -name &quot;*.log&quot; -exec rm -f {} \;# 找出当前目录下的所有空文件find . -type f -empty# 找出当前目录下的所有空目录find . -type d -empty# 找出 /tmp 目录下的所有隐藏文件find /tmp/ -type f -name &quot;.*&quot;# 找出 /tmp 目录下，所有者是 root 的文件和目录find /tmp/ -user root# 找出 /tmp 目录下，用户组是 developer 的文件和目录find /tmp/ -group root# 找出你账号的主目录下，3 天前修改的文件find ~ -type f -mtime 3# 找出你账号的主目录下，30 天以前修改的所有文件find ~ -type f -mtime +30# 找出你账号的主目录下，3 天以内修改的所有文件find ~ -type f -mtime -3# 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件find ~ -type f -mtime +30 -mtime -60# 找出 /etc 目录下，一小时以内变更过的文件find /etc -type f -cmin -60# 找出 /etc 目录下，一小时以内访问过的文件find /etc -type f -amin -60# 找出你账号主目录下，大小是50MB的所有文件find ~ -type f -size 50MB# 找出你账号主目录下，大于50MB小于100MB的所有文件find ~ -type f -size +50MB -size -100MB# 找出你账号主目录下，大于100MB的文件并将其删除find ~ -type f -size +100MB -exec rm -rf {} \;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>轻量级滚动动画JavaScript库aos.js</title>
      <link href="/2018/10/08/qian-duan/qing-liang-ji-gun-dong-dong-hua-javascript-ku-aos.js/"/>
      <url>/2018/10/08/qian-duan/qing-liang-ji-gun-dong-dong-hua-javascript-ku-aos.js/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="http://michalsnik.github.io/aos/" target="_blank" rel="noopener">aos.js</a>是一款效果超赞的页面滚动的 JavaScript 动画库插件。该动画库可以在页面滚动时提供28种不同的元素动画效果，以及多种<code>easing</code>效果。在页面往回滚动时，元素会恢复到原来的状态。</p><p><img src="http://static.blinkfox.com/aos1.png" alt="AOS"></p><blockquote><p>注：从<code>2.0.0</code>版本之后,只支持使用<code>data-aos</code>属性，不再支持使用<code>aos</code>属性。</p></blockquote><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1-Bower-安装"><a href="#1-Bower-安装" class="headerlink" title="1. Bower 安装"></a>1. Bower 安装</h3><p>你可以使用 <a href="https://bower.io/" target="_blank" rel="noopener">Bower</a> 包管理工具安装<code>aos</code>：</p><pre><code class="bash">bower install aos --save</code></pre><h3 id="2-npm"><a href="#2-npm" class="headerlink" title="2. npm"></a>2. npm</h3><p>你也能在 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 上找到 <code>aos</code>：</p><pre><code class="bash">npm install aos --save</code></pre><h3 id="3-Github-下载"><a href="#3-Github-下载" class="headerlink" title="3. Github 下载"></a>3. Github 下载</h3><p>Github 下载点击<a href="https://github.com/michalsnik/aos/archive/master.zip" target="_blank" rel="noopener">此处</a></p><h2 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h3><p>引入<code>CSS</code>样式文件：</p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;bower_components/aos/dist/aos.css&quot; /&gt;</code></pre><p>添加<code>JavaScript</code>脚本文件：</p><pre><code class="html">&lt;script src=&quot;bower_components/aos/dist/aos.js&quot;&gt;&lt;/script&gt;</code></pre><p>初始化载入<code>AOS</code>：</p><pre><code class="html">&lt;script&gt;    AOS.init();&lt;/script&gt;</code></pre><h3 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2. 简单示例"></a>2. 简单示例</h3><pre><code class="css">body {    font-family: Helvetica,Tahoma;}*,*:before,*:after {    box-sizing: border-box;}.aos-all {    width: 1000px;    max-width: 98%;    margin: 10vh auto 0 auto;}.aos-item {    display: inline-block;    float: left;    width: 33.3333%;    height: 300px;    padding: 20px;}.aos-item__inner {    position: relative;    width: 100%;    height: 100%;    background: #1da4e2;    line-height: 260px;    text-align: center;    color: #fff;}@media screen and (max-width: 800px) {    .aos-item {        width: 50%;    }}</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;AOS的简单示例&lt;/title&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;aos/aos.css&quot; /&gt;    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;aos_test.css&quot; /&gt;&lt;/head&gt;&lt;body onload=&quot;initLoad();&quot;&gt;    &lt;div id=&quot;transcroller&quot; class=&quot;aos-all&quot;&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;1&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;2&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;zoom-out-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;3&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;flip-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;4&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;flip-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;5&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;6&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;7&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;8&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;9&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;10&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;11&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;12&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;13&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;14&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;15&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;16&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;17&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;18&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;zoom-out&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;19&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;20&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;zoom-out&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;21&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;22&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;zoom-out-up&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;23&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;zoom-out-down&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;24&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;25&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;26&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;27&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;28&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;29&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;30&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;31&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;32&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;33&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;34&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;35&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;36&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;37&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;38&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;39&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;40&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;41&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;aos-item&quot; data-aos=&quot;fade-in&quot;&gt;            &lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;42&lt;/h3&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;aos/aos.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function initLoad() {        AOS.init();    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="3-异步示例"><a href="#3-异步示例" class="headerlink" title="3. 异步示例"></a>3. 异步示例</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;AOS 异步使用的示例&lt;/title&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;aos.css&quot; /&gt;    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;aos_test.css&quot; /&gt;&lt;/head&gt;&lt;body onload=&quot;initLoad();&quot;&gt;    &lt;div id=&quot;aos_async&quot; class=&quot;aos-all&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;aos.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function initLoad() {        AOS.init();    }    // 0.5秒执行一次    setInterval(addItem, 500);    var itemsCounter = 1;    var container = document.getElementById(&#39;aos_async&#39;);    /**     * 动态生成的div元素     */    function addItem () {        if (itemsCounter &gt; 42) return;        var item = document.createElement(&#39;div&#39;);        item.classList.add(&#39;aos-item&#39;);        item.setAttribute(&#39;data-aos&#39;, &#39;fade-up&#39;);        item.innerHTML = &#39;&lt;div class=&quot;aos-item__inner&quot;&gt;&lt;h3&gt;&#39; + itemsCounter + &#39;&lt;/h3&gt;&lt;/div&gt;&#39;;        container.appendChild(item);        itemsCounter++;    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="四、动画样式"><a href="#四、动画样式" class="headerlink" title="四、动画样式"></a>四、动画样式</h2><p>以下是<code>AOS</code>已经提供了的多种动画：</p><h3 id="1-Fade-animations"><a href="#1-Fade-animations" class="headerlink" title="1. Fade animations"></a>1. Fade animations</h3><ul><li>fade-up</li><li>fade-down</li><li>fade-left</li><li>fade-right</li><li>fade-up-right</li><li>fade-up-left</li><li>fade-down-right</li><li>fade-down-left</li></ul><h3 id="2-Flip-animations"><a href="#2-Flip-animations" class="headerlink" title="2. Flip animations"></a>2. Flip animations</h3><ul><li>flip-up</li><li>flip-down</li><li>flip-left</li><li>flip-right</li></ul><h3 id="3-Slide-animations"><a href="#3-Slide-animations" class="headerlink" title="3. Slide animations"></a>3. Slide animations</h3><ul><li>slide-up</li><li>slide-down</li><li>slide-left</li><li>slide-right</li></ul><h3 id="4-Zoom-animations"><a href="#4-Zoom-animations" class="headerlink" title="4. Zoom animations"></a>4. Zoom animations</h3><ul><li>zoom-in</li><li>zoom-in-up</li><li>zoom-in-down</li><li>zoom-in-left</li><li>zoom-in-right</li><li>zoom-out</li><li>zoom-out-up</li><li>zoom-out-down</li><li>zoom-out-left</li><li>zoom-out-right</li></ul><h3 id="5-Anchor-placement"><a href="#5-Anchor-placement" class="headerlink" title="5. Anchor placement"></a>5. Anchor placement</h3><ul><li>top-bottom</li><li>top-center</li><li>top-top</li><li>center-bottom</li><li>center-center</li><li>center-top</li><li>bottom-bottom</li><li>bottom-center</li><li>bottom-top</li></ul><h2 id="五、Easing-函数"><a href="#五、Easing-函数" class="headerlink" title="五、Easing 函数"></a>五、Easing 函数</h2><p>你可以选择以下任意一个时间函数来做出很好的做动画元素：</p><ul><li>linear</li><li>ease</li><li>ease-in</li><li>ease-out</li><li>ease-in-out</li><li>ease-in-back</li><li>ease-out-back</li><li>ease-in-out-back</li><li>ease-in-sine</li><li>ease-out-sine</li><li>ease-in-out-sine</li><li>ease-in-quad</li><li>ease-out-quad</li><li>ease-in-out-quad</li><li>ease-in-cubic</li><li>ease-out-cubic</li><li>ease-in-out-cubic</li><li>ease-in-quart</li><li>ease-out-quart</li><li>ease-in-out-quart</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全功能JavaScript灯箱画廊插件lightgallery.js</title>
      <link href="/2018/10/06/qian-duan/quan-gong-neng-javascript-deng-xiang-hua-lang-cha-jian-lightgallery.js/"/>
      <url>/2018/10/06/qian-duan/quan-gong-neng-javascript-deng-xiang-hua-lang-cha-jian-lightgallery.js/</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote><p><a href="https://sachinchoolur.github.io/lightgallery.js/" target="_blank" rel="noopener">lightgallery.js</a> 是一个全功能、轻量级、无依赖的灯箱画廊显示库。</p></blockquote><p><img src="http://static.blinkfox.com/lg.png" alt="lightgallery"></p><h3 id="二、主要特性"><a href="#二、主要特性" class="headerlink" title="二、主要特性"></a>二、主要特性</h3><ul><li>全响应式兼容</li><li>模块化的架构和内置插件</li><li>移动设备和触摸支持</li><li>桌面设备拖拽支持</li><li>双击查看图像的实际大小</li><li>动画缩略图</li><li>社交媒体分享</li><li>YouTube，Vimeo，DailyMotion，VK和 HTML5 视频支持</li><li>20+ 硬件加速CSS3过渡</li><li>全屏支持</li><li>支持缩放</li><li>浏览器历史记录</li><li>响应式图像</li><li>HTML iframe 支持</li><li>支持iFrame框架</li><li>单页多实例</li><li>可能过CSS(SCSS)定制样式</li><li>智能图像预加载与代码优化</li><li>桌面键盘导航</li><li>字体图标支持</li><li>还有更多</li></ul><h3 id="三、浏览器支持"><a href="#三、浏览器支持" class="headerlink" title="三、浏览器支持"></a>三、浏览器支持</h3><p>lightgallery 支持所有主要的浏览器包括IE 9及以上。</p><h3 id="四、安装下载"><a href="#四、安装下载" class="headerlink" title="四、安装下载"></a>四、安装下载</h3><h4 id="1-Bower-安装"><a href="#1-Bower-安装" class="headerlink" title="1. Bower 安装"></a>1. Bower 安装</h4><p>你可以使用 <a href="https://bower.io/" target="_blank" rel="noopener">Bower</a> 包管理工具安装<code>lightgallery</code>：</p><pre><code class="bash">bower install lightgallery.js --save</code></pre><h4 id="2-npm"><a href="#2-npm" class="headerlink" title="2. npm"></a>2. npm</h4><p>你也能在 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 上找到 <code>lightgallery</code>：</p><pre><code class="bash">npm install lightgallery.js</code></pre><h4 id="3-Github-下载"><a href="#3-Github-下载" class="headerlink" title="3. Github 下载"></a>3. Github 下载</h4><p>你也可以直接从 GitHub 下载<a href="https://github.com/sachinchoolur/lightgallery.js" target="_blank" rel="noopener">lightgallery</a></p><h3 id="五、基础示例"><a href="#五、基础示例" class="headerlink" title="五、基础示例"></a>五、基础示例</h3><h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h4><p>首先，在 html 头文件<code>&lt;head&gt;</code>中引入<code>lightgallery.css</code>：</p><pre><code class="html">&lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/lightgallery.css&quot;&gt;&lt;/head&gt;</code></pre><p>然后，在<code>&lt;body&gt;</code>标签结尾引入<code>lightgallery.min.js</code>，如果你想引入其他 lightgallery 的功能插件，你可以将这些插件引入到<code>lightgallery.min.js</code>之后，如下：</p><pre><code class="html">&lt;body&gt;    ...    &lt;script src=&quot;js/lightgallery.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- lightgallery plugins --&gt;    &lt;script src=&quot;js/lg-thumbnail.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;js/lg-fullscreen.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>以下是页面标记的图片示例：</p><pre><code class="html">&lt;div id=&quot;lightgallery&quot;&gt;    &lt;a href=&quot;img/img1.jpg&quot;&gt;        &lt;img src=&quot;img/thumb1.jpg&quot;&gt;    &lt;/a&gt;    &lt;a href=&quot;img/img2.jpg&quot;&gt;        &lt;img src=&quot;img/thumb2.jpg&quot;&gt;    &lt;/a&gt;    ...&lt;/div&gt;</code></pre><p>最后，是 JavaScript 调用插件的方式：</p><pre><code class="javascript">&lt;script&gt;    lightGallery(document.getElementById(&#39;lightgallery&#39;));&lt;/script&gt;</code></pre><h4 id="2-完整示例"><a href="#2-完整示例" class="headerlink" title="2. 完整示例"></a>2. 完整示例</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;lightgallery.js的使用示例&lt;/title&gt;    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/lightGallery/css/lightgallery.min.css&quot; /&gt;    &lt;style type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;        ul {            float: left;            list-style-type: none;        }        ul li {            float: left;            display: inline-block;            margin: 5px;        }        .lgallery {            width: 213px;            height: 137px;            cursor: pointer;        }    &lt;/style&gt;&lt;/head&gt;&lt;body onload=&quot;initLoad();&quot;&gt;    &lt;ul id=&quot;lightGallery&quot;&gt;        &lt;li data-src=&quot;/assets/images/a.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/a.jpg&quot;&gt;        &lt;/li&gt;        &lt;li data-src=&quot;/assets/images/b.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/b.jpg&quot;&gt;        &lt;/li&gt;        &lt;li data-src=&quot;/assets/images/c.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/c.jpg&quot;&gt;        &lt;/li&gt;        &lt;li data-src=&quot;/assets/images/d.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/d.jpg&quot;&gt;        &lt;/li&gt;        &lt;li data-src=&quot;/assets/images/e.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/e.jpg&quot;&gt;        &lt;/li&gt;        &lt;li data-src=&quot;/assets/images/f.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/f.jpg&quot;&gt;        &lt;/li&gt;        &lt;li data-src=&quot;/assets/images/g.jpg&quot;&gt;            &lt;img class=&quot;lgallery&quot; src=&quot;/assets/images/g.jpg&quot;&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/lightgallery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-fullscreen.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-thumbnail.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-autoplay.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-hash.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-pager.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-share.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/lightGallery/js/plugins/lg-zoom.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;function initLoad() {    var lg = document.getElementById(&#39;lightGallery&#39;);    lightGallery(lg, {        mode: &#39;lg-slide&#39;,        cssEasing: &#39;ease&#39;,        speed: 500    });}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="六、学习和参考资源"><a href="#六、学习和参考资源" class="headerlink" title="六、学习和参考资源"></a>六、学习和参考资源</h3><ul><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html" target="_blank" rel="noopener">API Reference</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#events" target="_blank" rel="noopener">Events</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#methods" target="_blank" rel="noopener">Methods</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#attributes" target="_blank" rel="noopener">Data Attributes</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#dynamic" target="_blank" rel="noopener">Dynamic variables</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/api.html#sass" target="_blank" rel="noopener">Sass variables</a></li><li><a href="https://sachinchoolur.github.io/lightgallery.js/docs/plugin-api.html" target="_blank" rel="noopener">Module API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Java编程风格指南</title>
      <link href="/2018/10/05/bian-cheng-zhi-dao/google-java-bian-cheng-feng-ge-zhi-nan/"/>
      <url>/2018/10/05/bian-cheng-zhi-dao/google-java-bian-cheng-feng-ge-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是<code>Google Java</code>编程风格规范的完整定义。当且仅当一个<code>Java</code>源文件符合此文档中的规则，我们才认为它符合<code>Google</code>的<code>Java</code>编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语<code>class</code>可表示一个普通类、枚举类、接口或者注解。</li><li>术语<code>comment</code>只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用<code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用<code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code>水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code>字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>任何需要转义字符串表示的字符（例如：<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\\</code>等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 <code>\012</code>）或<code>Unicode</code>码（例如：<code>\u000a</code>）表示。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于其余非<code>ASCII</code>字符，直接使用<code>Unicode</code>字符（例如 <code>∞</code>），或者使用对应的<code>Unicode</code>码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用<code>Unicode</code>字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非<code>ASCII</code>字符而让你的代码可读性变差。当程序无法正确处理非<code>ASCII</code>字符时，它自然无法正确运行，你就会去<code>fix</code>这些问题的了。(言下之意就是大胆去用非<code>ASCII</code>字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code>语句</li><li><code>import</code>语句</li><li><code>class</code>类声明（每个源码文件只能有唯一一个顶级<code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间应该只有<strong>一个空行</strong>作为间隔。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不使用通配符"><a href="#3-3-1-import不使用通配符" class="headerlink" title="3.3.1 import不使用通配符"></a>3.3.1 import不使用通配符</h4><p><code>import</code>语句中不应该使用通配符，不管是否是静态导入。</p><h4 id="3-3-2-import不换行"><a href="#3-3-2-import不换行" class="headerlink" title="3.3.2 import不换行"></a>3.3.2 import不换行</h4><p><code>import</code>语句不换行，列限制(4.4节)并不适用于<code>import</code>语句。(每个<code>import</code>语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code>语句可分为以下几组，按照顺序，每组由<strong>一个空行</strong>分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code>包的<code>import</code>归为一组</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li><li><code>java</code>包归为一组</li><li><code>javax</code>包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的<code>import</code>语句之间不应用空行隔开，同一组中的<code>import</code>语句按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级class"><a href="#3-4-1-只声明唯一一个顶级class" class="headerlink" title="3.4.1 只声明唯一一个顶级class"></a>3.4.1 只声明唯一一个顶级class</h4><p>每个源文件中只能有一个顶级class。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用K-amp-R风格"><a href="#4-1-2-非空语句块采用K-amp-R风格" class="headerlink" title="4.1.2 非空语句块采用K&amp;R风格"></a>4.1.2 非空语句块采用<code>K&amp;R</code>风格</h4><p>对于非空语句块，大括号遵循<code>Kernighan</code>和<code>Ritchie</code>风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接<code>else</code>或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><pre><code class="java">return () -&gt; {    while (condition()) {        method();    }};return new MyClass() {    @Override public void method() {        if (condition()) {            try {                something();            } catch (ProblemException e) {                recover();            }        } else if (otherCondition()) {            somethingElse();        } else {            lastThing();        }    }};</code></pre><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：<code>if/else</code> 或者<code>try/catch/finally</code>）.</p><p>示例：</p><pre><code class="java">// 这是可接受的void doNothing() {}// 这同样是可接受的void doNothingElse() {}</code></pre><pre><code class="java">// 这是不可接受的：多块语句中没有简洁的空语句块try {    doSomething();} catch (Exception e) {}</code></pre><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为<code>100个</code>字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到shell中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code>个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。</li><li>如果要在非赋值运算符处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code>表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><pre><code class="java">MyLambda&lt;String, Long, Object&gt; lambda =    (String label, Long value, Object obj) -&gt; {        ...    };Predicate&lt;String&gt; predicate = str -&gt;    longExpressionInvolving(str);</code></pre><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进<code>4</code>个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只<code>4</code>个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code>语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code>等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：<code>a = 0; // 赋值为0</code>）</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。（例如：<code>List&lt;String&gt; list</code>）</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>）</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><pre><code class="java">private int x;   // 这种挺好private Color color;   // 同上private int   x;      // 允许，但是未来会继续编辑private Color color;  // 可能会使它对不齐</code></pre><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和<code>reviewer</code>都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：</p><pre><code class="java">private enum Answer {    YES {        @Override public String toString() {            return &quot;yes&quot;;        }    },    NO,    MAYBE}</code></pre><p>没有方法和Javadoc的枚举类可写成数组初始化的格式：</p><pre><code class="java">private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }</code></pre><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><pre><code class="java">new int[] {           new int[] {  0, 1, 2, 3            0,}                       1,                        2,new int[] {             3,  0, 1,               }  2, 3}                     new int[]                          {0, 1, 2, 3}</code></pre><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code>块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code>大括号之后缩进两个字符。每个<code>switch</code>标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。例如：</p><pre><code class="java">switch (input) {    case 1:    case 2:        prepareOneOrTwo();        // fall through    case 3:        handleOneTwoOrThree();        break;    default:        handleLargeNumber(input);}</code></pre><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default标签需要显式声明"><a href="#4-8-4-3-default标签需要显式声明" class="headerlink" title="4.8.4.3 default标签需要显式声明"></a>4.8.4.3 default标签需要显式声明</h5><p>每个<code>switch</code>语句中，都需要显式声明<code>default</code>标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的<code>switch</code>语句可以省略<code>default</code>语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接<code>Javadoc</code>之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><pre><code class="java">@Override@Nullablepublic String getNameIfPresent() { ... }</code></pre><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><pre><code class="java">@Override public int hashCode() { ... }</code></pre><p>注解应用到成员变量时，也是紧接<code>Javadoc</code>之后。不同的是，多个注解可以放在同一行。例如：</p><pre><code class="java">@Partial @Mock DataLoader loader;</code></pre><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用<code>/* */</code>进行注释，也可以用<code>//</code>进行注释。当使用<code>/* */</code>进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><pre><code class="java">/* * This is * okay. */// And so// is this./* Or you can * even do this. */</code></pre><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用<code>/* */</code>，<code>//</code>一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按<code>Java Lauguage Specification</code>中介绍的先后顺序排序。具体是：</p><pre><code class="java">public protected private abstract default static final transient volatile synchronized native strictfp</code></pre><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的<code>L</code>作为后缀，不得使用小写（以免与数字1混淆）。例如：使用<code>3000000000L</code>，而不是<code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用<code>ASCII</code>字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用<code>com.example.deepspace</code>，而不是<code>com.example.deepSpace</code>或者<code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code>或者<code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语（例如：<code>Readable</code>）。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如：<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code>或者<code>stop</code>。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态<code>final</code>字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><pre><code class="java">// 常量static final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);static final ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of(&quot;Ed&quot;, 35, &quot;Ann&quot;, 32);static final Joiner COMMA_JOINER = Joiner.on(&#39;,&#39;); // 因为Joiner是不可变的static final SomeMutableType[] EMPTY_ARRAY = {};enum SomeEnum { ENUM_CONSTANT }// 非常量static String nonFinal = &quot;non-final&quot;;final String nonStatic = &quot;non-static&quot;;static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final ImmutableMap&lt;String, SomeMutableType&gt; mutableValues =    ImmutableMap.of(&quot;Ed&quot;, mutableInstance, &quot;Ann&quot;, mutableInstance2);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = {&quot;these&quot;, &quot;can&quot;, &quot;change&quot;};</code></pre><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code>或者<code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写。</p><p>即使局部变量是<code>final</code>和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><strong>驼峰式命名法</strong>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯<code>ASCII</code>码，并且移除任何单引号。例如：<code>Müller’s algorithm</code>将变成<code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code>将分割成<code>ad words</code>)。 </li><li>需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter^</td><td>无</td></tr></tbody></table><p>加<code>^</code>号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code>和<code>non-empty</code>都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把<code>@Override</code>注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为<code>@Deprecated</code>时，可以省略<code>@Override</code>。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p><pre><code class="java">try {    int i = Integer.parseInt(response);    return handleNumericResponse(i);} catch (NumberFormatException ok) {    // 它不是一个数字，不过没关系，继续}return handleTextResponse(response);</code></pre><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><pre><code class="java">try {    emptyStack.pop();    fail();} catch (NoSuchElementException expected) {}</code></pre><p>6.3 静态成员：使用类来调用</p><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><pre><code class="java">Foo aFoo = ...;Foo.aStaticMethod(); // 好aFoo.aStaticMethod(); // 糟somethingThatYieldsAFoo().aStaticMethod(); // 很糟</code></pre><p>6.4 <code>Finalizers</code>: 禁用</p><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用<code>finalize</code>。如果你非要使用它，请先仔细阅读和理解<code>Effective Java第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code>块的基本格式如下所示：</p><pre><code class="java">/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) { ... }</code></pre><p>或者是以下单行形式：</p><pre><code class="java">/** An especially short bit of Javadoc. */</code></pre><p>基本格式总是可以接受的。当整个<code>Javadoc</code>块能容纳于一行时(且没有标记<code>@XXX</code>)，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和<code>Javadoc</code>标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进<code>4</code>个空格(<strong>注</strong>：如果你的缩进统一采用采用<code>4</code>个空格，那么这里就应该是<code>8</code>个空格)。</p><h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的<code>Javadoc</code>以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或者<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用Javadoc"><a href="#7-3-在哪里使用Javadoc" class="headerlink" title="7.3 在哪里使用Javadoc"></a>7.3 在哪里使用Javadoc</h3><p>至少在每个<code>public</code>类及它的每个<code>public</code>和<code>protected</code>成员处使用<code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，<code>Javadoc</code>是可选的(可以不写)。这种情况下除了写<code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么<code>Javadoc</code>并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用<code>Javadoc</code>的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成<code>Javadoc</code>，这样更统一更友好。</p><p>原文地址: <a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Java调用PhantomJS动态导出ECharts图片到Word文件中</title>
      <link href="/2018/10/01/hou-duan/java/shi-yong-java-diao-yong-phantomjs-dong-tai-dao-chu-echarts-tu-pian-dao-word-wen-jian-zhong/"/>
      <url>/2018/10/01/hou-duan/java/shi-yong-java-diao-yong-phantomjs-dong-tai-dao-chu-echarts-tu-pian-dao-word-wen-jian-zhong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在一个项目中遇到导出为Word文件的问题，导出Word的功能很简单，但是导出Word文件中包含数据库动态查询的统计数据而生成的Echarts图片，且导出Word的时机又是在凌晨的服务器定时执行，所以不能通过客户端访问统计页面时再去生成。</p><p>服务端语言使用Java语言，最开始考虑使用<a href="http://www.jfree.org/jfreechart/index.html" target="_blank" rel="noopener">JFreeChart</a>来生成统计图片，但是JFreeChart生成的图片很丑，且和ECharts的统计图效果截然不同。所以最终抛弃了使用<code>JFreeChart</code>，而采用了在服务端使用Java调用<a href="http://phantomjs.org/" target="_blank" rel="noopener">PhantomJS</a>的指令来导出Ehcarts图片。所以主要的技术方案选型如下：</p><ul><li><code>poi-tl</code>，一个简单的基于<code>Word</code>模版生成<code>Word</code>的工具。</li><li><code>PhantomJS</code>，一个基于<code>webkit</code>内核的无头浏览器，可在服务端程序实现加载、操作页面等功能</li></ul><h2 id="使用poi-tl导出Word"><a href="#使用poi-tl导出Word" class="headerlink" title="使用poi-tl导出Word"></a>使用poi-tl导出Word</h2><h3 id="poi-tl介绍"><a href="#poi-tl介绍" class="headerlink" title="poi-tl介绍"></a>poi-tl介绍</h3><p>使用Java导出Word通常采用的是<a href="https://poi.apache.org/" target="_blank" rel="noopener">Apache POI</a>的库，但是使用POI来导出Word，会书写大量的段落、样式等细节代码，代码量巨大，而且不易于维护。通过<a href="https://github.com/Sayi/poi-tl" target="_blank" rel="noopener">poi-tl</a>只需要制作导出的模版，服务端一行代码调用，传入模版路径和<code>Map</code>或者<code>Bean</code>即可生成Word模版，代码量大大降低，以后导出样式不满意的时候，只需要修改Word模版文件即可。</p><blockquote><p><strong>注意</strong>：<code>poi-tl</code>只能生成<code>docx</code>文件，对word2007之前的<code>doc</code>文档则不支持。</p></blockquote><h3 id="Maven引入"><a href="#Maven引入" class="headerlink" title="Maven引入"></a>Maven引入</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.deepoove&lt;/groupId&gt;    &lt;artifactId&gt;poi-tl&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p><strong>注</strong>：该包带入了<code>POI3.16</code>，如果系统中本身有低于<code>3.15</code>版本的<code>POI</code>，需要排除掉，否则生成Word时会报错。</p></blockquote><h3 id="demo示例"><a href="#demo示例" class="headerlink" title="demo示例"></a>demo示例</h3><p>首先，制作一个用于测试的word模版，使用<code>poi-tl</code>的标记语法做如下标记，如下图所示：</p><p><img src="http://static.blinkfox.com/test_word_template.jpg" alt="测试word模版"></p><p>然后，构造一个需要渲染的model JavaBean类，如果有多个Bean，貌似只能通过继承来复用属性，采用组合的方式是渲染不了的，代码如下：</p><pre><code class="java">/** * BaseProp * @author blinkfox on 2017-06-28. */public class BaseProp {    protected String baseProp;    /**     * 构造方法.     * @param baseProp 基础属性     */    public BaseProp() {        super();    }    public String getBaseProp() {        return baseProp;    }    public void setBaseProp(String baseProp) {        this.baseProp = baseProp;    }}</code></pre><pre><code class="java">/** * 测试旅游信息的bean. * @author blinkfox on 2017-06-28. */public class Travel extends BaseProp {    private String title;    private String smallTitle;    private String startDate;    private String endDate;    private int count;    private double money;    private String place1;    private String place2;    private PictureRenderData pic;    /**     * 构造方法.     */    public Travel() {        super();    }    /*getter和setter方法.*/    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public String getSmallTitle() {        return smallTitle;    }    public void setSmallTitle(String smallTitle) {        this.smallTitle = smallTitle;    }    public String getStartDate() {        return startDate;    }    public void setStartDate(String startDate) {        this.startDate = startDate;    }    public String getEndDate() {        return endDate;    }    public void setEndDate(String endDate) {        this.endDate = endDate;    }    public int getCount() {        return count;    }    public void setCount(int count) {        this.count = count;    }    public double getMoney() {        return money;    }    public void setMoney(double money) {        this.money = money;    }    public String getPlace1() {        return place1;    }    public void setPlace1(String place1) {        this.place1 = place1;    }    public String getPlace2() {        return place2;    }    public void setPlace2(String place2) {        this.place2 = place2;    }    public PictureRenderData getPic() {        return pic;    }    public void setPic(PictureRenderData pic) {        this.pic = pic;    }}</code></pre><p>最后，是模拟调用示例：</p><pre><code class="java">/** * poi-tl库的使用示例. * Created by blinkfox on 2017/6/27. */public class PoitlTest {    private static final Logger log = LoggerFactory.getLogger(PoitlTest.class);    /** 项目资源路径. */    private static final String PATH = &quot;F:/poitl-test/web&quot;;    /** word模板路径. */    private static final String DOC_PATH = PATH + &quot;/template/test/test.docx&quot;;    /** 图片路径. */    private static final String PIC_PATH = PATH + &quot;/template/test/pic.png&quot;;    /** 输出文件及路径. */    private static final String OUTPUT_PATH = &quot;G:/test/poitl_out_word.docx&quot;;    /**     * 构造Bean型的data数据.     * @return map     */    private static Travel buildBeanData() {        Travel travel = new Travel();        travel.setTitle(&quot;我的旅游日记&quot;);        travel.setSmallTitle(&quot;再写日记&quot;);        travel.setStartDate(&quot;2017-01-01&quot;);        travel.setEndDate(&quot;2017-06-28&quot;);        travel.setCount(3);        travel.setPlace1(&quot;九寨沟&quot;);        travel.setPlace2(&quot;天涯海角&quot;);        travel.setMoney(1872.52);        travel.setPic(new PictureRenderData(600, 400, PIC_PATH));        travel.setBaseProp(&quot;这是&quot;);        return travel;    }    /**     * main方法.     * @param args 数组参数     */    public static void main(String[] args) throws IOException {        XWPFTemplate template = XWPFTemplate.compile(DOC_PATH).render(buildBeanData());        FileOutputStream out = new FileOutputStream(OUTPUT_PATH);        template.write(out);        out.flush();        out.close();        template.close();        log.info(&quot;通过&#39;poi-tl&#39;导出word成功!&quot;);    }}</code></pre><p>最后，在导出的文件夹中可查看生成的word文件，如下所示：</p><p><img src="http://static.blinkfox.com/test_out_result.jpg" alt="生成的Word文件结果"></p><h2 id="Java调用PhantomJS导出Ehcarts图片"><a href="#Java调用PhantomJS导出Ehcarts图片" class="headerlink" title="Java调用PhantomJS导出Ehcarts图片"></a>Java调用PhantomJS导出Ehcarts图片</h2><h3 id="PhantomJS介绍"><a href="#PhantomJS介绍" class="headerlink" title="PhantomJS介绍"></a>PhantomJS介绍</h3><p><code>PhantomJS</code>是一个基于<code>webkit</code>内核的无头浏览器，即没有UI界面的一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。<code>PhantomJS</code>提供JavaScript API接口，即通过编写js程序可以直接与<code>webkit</code>内核交互，在此之上可以结合Java语言等，通过java调用js等相关操作，从而解决了以前<code>c/c++</code>才能比较好的基于<code>webkit</code>开发优质采集器的限制。</p><h3 id="PhantomJS的安装配置"><a href="#PhantomJS的安装配置" class="headerlink" title="PhantomJS的安装配置"></a>PhantomJS的安装配置</h3><h4 id="windows环境"><a href="#windows环境" class="headerlink" title="windows环境"></a>windows环境</h4><p>如果是在windows环境下，则在官网下载解压到某个目录后，将其bin目录加入到<code>path</code>变量中即可。</p><h4 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h4><p>如果是在<code>Linux</code>环境下，在官网下载解压后，同样需要将<code>PhantomJS</code>的<code>bin</code>目录加入到<code>path</code>环境变量中，参考的命令和配置如下：</p><pre><code class="bash"># 编辑配置文件.vi ~/.bashrc# 将PhantomJS的bin目录加入到PATH环境变量中.export PHANTOMJS_HOME=/home/blinkfox/Documents/phantomjs-2.1.1-linux-x86_64export PATH=${PHANTOMJS_HOME}/bin:$PATH# 退出vi编辑器，使用source命令让刚才的配置即时生效.source ~/.bashrc# 测试PhantomJS是否安装成功，如果打出了版本信息，即安装成功.phantomjs -v</code></pre><h3 id="demo示例-1"><a href="#demo示例-1" class="headerlink" title="demo示例"></a>demo示例</h3><p>这个demo的需求是这样的，我们使用Java调用<code>PhantomJS</code>的指令来在服务端加载含<code>ECharts</code>统计的图<code>html</code>文件，然后调用<code>ECharts</code>的生成图片方法，将图片传输到Java后台最终实现保存图片到指定路径中。</p><p>首先，制作<code>ECharts</code>的html页面，示例页面如下代码如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;测试的ECharts数据统计图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;    &lt;div id=&quot;main&quot; style=&quot;width:560px; height:270px;&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/lib/jquery/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/lib/echarts/v3/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById(&#39;main&#39;));// 指定图表的配置项和数据var option = {    title: {        text: &#39;ECharts 入门示例&#39;    },    animation: false, // 关闭动画效果    tooltip: {},    legend: {        data:[&#39;销量&#39;]    },    xAxis: {        data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]    },    yAxis: {},    series: [{        name: &#39;销量&#39;,        type: &#39;bar&#39;,        data: [5, 20, 36, 10, 10, 20]    }]};// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);/** * ajax传输图片信息. */function postImage() {    // 向后台发起请求保存图片到指定目录.    $.ajax({        type: &#39;POST&#39;,        url: &#39;/test/saveImage&#39;,        data: {picInfo: myChart.getDataURL()},        success: function() {            console.log(&#39;通过post请求传输数据成功!&#39;);        }    });}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后，使用<code>Servlet</code>来写一个服务端代码，用来获取<code>Base64</code>的图片信息并在后端解析保存图片，<code>Servlet</code>代码如下：</p><pre><code class="java">/** * 保存Echarts统计图片的Servlet. * @author blinkfox on 2017-06-28. */public class SaveImageServlet extends HttpServlet {    private static final long serialVersionUID = 1L;    private static final Logger log = LoggerFactory.getLogger(SaveImageServlet.class);    /**     * 执行获取echarts图片的post请求.     * @param request req     * @param response resp     * @throws ServletException Servlet异常.     * @throws IOException IO异常.     */    @Override    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // 获取图片信息.        String picInfo = request.getParameter(&quot;picInfo&quot;);        if (StringUtils.isBlank(picInfo)) {            log.error(&quot;picInfo为空,未从前台获取到base64图片信息!&quot;);            return;        }        this.getAndsaveImage(picInfo, &quot;G:/test/image1.png&quot;);    }    /**     * 获取并保存图片到本地.     * @param picInfo 图片信息     * @param imagePath 图片保存的路径     */    private void getAndsaveImage(String picInfo, String imagePath) {        // 传递过程中  &quot;+&quot; 变为了 &quot; &quot;.        String newPicInfo = picInfo.replaceAll(&quot; &quot;, &quot;+&quot;);        String picPath = decodeBase64(newPicInfo, new File(imagePath));        log.warn(&quot;从echarts中生成图片的的路径为:{}&quot;, picPath);    }    /**     * 解析Base64位信息并输出到某个目录下面.     * @param base64Info base64串     * @param picPath 生成的文件路径     * @return 文件地址     */    private String decodeBase64(String base64Info, File picPath) {        if (StringUtils.isEmpty(base64Info)) {            return null;        }        // 数据中：data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABI4AAAEsCAYAAAClh/jbAAA ...  在&quot;base64,&quot;之后的才是图片信息        String[] arr = base64Info.split(&quot;base64,&quot;);        // 将图片输出到系统某目录.        OutputStream out = null;        try {            // 使用了Apache commons codec的包来解析Base64            byte[] buffer = Base64.decodeBase64(arr[1]);            out = new FileOutputStream(picPath);            out.write(buffer);        } catch (IOException e) {            log.error(&quot;解析Base64图片信息并保存到某目录下出错!&quot;, e);        } finally {            IOUtils.closeQuietly(out);        }        return picPath;    }}</code></pre><p>然后，是书写PhantomJS脚本<code>echarts_load.js</code>来加载和调用图片下载的代码：</p><pre><code class="javascript">var system = require(&#39;system&#39;);var page = require(&#39;webpage&#39;).create();// 如果是windows,设置编码为gbk，防止中文乱码,Linux本身是UTF-8var osName = system.os.name;console.log(&#39;os name:&#39; + osName);if (&#39;windows&#39; === osName.toLowerCase()) {    phantom.outputEncoding=&quot;gbk&quot;;}// 获取第二个参数(即请求地址url).var url = system.args[1];console.log(&#39;url:&#39; + url);// 显示控制台日志.page.onConsoleMessage = function(msg, lineNum, sourceId) {    console.log(&#39;CONSOLE: &#39; + msg + &#39; (from line #&#39; + lineNum + &#39; in &quot;&#39; + sourceId + &#39;&quot;)&#39;);};//打开给定url的页面.var start = new Date().getTime();page.open(url, function(status) {    if (status == &#39;success&#39;) {        console.log(&#39;echarts页面加载完成,加载耗时:&#39; + (new Date().getTime() - start) + &#39; ms&#39;);        // 由于echarts动画效果，延迟500毫秒确保图片渲染完毕再调用下载图片方法.        setTimeout(function() {            page.evaluate(function() {                postImage();                console.log(&quot;调用了echarts的下载图片功能.&quot;);            });        }, 500);    } else {        console.log(&quot;页面加载失败 Page failed to load!&quot;);    }    // 3秒后再关闭浏览器.    setTimeout(function() {        phantom.exit();    }, 3000);});</code></pre><p>最后，是使用<code>Java</code>来调用<code>PhantomJS</code>的指令，代码如下：</p><pre><code class="java">/** * HttpTest. * @author blinkfox on 2017-06-28. * @version 1.0 */public class HttpTest {    private static final Logger log = LoggerFactory.getLogger(HttpTest.class);    private static final String PHANTOM_PATH = &quot;phantomjs&quot;;    //这里我的test.js是保存在G盘下面的phantomjs目录    private static final String TEST_JS = &quot;G:/test/phantom/test.js &quot;;    public void String downloadImage(String url) throws IOException {        String cmdStr = PHANTOM_PATH + TEST_JS + url;        log.info(&quot;命令行字符串:{}&quot;, cmdStr);        Runtime rt = Runtime.getRuntime();        try {            rt.exec(cmdStr);        } catch (IOException e) {            log.error(&quot;执行phantomjs的指令失败！请检查是否安装有PhantomJs的环境或配置path路径！PhantomJs详情参考这里:http://phantomjs.org&quot;, e);        }    }    /**     * main.     * @param args args     * @throws IOException IO异常     */    public static void main(String[] args) throws IOException {        downloadImage(&quot;http://127.0.0.1:8080/test/echart_test/test_echarts.html&quot;);    }}</code></pre><p>通过调用测试代码即可在指定目录生成<code>Echarts</code>的图片啦！</p><p>联系上面生成<code>Word</code>的功能，两个功能一结合即可动态导出<code>ECharts</code>图片到<code>Word</code>文件中。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Lang之日期时间工具类</title>
      <link href="/2018/09/29/hou-duan/java/commons/apache-commons-lang-zhi-ri-qi-shi-jian-gong-ju-lei/"/>
      <url>/2018/09/29/hou-duan/java/commons/apache-commons-lang-zhi-ri-qi-shi-jian-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>码农不识Apache，码尽一生也枉然。</p></blockquote><h2 id="FastDateFormat"><a href="#FastDateFormat" class="headerlink" title="FastDateFormat"></a>FastDateFormat</h2><p><code>FastDateFormat</code>是一个快速且线程安全的时间操作类，它完全可以替代<code>SimpleDateFromat</code>。因为是线程安全的，所以你可以把它作为一个类的静态字段使用。构造方法为protected，不允许直接构造它的对象，可以通过工厂方法获取。FastDateFormat之所以是线程安全的，是因为这个类是无状态的：内部的成员在构造时就完成了初始化，并在对象存活期，不提供任何API供外界修改他们。</p><h3 id="getInstance-String-pattern"><a href="#getInstance-String-pattern" class="headerlink" title="getInstance(String pattern)"></a>getInstance(String pattern)</h3><p>获取指定日期时间格式的<code>FastDateFormat</code>实例。</p><h3 id="format-Date-date"><a href="#format-Date-date" class="headerlink" title="format(Date date)"></a>format(Date date)</h3><p>将日期时间格式化为字符串。</p><pre><code class="java">FastDateFormat.getInstance(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()); // 2017-06-03 23:32:31</code></pre><h3 id="format-long-millis"><a href="#format-long-millis" class="headerlink" title="format(long millis)"></a>format(long millis)</h3><p>同<code>format(Date date)</code>相似。</p><h3 id="format-Calendar-calendar"><a href="#format-Calendar-calendar" class="headerlink" title="format(Calendar calendar)"></a>format(Calendar calendar)</h3><p>同<code>format(Date date)</code>相似。</p><h2 id="DateFormatUtils"><a href="#DateFormatUtils" class="headerlink" title="DateFormatUtils"></a>DateFormatUtils</h2><p>将时间转化为字符串的工具类。不可实例化对象且线程安全，依赖于<code>FastDateFormat</code>。</p><h3 id="预定义的日期格式"><a href="#预定义的日期格式" class="headerlink" title="预定义的日期格式"></a>预定义的日期格式</h3><p><code>DateFormatUtils</code>预定义的日期格式有如下几种：</p><pre><code class="java">public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_FORMAT = FastDateFormat.getInstance(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss&quot;);public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZZ&quot;);public static final FastDateFormat ISO_8601_EXTENDED_DATE_FORMAT = FastDateFormat.getInstance(&quot;yyyy-MM-dd&quot;);public static final FastDateFormat ISO_8601_EXTENDED_TIME_FORMAT = FastDateFormat.getInstance(&quot;HH:mm:ss&quot;);public static final FastDateFormat ISO_8601_EXTENDED_TIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance(&quot;HH:mm:ssZZ&quot;);public static final FastDateFormat SMTP_DATETIME_FORMAT = FastDateFormat.getInstance(&quot;EEE, dd MMM yyyy HH:mm:ss Z&quot;, Locale.US);</code></pre><h3 id="format-Date-date-String-pattern"><a href="#format-Date-date-String-pattern" class="headerlink" title="format(Date date, String pattern)"></a>format(Date date, String pattern)</h3><p>将日期格式化为字符串。</p><pre><code class="java">DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;); // 2017-06-03 23:03:53DateFormatUtils.ISO_8601_EXTENDED_DATETIME_FORMAT.format(new Date()); // 2017-06-03T23:09:52DateFormatUtils.format(System.currentTimeMillis(), &quot;yyyy-MM-dd HH:mm:ss&quot;); // 2017-06-03 23:16:59</code></pre><h3 id="format-long-millis-String-pattern"><a href="#format-long-millis-String-pattern" class="headerlink" title="format(long millis, String pattern)"></a>format(long millis, String pattern)</h3><p>同<code>format(Date date, String pattern)</code>相似。</p><h3 id="format-Calendar-calendar-String-pattern"><a href="#format-Calendar-calendar-String-pattern" class="headerlink" title="format(Calendar calendar, String pattern)"></a>format(Calendar calendar, String pattern)</h3><p>同<code>format(Date date, String pattern)</code>相似。</p><h2 id="DateUtils"><a href="#DateUtils" class="headerlink" title="DateUtils"></a>DateUtils</h2><p><code>DateUtils</code>提供了很多很方便的功能，减轻了使用Date的复杂性。把原来需用<code>Calendar</code>才能完成的功能统一集中了起来，也就是说没有对应的<code>CalendarUtils</code>类。在JDK中，Date与Calendar概念本身就有些混淆，只是为了保持兼容性才引入的Calendar。相对于Calendar提供的方法，DateUtils提供了更加合理的方法，对时间的单个字段操作变得更加的容易。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="java">public static final long MILLIS_PER_SECOND = 1000; // 1秒钟的毫秒数public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; // 1分钟的毫秒数public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; // 1小时的毫秒数public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; // 1天的毫秒数</code></pre><h3 id="boolean-isSameDay-Date-date1-Date-date2"><a href="#boolean-isSameDay-Date-date1-Date-date2" class="headerlink" title="boolean isSameDay(Date date1, Date date2)"></a>boolean isSameDay(Date date1, Date date2)</h3><p>判断两个日期是否是同一天。</p><pre><code class="java">DateUtils.isSameDay(new Date(), new Date()); // true</code></pre><h3 id="boolean-isSameDay-Calendar-cal1-Calendar-cal2"><a href="#boolean-isSameDay-Calendar-cal1-Calendar-cal2" class="headerlink" title="boolean isSameDay(Calendar cal1, Calendar cal2)"></a>boolean isSameDay(Calendar cal1, Calendar cal2)</h3><p>同<code>isSameDay(Date date1, Date date2)</code>相似。</p><h3 id="Date-parseDate-String-str-String…-parsePatterns"><a href="#Date-parseDate-String-str-String…-parsePatterns" class="headerlink" title="Date parseDate(String str, String… parsePatterns)"></a>Date parseDate(String str, String… parsePatterns)</h3><p>解析日期时间字符串日期时间Date对象，通过尝试各种不同的解析器来解析表示日期的字符串。</p><pre><code class="java">DateUtils.parseDate(&quot;2017-06-03 23:51:44&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;); // 2017-06-03 23:51:44DateUtils.parseDate(&quot;2017年06月03日 23时51分44秒&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);</code></pre><h3 id="Date-addYears-Date-date-int-amount"><a href="#Date-addYears-Date-date-int-amount" class="headerlink" title="Date addYears(Date date, int amount)"></a>Date addYears(Date date, int amount)</h3><p>得到<code>date</code>日期时间后（前）<code>amount</code>年后的日期时间。</p><pre><code class="java">Date d3 = DateUtils.addYears(new Date(), 3); // 2020-06-04 00:06:21Date d3 = DateUtils.addYears(new Date(), -2); // 2015-06-04 00:06:21</code></pre><h3 id="Date-addMonths-Date-date-int-amount"><a href="#Date-addMonths-Date-date-int-amount" class="headerlink" title="Date addMonths(Date date, int amount)"></a>Date addMonths(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对月份数进行加减。</p><h3 id="Date-addWeeks-Date-date-int-amount"><a href="#Date-addWeeks-Date-date-int-amount" class="headerlink" title="Date addWeeks(Date date, int amount)"></a>Date addWeeks(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对周数进行加减。</p><h3 id="Date-addDays-Date-date-int-amount"><a href="#Date-addDays-Date-date-int-amount" class="headerlink" title="Date addDays(Date date, int amount)"></a>Date addDays(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对天数进行加减。</p><h3 id="Date-addHours-Date-date-int-amount"><a href="#Date-addHours-Date-date-int-amount" class="headerlink" title="Date addHours(Date date, int amount)"></a>Date addHours(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对小时数进行加减。</p><h3 id="Date-addMinutes-Date-date-int-amount"><a href="#Date-addMinutes-Date-date-int-amount" class="headerlink" title="Date addMinutes(Date date, int amount)"></a>Date addMinutes(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对分钟数进行加减。</p><h3 id="Date-addSeconds-Date-date-int-amount"><a href="#Date-addSeconds-Date-date-int-amount" class="headerlink" title="Date addSeconds(Date date, int amount)"></a>Date addSeconds(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对秒数进行加减。</p><h3 id="Date-addMilliseconds-Date-date-int-amount"><a href="#Date-addMilliseconds-Date-date-int-amount" class="headerlink" title="Date addMilliseconds(Date date, int amount)"></a>Date addMilliseconds(Date date, int amount)</h3><p>同<code>addYears(Date date, int amount)</code>相似，对毫秒数进行加减。</p><h3 id="Date-setYears-Date-date-int-amount"><a href="#Date-setYears-Date-date-int-amount" class="headerlink" title="Date setYears(Date date, int amount)"></a>Date setYears(Date date, int amount)</h3><p>对给定的日期时间设置年份。</p><pre><code class="java">Date d4 = DateUtils.setYears(new Date(), 2028); // 2028-06-04 00:16:48</code></pre><h3 id="Date-setMonths-Date-date-int-amount"><a href="#Date-setMonths-Date-date-int-amount" class="headerlink" title="Date setMonths(Date date, int amount)"></a>Date setMonths(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对月数进行设置。</p><h3 id="Date-setDays-Date-date-int-amount"><a href="#Date-setDays-Date-date-int-amount" class="headerlink" title="Date setDays(Date date, int amount)"></a>Date setDays(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对天数进行设置。</p><h3 id="Date-setHours-Date-date-int-amount"><a href="#Date-setHours-Date-date-int-amount" class="headerlink" title="Date setHours(Date date, int amount)"></a>Date setHours(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对小时数进行设置。</p><h3 id="Date-setMinutes-Date-date-int-amount"><a href="#Date-setMinutes-Date-date-int-amount" class="headerlink" title="Date setMinutes(Date date, int amount)"></a>Date setMinutes(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对分钟数进行设置。</p><h3 id="Date-setSeconds-Date-date-int-amount"><a href="#Date-setSeconds-Date-date-int-amount" class="headerlink" title="Date setSeconds(Date date, int amount)"></a>Date setSeconds(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对秒钟数进行设置。</p><h3 id="Date-setMilliseconds-Date-date-int-amount"><a href="#Date-setMilliseconds-Date-date-int-amount" class="headerlink" title="Date setMilliseconds(Date date, int amount)"></a>Date setMilliseconds(Date date, int amount)</h3><p>同<code>setYears(Date date, int amount)</code>相似，对毫秒数进行设置。</p><h3 id="toCalendar-Date-date"><a href="#toCalendar-Date-date" class="headerlink" title="toCalendar(Date date)"></a>toCalendar(Date date)</h3><p>将日期转为<code>Calendar</code>实例。</p><h3 id="Date-round-Date-date-int-field"><a href="#Date-round-Date-date-int-field" class="headerlink" title="Date round(Date date, int field)"></a>Date round(Date date, int field)</h3><p>对日期时间进行四舍五入。filed指定取整的字段，可以取的值为</p><ul><li>Calendar.SECOND</li><li>Calendar.MINUTE</li><li>Calendar.HOUR_OF_DAY</li><li>Calendar.DAY_OF_MONTH</li><li>Calendar.MONTH</li><li>Calendar.YEAR<br>… </li></ul><pre><code class="java">// 当前时间为&#39;2017-06-04 00:44:41&#39;，则执行以下代码DateUtils.round(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00DateUtils.round(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00DateUtils.round(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 01:00:00DateUtils.round(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00DateUtils.round(new Date(), Calendar.HOUR); // 2017-06-04 01:00:00DateUtils.round(new Date(), Calendar.MINUTE); // 2017-06-04 00:45:00DateUtils.round(new Date(), Calendar.SECOND); // 2017-06-04 00:44:43</code></pre><h3 id="Date-truncate-Date-date-int-field"><a href="#Date-truncate-Date-date-int-field" class="headerlink" title="Date truncate(Date date, int field)"></a>Date truncate(Date date, int field)</h3><p>从给定字段开始格式化截取日期。对一个时间对象的某个字段进行截断。</p><pre><code class="java">// 当前时间为&#39;2017-06-04 00:56:05&#39;，则执行以下代码DateUtils.truncate(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00DateUtils.truncate(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00DateUtils.truncate(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 00:00:00DateUtils.truncate(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00DateUtils.truncate(new Date(), Calendar.HOUR); // 2017-06-04 00:00:00DateUtils.truncate(new Date(), Calendar.MINUTE); // 2017-06-04 00:56:00DateUtils.truncate(new Date(), Calendar.SECOND); // 2017-06-04 00:56:05</code></pre><h3 id="Date-ceiling-Date-date-int-field"><a href="#Date-ceiling-Date-date-int-field" class="headerlink" title="Date ceiling(Date date, int field)"></a>Date ceiling(Date date, int field)</h3><p>从给定字段开始“向上”格式化日期。</p><pre><code class="java">// 当前时间为&#39;2017-06-04 01:02:31&#39;，则执行以下代码DateUtils.ceiling(new Date(), Calendar.YEAR); // 2018-01-01 00:00:00DateUtils.ceiling(new Date(), Calendar.MONTH); // 2017-07-01 00:00:00DateUtils.ceiling(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 02:00:00DateUtils.ceiling(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-05 00:00:00DateUtils.ceiling(new Date(), Calendar.HOUR); // 2017-06-04 02:00:00DateUtils.ceiling(new Date(), Calendar.MINUTE); // 2017-06-04 01:03:00DateUtils.ceiling(new Date(), Calendar.SECOND); // 2017-06-04 01:02:32</code></pre><h3 id="long-getFragmentInDays-Date-date-int-fragment"><a href="#long-getFragmentInDays-Date-date-int-fragment" class="headerlink" title="long getFragmentInDays(Date date, int fragment)"></a>long getFragmentInDays(Date date, int fragment)</h3><p>返回一个指定时间的天数。关键的是参数<code>fragment</code>，它的作用非常重要。它的值必须是Calendar的时间常量字段。</p><p><strong>注意</strong>：小时必须用24小时制的，即<code>Calendar.HOUR_OF_DAY</code>，而不能用<code>Calendar.HOUR</code>字段。</p><pre><code class="java">// 当前时间为&#39;2017-06-04 01:12:31&#39;，则执行以下代码DateUtils.getFragmentInDays(new Date(), Calendar.YEAR); // 155DateUtils.getFragmentInDays(new Date(), Calendar.MONTH); // 4</code></pre><h3 id="long-getFragmentInMilliseconds-Date-date-int-fragment"><a href="#long-getFragmentInMilliseconds-Date-date-int-fragment" class="headerlink" title="long getFragmentInMilliseconds(Date date, int fragment)"></a>long getFragmentInMilliseconds(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="long-getFragmentInSeconds-Date-date-int-fragment"><a href="#long-getFragmentInSeconds-Date-date-int-fragment" class="headerlink" title="long getFragmentInSeconds(Date date, int fragment)"></a>long getFragmentInSeconds(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="long-getFragmentInMinutes-Date-date-int-fragment"><a href="#long-getFragmentInMinutes-Date-date-int-fragment" class="headerlink" title="long getFragmentInMinutes(Date date, int fragment)"></a>long getFragmentInMinutes(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="long-getFragmentInHours-Date-date-int-fragment"><a href="#long-getFragmentInHours-Date-date-int-fragment" class="headerlink" title="long getFragmentInHours(Date date, int fragment)"></a>long getFragmentInHours(Date date, int fragment)</h3><p>同<code>getFragmentInDays(Date date, int fragment)</code>相似。</p><h3 id="boolean-truncatedEquals-Date-date1-Date-date2-int-field"><a href="#boolean-truncatedEquals-Date-date1-Date-date2-int-field" class="headerlink" title="boolean truncatedEquals(Date date1, Date date2, int field)"></a>boolean truncatedEquals(Date date1, Date date2, int field)</h3><p>比较日历对应字段是否相等。</p><h2 id="StopWatch"><a href="#StopWatch" class="headerlink" title="StopWatch"></a>StopWatch</h2><p><code>StopWatch</code>是一个方便的计时器。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code class="java">StopWatch stopWatch = new StopWatch();stopWatch.start();...stopWatch.stop();System.out.println(stopWatch.getTime());</code></pre><h3 id="主要方法："><a href="#主要方法：" class="headerlink" title="主要方法："></a>主要方法：</h3><ul><li><code>start()</code>: 开始计时</li><li><code>stop()</code>: 停止计时</li><li><code>reset()</code>: 重置计时</li><li><code>suspend()</code>: 暂停计时</li><li><code>resume()</code>: 继续计时</li><li><code>getTime()</code>: 获取消耗的毫秒数</li><li><code>getNanoTime()</code>: 获取消耗的纳秒数</li><li><code>getStartTime()</code>: 获取开始的毫秒数</li><li><code>isStarted()</code>: 是否开始</li><li><code>isSuspended()</code>: 是否暂停</li><li><code>isStopped()</code>: 是否停止</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Lang之ArrayUtils</title>
      <link href="/2018/09/28/hou-duan/java/commons/apache-commons-lang-zhi-arrayutils/"/>
      <url>/2018/09/28/hou-duan/java/commons/apache-commons-lang-zhi-arrayutils/</url>
      
        <content type="html"><![CDATA[<blockquote><p>码农不识Apache，码尽一生也枉然。</p></blockquote><h2 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h2><pre><code class="java">public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0];public static final String[] EMPTY_STRING_ARRAY = new String[0];public static final long[] EMPTY_LONG_ARRAY = new long[0];public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];public static final int[] EMPTY_INT_ARRAY = new int[0];public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];</code></pre><h2 id="转换为Map"><a href="#转换为Map" class="headerlink" title="转换为Map"></a>转换为Map</h2><h3 id="toMap-Object-array"><a href="#toMap-Object-array" class="headerlink" title="toMap(Object[] array)"></a>toMap(Object[] array)</h3><p>将二维数组转换为Map。</p><pre><code class="java">Map colorMap = ArrayUtils.toMap(new String[][] {    {&quot;RED&quot;, &quot;#FF0000&quot;},    {&quot;GREEN&quot;, &quot;#00FF00&quot;},    {&quot;BLUE&quot;, &quot;#0000FF&quot;}});</code></pre><h2 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h2><h3 id="T-toArray-final-T…-items"><a href="#T-toArray-final-T…-items" class="headerlink" title="T[] toArray(final T… items)"></a>T[] toArray(final T… items)</h3><p>将不定参数转换为数组。</p><pre><code class="java">String[] array = ArrayUtils.toArray(&quot;1&quot;, &quot;2&quot;);String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();</code></pre><h2 id="null转空数组"><a href="#null转空数组" class="headerlink" title="null转空数组"></a>null转空数组</h2><h3 id="Object-nullToEmpty-Object-array"><a href="#Object-nullToEmpty-Object-array" class="headerlink" title="Object[] nullToEmpty(Object[] array)"></a>Object[] nullToEmpty(Object[] array)</h3><p>将null数组转为对应类型的空数组，如果array不是null，则返回array。</p><pre><code class="java">String[] arr = ArrayUtils.nullToEmpty((String[]) null);</code></pre><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="T-subarray-T-array-int-startIndexInclusive-int-endIndexExclusive"><a href="#T-subarray-T-array-int-startIndexInclusive-int-endIndexExclusive" class="headerlink" title=" T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)"></a><t> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)</t></h3><p>截取数组开始索引位置和结束索引位置的数组为子数组</p><pre><code class="java">Object[]s1=ArrayUtils.subarray(newObject[]{&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;},0,1); // [&quot;aa&quot;]Object[]s2=ArrayUtils.subarray(newObject[]{&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;},0,2); // [&quot;aa&quot;, &quot;bb&quot;]</code></pre><h3 id="reverse-long-array"><a href="#reverse-long-array" class="headerlink" title="reverse(long[] array)"></a>reverse(long[] array)</h3><p>反转数组。</p><pre><code class="java">ArrayUtils.reverse(new String[]{&quot;aa&quot;,&quot;bb&quot;});//结果是：{&quot;bb&quot;，&quot;aa&quot;}</code></pre><h3 id="swap-Object-array-int-offset1-int-offset2"><a href="#swap-Object-array-int-offset1-int-offset2" class="headerlink" title="swap(Object[] array, int offset1, int offset2)"></a>swap(Object[] array, int offset1, int offset2)</h3><p>交换数组中的元素。</p><pre><code class="java">ArrayUtils.swap([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], 0, 2) -&gt; [&quot;3&quot;, &quot;2&quot;, &quot;1&quot;]ArrayUtils.swap([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], 0, 0) -&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]ArrayUtils.swap([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], 1, 0) -&gt; [&quot;2&quot;, &quot;1&quot;, &quot;3&quot;]ArrayUtils.swap([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], 0, 5) -&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]ArrayUtils.swap([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], -1, 1) -&gt; [&quot;2&quot;, &quot;1&quot;, &quot;3&quot;]</code></pre><h2 id="数组元素查找"><a href="#数组元素查找" class="headerlink" title="数组元素查找"></a>数组元素查找</h2><h3 id="int-indexOf-Object-array-Object-objectToFind"><a href="#int-indexOf-Object-array-Object-objectToFind" class="headerlink" title="int indexOf(Object[] array, Object objectToFind)"></a>int indexOf(Object[] array, Object objectToFind)</h3><p>数组元素所在的索引位置,如果没有则返回-1,可指定起始搜索位置。</p><pre><code class="java">ArrayUtils.indexOf(new String[]{&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;},&quot;cc&quot;); // 2ArrayUtils.indexOf(new String[]{&quot;aa&quot;,&quot;bb&quot;,&quot;bb&quot;},&quot;bb&quot;,2); // 2ArrayUtils.indexOf(newObject[]{&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;},&quot;cc&quot;,3); // -1</code></pre><h3 id="int-lastIndexOf-Object-array-Object-objectToFind-int-startIndex"><a href="#int-lastIndexOf-Object-array-Object-objectToFind-int-startIndex" class="headerlink" title="int lastIndexOf(Object[] array, Object objectToFind, int startIndex)"></a>int lastIndexOf(Object[] array, Object objectToFind, int startIndex)</h3><p>同<code>indexOf(Object[] array, Object objectToFind)</code>相反。反向查询某个object在数组中的位置，可以指定起始搜索位置。</p><h3 id="contains-Object-array-Object-objectToFind"><a href="#contains-Object-array-Object-objectToFind" class="headerlink" title="contains(Object[] array, Object objectToFind)"></a>contains(Object[] array, Object objectToFind)</h3><p>判断数组中是否包含某个元素。</p><pre><code class="java">ArrayUtils.contains(new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, &quot;a&quot;); // true</code></pre><h2 id="数组判空"><a href="#数组判空" class="headerlink" title="数组判空"></a>数组判空</h2><h3 id="boolean-isEmpty-Object-array"><a href="#boolean-isEmpty-Object-array" class="headerlink" title="boolean isEmpty(Object[] array)"></a>boolean isEmpty(Object[] array)</h3><p>判断数组是否为空。</p><pre><code class="java">ArrayUtils.isEmpty(new String[]{&quot;21&quot;,&quot;是&quot;}); // falseArrayUtils.isEmpty(new String[]{&quot;&quot;}); // falseArrayUtils.isEmpty(new String[]{null}); // falseArrayUtils.isEmpty(new String[]{}); // true</code></pre><h3 id="boolean-isNotEmpty-T-array"><a href="#boolean-isNotEmpty-T-array" class="headerlink" title=" boolean isNotEmpty(T[] array)"></a><t> boolean isNotEmpty(T[] array)</t></h3><p>同<code></code>相反。判断数组是否不为空。</p><h2 id="合并数组元素"><a href="#合并数组元素" class="headerlink" title="合并数组元素"></a>合并数组元素</h2><h3 id="T-addAll-T-array1-T…-array2"><a href="#T-addAll-T-array1-T…-array2" class="headerlink" title=" T[] addAll(T[] array1, T… array2)"></a><t> T[] addAll(T[] array1, T… array2)</t></h3><p>合并多个数组到某一个数组中。</p><pre><code class="java">ArrayUtils.addAll(null, null)     = nullArrayUtils.addAll(array1, null)   = cloned copy of array1ArrayUtils.addAll(null, array2)   = cloned copy of array2ArrayUtils.addAll([], [])         = []ArrayUtils.addAll([null], [null]) = [null, null]ArrayUtils.addAll([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code></pre><h3 id="T-add-T-array-T-element"><a href="#T-add-T-array-T-element" class="headerlink" title=" T[] add(T[] array, T element)"></a><t> T[] add(T[] array, T element)</t></h3><p>将单个元素合并到数组中。</p><pre><code class="java">ArrayUtils.add(null, null)      = IllegalArgumentExceptionArrayUtils.add(null, &quot;a&quot;)       = [&quot;a&quot;]ArrayUtils.add([&quot;a&quot;], null)     = [&quot;a&quot;, null]ArrayUtils.add([&quot;a&quot;], &quot;b&quot;)      = [&quot;a&quot;, &quot;b&quot;]ArrayUtils.add([&quot;a&quot;, &quot;b&quot;], &quot;c&quot;) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><h3 id="T-add-T-array-int-index-T-element"><a href="#T-add-T-array-int-index-T-element" class="headerlink" title=" T[] add(T[] array, int index, T element)"></a><t> T[] add(T[] array, int index, T element)</t></h3><p>将单个元素合并到指定索引位置的数组中。</p><pre><code class="java">ArrayUtils.add(null, 0, null)      = IllegalArgumentExceptionArrayUtils.add(null, 0, &quot;a&quot;)       = [&quot;a&quot;]ArrayUtils.add([&quot;a&quot;], 1, null)     = [&quot;a&quot;, null]ArrayUtils.add([&quot;a&quot;], 0, &quot;b&quot;)      = [&quot;b&quot;, &quot;a&quot;]ArrayUtils.add([&quot;a&quot;, &quot;b&quot;], 1, &quot;c&quot;) = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;]</code></pre><h2 id="移除数组元素"><a href="#移除数组元素" class="headerlink" title="移除数组元素"></a>移除数组元素</h2><h3 id="T-remove-T-array-int-index"><a href="#T-remove-T-array-int-index" class="headerlink" title=" T[] remove(T[] array, int index)"></a><t> T[] remove(T[] array, int index)</t></h3><p>移除数组中指定索引位置的元素。</p><pre><code class="java">ArrayUtils.remove([&quot;a&quot;], 0)           = []ArrayUtils.remove([&quot;a&quot;, &quot;b&quot;], 0)      = [&quot;b&quot;]ArrayUtils.remove([&quot;a&quot;, &quot;b&quot;], 1)      = [&quot;a&quot;]ArrayUtils.remove([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 1) = [&quot;a&quot;, &quot;c&quot;]</code></pre><h3 id="T-removeAll-T-array-int…-indices"><a href="#T-removeAll-T-array-int…-indices" class="headerlink" title=" T[] removeAll(T[] array, int… indices)"></a><t> T[] removeAll(T[] array, int… indices)</t></h3><p>同<code>&lt;T&gt; T[] remove(T[] array, int index)</code>相似，移除数组中所有指定索引位置的元素。</p><pre><code class="java">ArrayUtils.removeAll([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 0, 2) = [&quot;b&quot;]ArrayUtils.removeAll([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 1, 2) = [&quot;a&quot;]</code></pre><h3 id="T-removeElement-T-array-Object-element"><a href="#T-removeElement-T-array-Object-element" class="headerlink" title=" T[] removeElement(T[] array, Object element)"></a><t> T[] removeElement(T[] array, Object element)</t></h3><p>移除数组中的第一个element元素。</p><pre><code class="java">ArrayUtils.removeElement(null, &quot;a&quot;)            = nullArrayUtils.removeElement([], &quot;a&quot;)              = []ArrayUtils.removeElement([&quot;a&quot;], &quot;b&quot;)           = [&quot;a&quot;]ArrayUtils.removeElement([&quot;a&quot;, &quot;b&quot;], &quot;a&quot;)      = [&quot;b&quot;]ArrayUtils.removeElement([&quot;a&quot;, &quot;b&quot;, &quot;a&quot;], &quot;a&quot;) = [&quot;b&quot;, &quot;a&quot;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo博客主题之hexo-theme-matery的介绍</title>
      <link href="/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/"/>
      <url>/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a>设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>每天动态切换<code>Banner</code>图片</li><li>瀑布流式的博客文章列表(文章无特色图片时会有<code>24</code>张漂亮的图片代替)</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>TOC目录</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>和<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>评论模块（推荐使用Gitalk）</li></ul><h2 id="后续开发计划"><a href="#后续开发计划" class="headerlink" title="后续开发计划"></a>后续开发计划</h2><ul><li style="list-style: none"><input type="checkbox" checked> 重构标签页为<strong>可分页</strong></li><li style="list-style: none"><input type="checkbox" checked> 重构归档页为<strong>可分页</strong></li><li style="list-style: none"><input type="checkbox" checked> 增加分类页</li><li style="list-style: none"><input type="checkbox" checked> 增加关于我页面</li><li style="list-style: none"><input type="checkbox"> 美化滚动条</li><li style="list-style: none"><input type="checkbox" checked> 集成<a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a></li><li style="list-style: none"><input type="checkbox" checked> 右上角实现<code>fork me on github</code></li><li style="list-style: none"><input type="checkbox" checked> 添加<code>RSS</code></li><li style="list-style: none"><input type="checkbox" checked> 添加文章<code>TOC</code></li><li><del>网站底部加上访问量等统计功能</del>（主题使用者可以基于谷歌分析、百度统计、LeanCloud等来实现）</li><li style="list-style: none"><input type="checkbox" checked> 首页设计和添加置顶文章</li><li style="list-style: none"><input type="checkbox" checked> 文章结束后增加<strong>打赏</strong>功能</li><li><del>为博客添加萌萌的<strong>宠物</strong>或者<strong>成长树</strong>等</del>（可以使用<a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a>插件来实现）</li></ul><blockquote><p>欢迎贡献!</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>博客了，如果还没有的话，不妨使用 Hexo 和<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a>来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载<code>master</code>分支的最新稳定版的代码，解压缩后，将<code>hexo-theme-matery</code>的文件夹复制到你 Hexo 的<code>themes</code>文件夹中即可。当然你也可以在你的<code>themes</code>文件夹下使用<code>Git clone</code>命令来下载:</p><pre><code class="bash">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的<code>_config.yml</code>的<code>theme</code>的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml文件的其它修改建议"><a href="#config-yml文件的其它修改建议" class="headerlink" title="_config.yml文件的其它修改建议:"></a><code>_config.yml</code>文件的其它修改建议:</h4><ul><li>请修改<code>_config.yml</code>的<code>url</code>的值为你的网站主<code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个<code>per_page</code>的分页条数值为<code>6</code>的倍数，如：<code>12</code>、<code>18</code>等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改<code>language</code>的值为<code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code>页是用来展示所有分类的页面，如果在你的博客<code>source</code>目录下还没有<code>categories/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;categories&quot;</code></pre><p>编辑你刚刚新建的页面文件<code>/source/categories/index.md</code>，至少需要以下内容：</p><pre><code class="yml">title: categoriesdate: 2018-09-30 17:25:30type: &quot;categories&quot;layout: &quot;categories&quot;</code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code>页是用来展示所有标签的页面，如果在你的博客<code>source</code>目录下还没有<code>tags/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;tags&quot;</code></pre><p>编辑你刚刚新建的页面文件<code>/source/tags/index.md</code>，至少需要以下内容：</p><pre><code class="yml">title: tagsdate: 2018-09-30 18:23:38type: &quot;tags&quot;layout: &quot;tags&quot;</code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code>页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客<code>source</code>目录下还没有<code>about/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;about&quot;</code></pre><p>编辑你刚刚新建的页面文件<code>/source/about/index.md</code>，至少需要以下内容：</p><pre><code class="yml">title: aboutdate: 2018-09-30 17:25:30type: &quot;about&quot;layout: &quot;about&quot;</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了<a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a>的 Hexo 插件来做代码高亮，安装命令如下：</p><pre><code class="bash">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下<code>_config.yml</code>文件中<code>highlight.enable</code>的值为<code>false</code>，并新增<code>prism</code>插件相关的配置，主要配置如下：</p><pre><code class="yml">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code class="bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre><code class="yml">search:  path: search.xml  field: post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于<code>SEO</code>，且<code>gitment</code>评论对中文链接也不支持。我们可以用<a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre><code class="bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre><code class="yml">permalink_pinyin:  enable: true  separator: &#39;-&#39; # default: &#39;-&#39;</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a>插件也可以生成非中文的链接。</p></blockquote><h3 id="添加RSS订阅支持（可选的）"><a href="#添加RSS订阅支持（可选的）" class="headerlink" title="添加RSS订阅支持（可选的）"></a>添加RSS订阅支持（可选的）</h3><p>本主题中还使用到了<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>的 Hexo 插件来做<code>RSS</code>，安装命令如下：</p><pre><code class="bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre><code class="yml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code>重新生成博客文件，然后在<code>public</code>文件夹中即可看到<code>atom.xml</code>文件，说明你已经安装成功了。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题文件的<code>/layout/_partial/social-link.ejs</code>文件中，你可以修改或添加你需要的社交链接地址，增加链接可参考如下代码：</p><pre><code class="html">&lt;a href=&quot;https://github.com/blinkfox&quot; class=&quot;tooltipped&quot; target=&quot;_blank&quot; data-tooltip=&quot;访问我的GitHub&quot; data-position=&quot;top&quot; data-delay=&quot;50&quot;&gt;    &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt;</code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a>中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的<code>Font Awesome</code>版本为<code>4.5.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的<code>source/medias/reward</code>文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h2 id="文章Front-matter示例"><a href="#文章Front-matter示例" class="headerlink" title="文章Front-matter示例"></a>文章Front-matter示例</h2><p>以下为文章<code>Front-matter</code>的示例，所有内容均为<strong>非必填</strong>的。但是，仍然建议至少填写<code>title</code>的值，当然最好都填写上这些文章信息。</p><pre><code class="yml">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpg # 或者:http://xxx.com/xxx.jpgtop: true # 如果top值为true，则会是首页推荐文章categories: Markdowntags:  - Typora  - Markdown---</code></pre><blockquote><p><strong>注意</strong>:</p><ol><li>如果<code>img</code>属性不填写的话，文章特色图会根据文章标题的<code>hashcode</code>的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code>的值尽量保证每篇文章是唯一的，因为本主题中<code>Gitment</code>识别<code>id</code>是通过<code>date</code>的值来作为唯一标识的。</li></ol></blockquote><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="http://static.blinkfox.com/hexo-matery-index1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/hexo-matery-index2.png" alt="首页文章列表"></p><h3 id="文章页"><a href="#文章页" class="headerlink" title="文章页"></a>文章页</h3><p><img src="http://static.blinkfox.com/hexo-matery-post1.png" alt="文章"></p><p><img src="http://static.blinkfox.com/hexo-matery-post2.png" alt="文章后续内容"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的<code>_config.yml</code>中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>首页的励志名言</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC目录</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>和<code>disqus</code>评论配置</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的<code>hashcode</code>值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的<code>_config.yml</code>中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的<code>/source/css/matery.css</code>文件中，搜索<code>.bg-color</code>来修改背景颜色：</p><pre><code class="css">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color {    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}/* 和背景颜色相同的文字颜色，目前仅在首页一个地方使用到，你也可以将此样式应用到其他地方. */.text-color {    color: #0f9d58 !important;}@-webkit-keyframes rainbow {   /* 动态切换背景颜色. */}@keyframes rainbow {    /* 动态切换背景颜色. */}</code></pre><h3 id="修改banner图和文章特色图"><a href="#修改banner图和文章特色图" class="headerlink" title="修改banner图和文章特色图"></a>修改banner图和文章特色图</h3><p>你可以直接在<code>/source/medias/banner</code>文件夹中更换你喜欢的<code>banner</code>图片，主题代码中是每天动态切换一张，只需<code>7</code>张即可。如果你会<code>JavaScript</code>代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code>切换的代码位置在<code>/layout/_partial/bg-cover.ejs</code>文件的<code>&lt;script&gt;&lt;/script&gt;</code>代码中：</p><pre><code class="javascript">$(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(/medias/banner/&#39; + new Date().getDay() + &#39;.jpg)&#39;);</code></pre><p>在<code>/source/medias/featureimages</code>文件夹中默认有24张特色图片，你可以再增加或者减少，并需要在<code>_config.yml</code>做同步修改。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Lang之StringUtils</title>
      <link href="/2018/09/27/hou-duan/java/commons/apache-commons-lang-zhi-stringutils/"/>
      <url>/2018/09/27/hou-duan/java/commons/apache-commons-lang-zhi-stringutils/</url>
      
        <content type="html"><![CDATA[<blockquote><p>码农不识Apache，码尽一生也枉然。</p></blockquote><h2 id="判断空字符串"><a href="#判断空字符串" class="headerlink" title="判断空字符串"></a>判断空字符串</h2><h3 id="isEmpty-CharSequence-cs"><a href="#isEmpty-CharSequence-cs" class="headerlink" title="isEmpty(CharSequence cs)"></a>isEmpty(CharSequence cs)</h3><p>判断是否是空字符串，代码示例：</p><pre><code class="java">StringUtils.isEmpty(null)      = trueStringUtils.isEmpty(&quot;&quot;)        = trueStringUtils.isEmpty(&quot; &quot;)       = falseStringUtils.isEmpty(&quot;bob&quot;)     = falseStringUtils.isEmpty(&quot;  bob  &quot;) = false</code></pre><h3 id="isNotEmpty-CharSequence-cs"><a href="#isNotEmpty-CharSequence-cs" class="headerlink" title="isNotEmpty(CharSequence cs)"></a>isNotEmpty(CharSequence cs)</h3><p>判断是否不是空字符串，与<code>isEmpty(CharSequence cs)</code>相反。</p><h3 id="isAnyEmpty-CharSequence…-css"><a href="#isAnyEmpty-CharSequence…-css" class="headerlink" title="isAnyEmpty(CharSequence… css)"></a>isAnyEmpty(CharSequence… css)</h3><p>判断是否含有空字符串，代码示例：</p><pre><code class="java">StringUtils.isAnyEmpty(null)             = trueStringUtils.isAnyEmpty(null, &quot;foo&quot;)      = trueStringUtils.isAnyEmpty(&quot;&quot;, &quot;bar&quot;)        = trueStringUtils.isAnyEmpty(&quot;bob&quot;, &quot;&quot;)        = trueStringUtils.isAnyEmpty(&quot;  bob  &quot;, null)  = trueStringUtils.isAnyEmpty(&quot; &quot;, &quot;bar&quot;)       = falseStringUtils.isAnyEmpty(&quot;foo&quot;, &quot;bar&quot;)     = false</code></pre><h3 id="isNoneEmpty-CharSequence…-css"><a href="#isNoneEmpty-CharSequence…-css" class="headerlink" title="isNoneEmpty(CharSequence… css)"></a>isNoneEmpty(CharSequence… css)</h3><p>判断是否都不是空字符串，与<code>isAnyEmpty(CharSequence... css)</code>相反。</p><h3 id="isAllEmpty-CharSequence…-css"><a href="#isAllEmpty-CharSequence…-css" class="headerlink" title="isAllEmpty(CharSequence… css)"></a>isAllEmpty(CharSequence… css)</h3><p>判断是否都是空字符串，代码示例：</p><pre><code class="java">StringUtils.isAllEmpty(null)             = trueStringUtils.isAllEmpty(null, &quot;&quot;)         = trueStringUtils.isAllEmpty(new String[] {})  = trueStringUtils.isAllEmpty(null, &quot;foo&quot;)      = falseStringUtils.isAllEmpty(&quot;&quot;, &quot;bar&quot;)        = falseStringUtils.isAllEmpty(&quot;bob&quot;, &quot;&quot;)        = falseStringUtils.isAllEmpty(&quot;  bob  &quot;, null)  = falseStringUtils.isAllEmpty(&quot; &quot;, &quot;bar&quot;)       = falseStringUtils.isAllEmpty(&quot;foo&quot;, &quot;bar&quot;)     = false</code></pre><h3 id="isBlank-CharSequence-cs"><a href="#isBlank-CharSequence-cs" class="headerlink" title="isBlank(CharSequence cs)"></a>isBlank(CharSequence cs)</h3><p>判断是否是“大空字符串”，代码示例：</p><pre><code class="java">StringUtils.isBlank(null)      = trueStringUtils.isBlank(&quot;&quot;)        = trueStringUtils.isBlank(&quot; &quot;)       = trueStringUtils.isBlank(&quot;bob&quot;)     = falseStringUtils.isBlank(&quot;  bob  &quot;) = false</code></pre><h3 id="isNotBlank-CharSequence-cs"><a href="#isNotBlank-CharSequence-cs" class="headerlink" title="isNotBlank(CharSequence cs)"></a>isNotBlank(CharSequence cs)</h3><p>判断是否不是“大空字符串”，与<code>isBlank(CharSequence cs)</code>相反，与<code>isNotEmpty(CharSequence cs)</code>相似。</p><h3 id="isAnyBlank-CharSequence…-css"><a href="#isAnyBlank-CharSequence…-css" class="headerlink" title="isAnyBlank(CharSequence… css)"></a>isAnyBlank(CharSequence… css)</h3><p>判断是否有“大空字符串”，与<code>isAnyEmpty(CharSequence... css)</code>相似。</p><h3 id="isNoneBlank-CharSequence…-css"><a href="#isNoneBlank-CharSequence…-css" class="headerlink" title="isNoneBlank(CharSequence… css)"></a>isNoneBlank(CharSequence… css)</h3><p>判断是否都不是“大空字符串”，与<code>isAnyBlank(CharSequence... css)</code>相反，与<code>isNoneEmpty(CharSequence... css)</code>相似。</p><h3 id="isAllBlank-CharSequence…-css"><a href="#isAllBlank-CharSequence…-css" class="headerlink" title="isAllBlank(CharSequence… css)"></a>isAllBlank(CharSequence… css)</h3><p>判断是否都是“大空字符串”，与<code>isAllEmpty(CharSequence... css)</code>相似。</p><h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><h3 id="trim-String-str"><a href="#trim-String-str" class="headerlink" title="trim(String str)"></a>trim(String str)</h3><p>去除字符串前后的控制符，代码示例：</p><pre><code class="java">StringUtils.trim(null)          = nullStringUtils.trim(&quot;&quot;)            = &quot;&quot;StringUtils.trim(&quot;     &quot;)       = &quot;&quot;StringUtils.trim(&quot;abc&quot;)         = &quot;abc&quot;StringUtils.trim(&quot;    abc    &quot;) = &quot;abc&quot;</code></pre><h3 id="trimToNull-String-str"><a href="#trimToNull-String-str" class="headerlink" title="trimToNull(String str)"></a>trimToNull(String str)</h3><p>去除字符串前后的控制符，如何是空字符串则转为<code>null</code>，代码示例：</p><pre><code class="java">StringUtils.trimToNull(null)          = nullStringUtils.trimToNull(&quot;&quot;)            = nullStringUtils.trimToNull(&quot;     &quot;)       = nullStringUtils.trimToNull(&quot;abc&quot;)         = &quot;abc&quot;StringUtils.trimToNull(&quot;    abc    &quot;) = &quot;abc&quot;</code></pre><h3 id="trimToEmpty-String-str"><a href="#trimToEmpty-String-str" class="headerlink" title="trimToEmpty(String str)"></a>trimToEmpty(String str)</h3><p>去除字符串前后的控制符，如何是<code>null</code>则转为空字符串，代码示例：</p><pre><code class="java">StringUtils.trimToEmpty(null)          = &quot;&quot;StringUtils.trimToEmpty(&quot;&quot;)            = &quot;&quot;StringUtils.trimToEmpty(&quot;     &quot;)       = &quot;&quot;StringUtils.trimToEmpty(&quot;abc&quot;)         = &quot;abc&quot;StringUtils.trimToEmpty(&quot;    abc    &quot;) = &quot;abc&quot;</code></pre><h3 id="truncate-String-str-int-maxWidth"><a href="#truncate-String-str-int-maxWidth" class="headerlink" title="truncate(String str, int maxWidth)"></a>truncate(String str, int maxWidth)</h3><p>截断字符串，具有以下特点：</p><ul><li>如果str字符串的长度小于maxWidth，则直接返回str。</li><li>不满足第一条时，则为<code>substring(str, 0, maxWidth)</code>。</li><li>如果maxWidth小于0，则抛出IllegalArgumentException。</li><li>在任何情况下都不会返回长度大于maxWidth的字符串。</li></ul><p>代码示例：</p><pre><code class="java">StringUtils.truncate(null, 0)       = nullStringUtils.truncate(null, 2)       = nullStringUtils.truncate(&quot;&quot;, 4)         = &quot;&quot;StringUtils.truncate(&quot;abcdefg&quot;, 4)  = &quot;abcd&quot;StringUtils.truncate(&quot;abcdefg&quot;, 6)  = &quot;abcdef&quot;StringUtils.truncate(&quot;abcdefg&quot;, 7)  = &quot;abcdefg&quot;StringUtils.truncate(&quot;abcdefg&quot;, 8)  = &quot;abcdefg&quot;StringUtils.truncate(&quot;abcdefg&quot;, -1) = throws an IllegalArgumentException</code></pre><h3 id="truncate-String-str-int-offset-int-maxWidth"><a href="#truncate-String-str-int-offset-int-maxWidth" class="headerlink" title="truncate(String str, int offset, int maxWidth)"></a>truncate(String str, int offset, int maxWidth)</h3><p>截断字符串，具有以下特点：</p><ul><li>如果str字符串的长度小于maxWidth，则直接返回str。</li><li>不满足第一条时，则为<code>substring(str, offset, maxWidth)</code>。</li><li>如果maxWidth或者offset小于0，则抛出IllegalArgumentException。</li><li>在任何情况下都不会返回长度大于maxWidth的字符串。</li></ul><p>代码示例：</p><pre><code class="java">StringUtils.truncate(null, 0, 0) = nullStringUtils.truncate(null, 2, 4) = nullStringUtils.truncate(&quot;&quot;, 0, 10) = &quot;&quot;StringUtils.truncate(&quot;&quot;, 2, 10) = &quot;&quot;StringUtils.truncate(&quot;abcdefghij&quot;, 0, 3) = &quot;abc&quot;StringUtils.truncate(&quot;abcdefghij&quot;, 5, 6) = &quot;fghij&quot;StringUtils.truncate(&quot;raspberry peach&quot;, 10, 15) = &quot;peach&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 0, 10) = &quot;abcdefghij&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, -1, 10) = throws an IllegalArgumentExceptionStringUtils.truncate(&quot;abcdefghijklmno&quot;, Integer.MIN_VALUE, 10) = &quot;abcdefghij&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, Integer.MIN_VALUE, Integer.MAX_VALUE) = &quot;abcdefghijklmno&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 0, Integer.MAX_VALUE) = &quot;abcdefghijklmno&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 1, 10) = &quot;bcdefghijk&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 2, 10) = &quot;cdefghijkl&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 3, 10) = &quot;defghijklm&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 4, 10) = &quot;efghijklmn&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 5, 10) = &quot;fghijklmno&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 5, 5) = &quot;fghij&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 5, 3) = &quot;fgh&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 10, 3) = &quot;klm&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 10, Integer.MAX_VALUE) = &quot;klmno&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 13, 1) = &quot;n&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 13, Integer.MAX_VALUE) = &quot;no&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 14, 1) = &quot;o&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 14, Integer.MAX_VALUE) = &quot;o&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 15, 1) = &quot;&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, 15, Integer.MAX_VALUE) = &quot;&quot;StringUtils.truncate(&quot;abcdefghijklmno&quot;, Integer.MAX_VALUE, Integer.MAX_VALUE) = &quot;&quot;StringUtils.truncate(&quot;abcdefghij&quot;, 3, -1) = throws an IllegalArgumentExceptionStringUtils.truncate(&quot;abcdefghij&quot;, -2, 4) = throws an IllegalArgumentException</code></pre><h3 id="left-String-str-int-len"><a href="#left-String-str-int-len" class="headerlink" title="left(String str, int len)"></a>left(String str, int len)</h3><p>得到一个字符串最左边的len个字符</p><pre><code class="java">StringUtils.left(&quot;abc&quot;, 0)   = &quot;&quot;StringUtils.left(&quot;abc&quot;, 2)   = &quot;ab&quot;StringUtils.left(&quot;abc&quot;, 4)   = &quot;abc&quot;</code></pre><h3 id="right-String-str-int-len"><a href="#right-String-str-int-len" class="headerlink" title="right(String str, int len)"></a>right(String str, int len)</h3><p>同<code>left(String str, int len)</code>相反，从右边截取len个字符。</p><h3 id="mid-String-str-int-pos-int-len"><a href="#mid-String-str-int-pos-int-len" class="headerlink" title="mid(String str, int pos, int len)"></a>mid(String str, int pos, int len)</h3><p>得到一个字符串中间的len个字符。</p><pre><code class="java">StringUtils.mid(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;StringUtils.mid(&quot;abc&quot;, 0, 4)   = &quot;abc&quot;StringUtils.mid(&quot;abc&quot;, 2, 4)   = &quot;c&quot;StringUtils.mid(&quot;abc&quot;, 4, 2)   = &quot;&quot;StringUtils.mid(&quot;abc&quot;, -2, 2)  = &quot;ab&quot;</code></pre><h3 id="substringBefore-String-str-String-separator"><a href="#substringBefore-String-str-String-separator" class="headerlink" title="substringBefore(String str, String separator)"></a>substringBefore(String str, String separator)</h3><p>得到一个字符串第一个分隔符字符串之前的字符串。</p><pre><code class="java">StringUtils.substringBefore(&quot;abc&quot;, &quot;a&quot;)   = &quot;&quot;StringUtils.substringBefore(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;StringUtils.substringBefore(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;StringUtils.substringBefore(&quot;abc&quot;, &quot;d&quot;)   = &quot;abc&quot;StringUtils.substringBefore(&quot;abc&quot;, &quot;&quot;)    = &quot;&quot;StringUtils.substringBefore(&quot;abc&quot;, null)  = &quot;abc&quot;</code></pre><h3 id="substringAfter-String-str-String-separator"><a href="#substringAfter-String-str-String-separator" class="headerlink" title="substringAfter(String str, String separator)"></a>substringAfter(String str, String separator)</h3><p>同<code>substringBefore(String str, String separator)</code>相反。得到一个字符串第一个分隔符字符串之后的字符串。</p><h3 id="substringBetween-String-str-String-open-String-close"><a href="#substringBetween-String-str-String-open-String-close" class="headerlink" title="substringBetween(String str, String open, String close)"></a>substringBetween(String str, String open, String close)</h3><p>得到一个字符串两个字符串之间字符串。</p><pre><code class="java">StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;&quot;)          = &quot;&quot;StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;]&quot;)         = nullStringUtils.substringBetween(&quot;&quot;, &quot;[&quot;, &quot;]&quot;)        = nullStringUtils.substringBetween(&quot;yabcz&quot;, &quot;&quot;, &quot;&quot;)     = &quot;&quot;StringUtils.substringBetween(&quot;yabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;StringUtils.substringBetween(&quot;yabczyabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;</code></pre><h3 id="substringBetween-String-str-String-tag"><a href="#substringBetween-String-str-String-tag" class="headerlink" title="substringBetween(String str, String tag)"></a>substringBetween(String str, String tag)</h3><p>是<code>substringBetween(String str, String open, String close)</code>的特殊情形。得到一个字符串中同一个字符串之间的字符串。</p><h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><h3 id="equals-CharSequence-cs1-CharSequence-cs2"><a href="#equals-CharSequence-cs1-CharSequence-cs2" class="headerlink" title="equals(CharSequence cs1, CharSequence cs2)"></a>equals(CharSequence cs1, CharSequence cs2)</h3><p>判断两字符串相等，代码示例：</p><pre><code class="java">StringUtils.equals(null, null)   = trueStringUtils.equals(null, &quot;abc&quot;)  = falseStringUtils.equals(&quot;abc&quot;, null)  = falseStringUtils.equals(&quot;abc&quot;, &quot;abc&quot;) = trueStringUtils.equals(&quot;abc&quot;, &quot;ABC&quot;) = false</code></pre><h3 id="equalsIgnoreCase-CharSequence-str1-CharSequence-str2"><a href="#equalsIgnoreCase-CharSequence-str1-CharSequence-str2" class="headerlink" title="equalsIgnoreCase(CharSequence str1, CharSequence str2)"></a>equalsIgnoreCase(CharSequence str1, CharSequence str2)</h3><p>判断两字符串相等，忽略大小写，代码示例：</p><pre><code class="java">StringUtils.equalsIgnoreCase(null, null)   = trueStringUtils.equalsIgnoreCase(null, &quot;abc&quot;)  = falseStringUtils.equalsIgnoreCase(&quot;abc&quot;, null)  = falseStringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;abc&quot;) = trueStringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;) = true</code></pre><h3 id="equalsAny-CharSequence-string-CharSequence…-searchStrings"><a href="#equalsAny-CharSequence-string-CharSequence…-searchStrings" class="headerlink" title="equalsAny(CharSequence string, CharSequence… searchStrings)"></a>equalsAny(CharSequence string, CharSequence… searchStrings)</h3><p>比较一个字符串是否与其后的某个字符串相等，代码示例：</p><pre><code class="java">StringUtils.equalsAny(null, (CharSequence[]) null) = falseStringUtils.equalsAny(null, null, null)    = trueStringUtils.equalsAny(null, &quot;abc&quot;, &quot;def&quot;)  = falseStringUtils.equalsAny(&quot;abc&quot;, null, &quot;def&quot;)  = falseStringUtils.equalsAny(&quot;abc&quot;, &quot;abc&quot;, &quot;def&quot;) = trueStringUtils.equalsAny(&quot;abc&quot;, &quot;ABC&quot;, &quot;DEF&quot;) = false</code></pre><h3 id="equalsAnyIgnoreCase-CharSequence-string-CharSequence…searchStrings"><a href="#equalsAnyIgnoreCase-CharSequence-string-CharSequence…searchStrings" class="headerlink" title="equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)"></a>equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)</h3><p>比较一个字符串是否与其后的某个字符串相等，忽略大小写，代码示例：</p><pre><code class="java">StringUtils.equalsAnyIgnoreCase(null, (CharSequence[]) null) = falseStringUtils.equalsAnyIgnoreCase(null, null, null)    = trueStringUtils.equalsAnyIgnoreCase(null, &quot;abc&quot;, &quot;def&quot;)  = falseStringUtils.equalsAnyIgnoreCase(&quot;abc&quot;, null, &quot;def&quot;)  = falseStringUtils.equalsAnyIgnoreCase(&quot;abc&quot;, &quot;abc&quot;, &quot;def&quot;) = trueStringUtils.equalsAnyIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;, &quot;DEF&quot;) = true</code></pre><h3 id="compare-String-str1-String-str2"><a href="#compare-String-str1-String-str2" class="headerlink" title="compare(String str1, String str2)"></a>compare(String str1, String str2)</h3><p>比较两字符串的大小，代码示例：</p><pre><code class="java">StringUtils.compare(null, null)   = 0StringUtils.compare(null , &quot;a&quot;)   &lt; 0StringUtils.compare(&quot;a&quot;, null)    &gt; 0StringUtils.compare(&quot;abc&quot;, &quot;abc&quot;) = 0StringUtils.compare(&quot;a&quot;, &quot;b&quot;)     &lt; 0StringUtils.compare(&quot;b&quot;, &quot;a&quot;)     &gt; 0StringUtils.compare(&quot;a&quot;, &quot;B&quot;)     &gt; 0StringUtils.compare(&quot;ab&quot;, &quot;abc&quot;)  &lt; 0</code></pre><h3 id="compareIgnoreCase-String-str1-String-str2"><a href="#compareIgnoreCase-String-str1-String-str2" class="headerlink" title="compareIgnoreCase(String str1, String str2)"></a>compareIgnoreCase(String str1, String str2)</h3><p>比较两字符串的大小，忽略大小写，代码示例：</p><pre><code class="java">StringUtils.compareIgnoreCase(null, null)   = 0StringUtils.compareIgnoreCase(null , &quot;a&quot;)   &lt; 0StringUtils.compareIgnoreCase(&quot;a&quot;, null)    &gt; 0StringUtils.compareIgnoreCase(&quot;abc&quot;, &quot;abc&quot;) = 0StringUtils.compareIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;) = 0StringUtils.compareIgnoreCase(&quot;a&quot;, &quot;b&quot;)     &lt; 0StringUtils.compareIgnoreCase(&quot;b&quot;, &quot;a&quot;)     &gt; 0StringUtils.compareIgnoreCase(&quot;a&quot;, &quot;B&quot;)     &lt; 0StringUtils.compareIgnoreCase(&quot;A&quot;, &quot;b&quot;)     &lt; 0StringUtils.compareIgnoreCase(&quot;ab&quot;, &quot;ABC&quot;)  &lt; 0</code></pre><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><h3 id="indexOf-CharSequence-seq-int-searchChar"><a href="#indexOf-CharSequence-seq-int-searchChar" class="headerlink" title="indexOf(CharSequence seq, int searchChar)"></a>indexOf(CharSequence seq, int searchChar)</h3><p>查找某个字符在字符串中第一次出现时的索引位置，代码示例：</p><pre><code class="java">StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;a&#39;) = 0StringUtils.indexOf(&quot;aabaabaa&quot;, &#39;b&#39;) = 2</code></pre><h3 id="indexOf-CharSequence-seq-CharSequence-searchSeq"><a href="#indexOf-CharSequence-seq-CharSequence-searchSeq" class="headerlink" title="indexOf(CharSequence seq, CharSequence searchSeq)"></a>indexOf(CharSequence seq, CharSequence searchSeq)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似。</p><pre><code class="java">StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;c&quot;)  = -1StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;a&quot;)  = 0StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;)  = 2StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;ab&quot;) = 1StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;&quot;)   = 0</code></pre><h3 id="indexOf-final-CharSequence-seq-final-CharSequence-searchSeq-final-int-startPos"><a href="#indexOf-final-CharSequence-seq-final-CharSequence-searchSeq-final-int-startPos" class="headerlink" title="indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)"></a>indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似。</p><pre><code class="java">StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 0)  = 0StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 0)  = 2StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 0) = 1StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 3)  = 5StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 9)  = -1StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, -1) = 2StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 2StringUtils.indexOf(&quot;abc&quot;, &quot;&quot;, 9)        = 3</code></pre><h3 id="indexOfIgnoreCase-CharSequence-str-CharSequence-searchStr"><a href="#indexOfIgnoreCase-CharSequence-str-CharSequence-searchStr" class="headerlink" title="indexOfIgnoreCase(CharSequence str, CharSequence searchStr)"></a>indexOfIgnoreCase(CharSequence str, CharSequence searchStr)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似,忽略大小写。</p><h3 id="lastIndexOf-CharSequence-seq-int-searchChar"><a href="#lastIndexOf-CharSequence-seq-int-searchChar" class="headerlink" title="lastIndexOf(CharSequence seq, int searchChar)"></a>lastIndexOf(CharSequence seq, int searchChar)</h3><p>同<code>indexOf(CharSequence seq, int searchChar)</code>相似，从后面开始查找。</p><h3 id="contains-CharSequence-seq-CharSequence-searchSeq"><a href="#contains-CharSequence-seq-CharSequence-searchSeq" class="headerlink" title="contains(CharSequence seq, CharSequence searchSeq)"></a>contains(CharSequence seq, CharSequence searchSeq)</h3><p>判断某字符串是否包含某子字符串。</p><pre><code class="java">StringUtils.contains(&quot;&quot;, &quot;&quot;)      = trueStringUtils.contains(&quot;abc&quot;, &quot;&quot;)   = trueStringUtils.contains(&quot;abc&quot;, &quot;a&quot;)  = trueStringUtils.contains(&quot;abc&quot;, &quot;z&quot;)  = false</code></pre><h3 id="containsIgnoreCase-CharSequence-str-CharSequence-searchStr"><a href="#containsIgnoreCase-CharSequence-str-CharSequence-searchStr" class="headerlink" title="containsIgnoreCase(CharSequence str, CharSequence searchStr)"></a>containsIgnoreCase(CharSequence str, CharSequence searchStr)</h3><p>同<code>contains(CharSequence seq, CharSequence searchSeq)</code>相似，忽略大小写。</p><h3 id="containsWhitespace-final-CharSequence-seq"><a href="#containsWhitespace-final-CharSequence-seq" class="headerlink" title="containsWhitespace(final CharSequence seq)"></a>containsWhitespace(final CharSequence seq)</h3><p>是<code>contains(CharSequence seq, CharSequence searchSeq)</code>的特殊情形，判断是否包含空白字符。</p><h3 id="containsAny-CharSequence-cs-CharSequence…-searchCharSequences"><a href="#containsAny-CharSequence-cs-CharSequence…-searchCharSequences" class="headerlink" title="containsAny(CharSequence cs, CharSequence… searchCharSequences)"></a>containsAny(CharSequence cs, CharSequence… searchCharSequences)</h3><p>判断某字符串是否包含其后的任意一个字符串。</p><pre><code class="java">StringUtils.containsAny(&quot;abcd&quot;, &quot;ab&quot;, null) = trueStringUtils.containsAny(&quot;abcd&quot;, &quot;ab&quot;, &quot;cd&quot;) = trueStringUtils.containsAny(&quot;abc&quot;, &quot;d&quot;, &quot;abc&quot;)  = true</code></pre><h3 id="containsNone-CharSequence-cs-String-invalidChars"><a href="#containsNone-CharSequence-cs-String-invalidChars" class="headerlink" title="containsNone(CharSequence cs, String invalidChars)"></a>containsNone(CharSequence cs, String invalidChars)</h3><p>判断某字符串是否不含其后字符串的任意一个字符。</p><pre><code class="java">StringUtils.containsNone(&quot;ab&quot;, &quot;&quot;)      = trueStringUtils.containsNone(&quot;abab&quot;, &quot;xyz&quot;) = trueStringUtils.containsNone(&quot;ab1&quot;, &quot;xyz&quot;)  = trueStringUtils.containsNone(&quot;abz&quot;, &quot;xyz&quot;)  = false</code></pre><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><h3 id="split-String-str-String-separatorChars"><a href="#split-String-str-String-separatorChars" class="headerlink" title="split(String str, String separatorChars)"></a>split(String str, String separatorChars)</h3><p>将某字符串按字符分割成数组，默认按空格分组。</p><pre><code class="java">StringUtils.split(&quot;abc def&quot;, null) = [&quot;abc&quot;, &quot;def&quot;]StringUtils.split(&quot;abc def&quot;, &quot; &quot;)  = [&quot;abc&quot;, &quot;def&quot;]StringUtils.split(&quot;abc  def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;]StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]</code></pre><h3 id="split-String-str-String-separatorChars-int-max"><a href="#split-String-str-String-separatorChars-int-max" class="headerlink" title="split(String str, String separatorChars, int max)"></a>split(String str, String separatorChars, int max)</h3><p>将某字符串按字符分割成最大max长度的数组，默认按空格分组。</p><pre><code class="java">StringUtils.split(&quot;ab cd ef&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]StringUtils.split(&quot;ab   cd ef&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]</code></pre><h3 id="splitByCharacterType-final-String-str"><a href="#splitByCharacterType-final-String-str" class="headerlink" title="splitByCharacterType(final String str)"></a>splitByCharacterType(final String str)</h3><p>按字符串类型划分字符串为数组。</p><pre><code class="java">StringUtils.splitByCharacterType(null)         = nullStringUtils.splitByCharacterType(&quot;&quot;)           = []StringUtils.splitByCharacterType(&quot;ab de fg&quot;)   = [&quot;ab&quot;, &quot; &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]StringUtils.splitByCharacterType(&quot;ab   de fg&quot;) = [&quot;ab&quot;, &quot;   &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]StringUtils.splitByCharacterType(&quot;ab:cd:ef&quot;)   = [&quot;ab&quot;, &quot;:&quot;, &quot;cd&quot;, &quot;:&quot;, &quot;ef&quot;]StringUtils.splitByCharacterType(&quot;number5&quot;)    = [&quot;number&quot;, &quot;5&quot;]StringUtils.splitByCharacterType(&quot;fooBar&quot;)     = [&quot;foo&quot;, &quot;B&quot;, &quot;ar&quot;]StringUtils.splitByCharacterType(&quot;foo200Bar&quot;)  = [&quot;foo&quot;, &quot;200&quot;, &quot;B&quot;, &quot;ar&quot;]StringUtils.splitByCharacterType(&quot;ASFRules&quot;)   = [&quot;ASFR&quot;, &quot;ules&quot;]</code></pre><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><h3 id="join-T…-elements"><a href="#join-T…-elements" class="headerlink" title="join(T… elements)"></a>join(T… elements)</h3><p>无连接符连接字符串。</p><pre><code class="java">StringUtils.join(null)            = nullStringUtils.join([])              = &quot;&quot;StringUtils.join([null])          = &quot;&quot;StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;</code></pre><h3 id="join-Object-array-String-separator"><a href="#join-Object-array-String-separator" class="headerlink" title="join(Object[] array, String separator)"></a>join(Object[] array, String separator)</h3><p>将提供的数组按连接符连成字符串。</p><pre><code class="java">StringUtils.join(null, *)               = nullStringUtils.join([], *)                 = &quot;&quot;StringUtils.join([null], *)             = &quot;&quot;StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &#39;;&#39;)  = &quot;a;b;c&quot;StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;StringUtils.join([null, &quot;&quot;, &quot;a&quot;], &#39;;&#39;)  = &quot;;;a&quot;</code></pre><h2 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h2><h3 id="deleteWhitespace-String-str"><a href="#deleteWhitespace-String-str" class="headerlink" title="deleteWhitespace(String str)"></a>deleteWhitespace(String str)</h3><p>删除空白字符。</p><pre><code class="java">StringUtils.deleteWhitespace(null)         = nullStringUtils.deleteWhitespace(&quot;&quot;)           = &quot;&quot;StringUtils.deleteWhitespace(&quot;abc&quot;)        = &quot;abc&quot;StringUtils.deleteWhitespace(&quot;   ab  c  &quot;) = &quot;abc&quot;</code></pre><h3 id="removeStart-String-str-String-remove"><a href="#removeStart-String-str-String-remove" class="headerlink" title="removeStart(String str, String remove)"></a>removeStart(String str, String remove)</h3><p>删除指定字符串前缀的字符串。</p><pre><code class="java">StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;StringUtils.removeStart(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;StringUtils.removeStart(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;</code></pre><h3 id="removeStartIgnoreCase-String-str-String-remove"><a href="#removeStartIgnoreCase-String-str-String-remove" class="headerlink" title="removeStartIgnoreCase(String str, String remove)"></a>removeStartIgnoreCase(String str, String remove)</h3><p>同<code>removeStart(String str, String remove)</code>相似，忽略大小写。</p><h3 id="removeEnd-String-str-String-remove"><a href="#removeEnd-String-str-String-remove" class="headerlink" title="removeEnd(String str, String remove)"></a>removeEnd(String str, String remove)</h3><p>同<code>removeStart(String str, String remove)</code>相反。</p><h3 id="removeEndIgnoreCase-String-str-String-remove"><a href="#removeEndIgnoreCase-String-str-String-remove" class="headerlink" title="removeEndIgnoreCase(String str, String remove)"></a>removeEndIgnoreCase(String str, String remove)</h3><p>同<code>removeEnd(String str, String remove)</code>相似，忽略大小写。</p><h3 id="remove-String-str-String-remove"><a href="#remove-String-str-String-remove" class="headerlink" title="remove(String str, String remove)"></a>remove(String str, String remove)</h3><p>移除字符串中指定的字符串。</p><pre><code class="java">StringUtils.remove(&quot;queued&quot;, &quot;ue&quot;) = &quot;qd&quot;StringUtils.remove(&quot;queued&quot;, &quot;zz&quot;) = &quot;queued&quot;</code></pre><h3 id="removeIgnoreCase-String-str-String-remove"><a href="#removeIgnoreCase-String-str-String-remove" class="headerlink" title="removeIgnoreCase(String str, String remove)"></a>removeIgnoreCase(String str, String remove)</h3><p>同<code>remove(String str, String remove)</code>相似，忽略大小写。</p><h2 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h2><h3 id="replace-String-text-String-searchString-String-replacement"><a href="#replace-String-text-String-searchString-String-replacement" class="headerlink" title="replace(String text, String searchString, String replacement)"></a>replace(String text, String searchString, String replacement)</h3><p>替换某字符串为另一个字符串。</p><pre><code class="java">StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;b&quot;StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zbz&quot;</code></pre><h3 id="replaceIgnoreCase-String-text-String-searchString-String-replacement"><a href="#replaceIgnoreCase-String-text-String-searchString-String-replacement" class="headerlink" title="replaceIgnoreCase(String text, String searchString, String replacement)"></a>replaceIgnoreCase(String text, String searchString, String replacement)</h3><p>同<code>replace(String text, String searchString, String replacement)</code>相似，忽略大小写。</p><h3 id="replace-String-text-String-searchString-String-replacement-int-max"><a href="#replace-String-text-String-searchString-String-replacement-int-max" class="headerlink" title="replace(String text, String searchString, String replacement, int max)"></a>replace(String text, String searchString, String replacement, int max)</h3><p>替换某字符串为另一个字符串,从左到右替换最大max次。</p><pre><code class="java">StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, null, -1) = &quot;abaa&quot;StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;&quot;, -1)   = &quot;b&quot;StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 0)   = &quot;abaa&quot;StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 1)   = &quot;zbaa&quot;StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 2)   = &quot;zbza&quot;StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, -1)  = &quot;zbzz&quot;</code></pre><h3 id="replaceEach-String-text-String-searchList-String-replacementList"><a href="#replaceEach-String-text-String-searchList-String-replacementList" class="headerlink" title="replaceEach(String text, String[] searchList, String[] replacementList)"></a>replaceEach(String text, String[] searchList, String[] replacementList)</h3><p>替换某些字符串为另一些字符串。</p><pre><code class="java">StringUtils.replaceEach(&quot;aba&quot;, null, null) = &quot;aba&quot;StringUtils.replaceEach(&quot;aba&quot;, new String[0], null) = &quot;aba&quot;StringUtils.replaceEach(&quot;aba&quot;, null, new String[0]) = &quot;aba&quot;StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null)  = &quot;aba&quot;StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;})  = &quot;b&quot;StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;})  = &quot;aba&quot;StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;})  = &quot;wcte&quot;StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;})  = &quot;dcte&quot;</code></pre><h2 id="填充字符串"><a href="#填充字符串" class="headerlink" title="填充字符串"></a>填充字符串</h2><h3 id="repeat-final-String-str-final-int-repeat"><a href="#repeat-final-String-str-final-int-repeat" class="headerlink" title="repeat(final String str, final int repeat)"></a>repeat(final String str, final int repeat)</h3><p>生成重复的字符串，repeat代表生成次数。</p><pre><code class="java">StringUtils.repeat(null, 2) = nullStringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;</code></pre><h3 id="repeat-String-str-String-separator-int-repeat"><a href="#repeat-String-str-String-separator-int-repeat" class="headerlink" title="repeat(String str, String separator, int repeat)"></a>repeat(String str, String separator, int repeat)</h3><p>生成重复的字符串，repeat代表生成次数。</p><pre><code class="java">StringUtils.repeat(null, null, 2) = nullStringUtils.repeat(null, &quot;x&quot;, 2)  = nullStringUtils.repeat(&quot;&quot;, null, 0)   = &quot;&quot;StringUtils.repeat(&quot;&quot;, &quot;&quot;, 2)     = &quot;&quot;StringUtils.repeat(&quot;&quot;, &quot;x&quot;, 3)    = &quot;xxx&quot;StringUtils.repeat(&quot;?&quot;, &quot;, &quot;, 3)  = &quot;?, ?, ?&quot;</code></pre><h2 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h2><h3 id="countMatches-CharSequence-str-CharSequence-sub"><a href="#countMatches-CharSequence-str-CharSequence-sub" class="headerlink" title="countMatches(CharSequence str, CharSequence sub)"></a>countMatches(CharSequence str, CharSequence sub)</h3><p>计算某字符串在字符串中的出现次数。</p><pre><code class="java">StringUtils.countMatches(&quot;abba&quot;, null)  = 0StringUtils.countMatches(&quot;abba&quot;, &quot;&quot;)    = 0StringUtils.countMatches(&quot;abba&quot;, &quot;a&quot;)   = 2StringUtils.countMatches(&quot;abba&quot;, &quot;ab&quot;)  = 1StringUtils.countMatches(&quot;abba&quot;, &quot;xxx&quot;) = 0</code></pre><h2 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h2><h3 id="isAlpha-CharSequence-cs"><a href="#isAlpha-CharSequence-cs" class="headerlink" title="isAlpha(CharSequence cs)"></a>isAlpha(CharSequence cs)</h3><p>判断字符串是否是Unicode字母。</p><pre><code class="java">StringUtils.isAlpha(null)   = falseStringUtils.isAlpha(&quot;&quot;)     = falseStringUtils.isAlpha(&quot;  &quot;)   = falseStringUtils.isAlpha(&quot;abc&quot;)  = trueStringUtils.isAlpha(&quot;ab2c&quot;) = falseStringUtils.isAlpha(&quot;ab-c&quot;) = false</code></pre><h3 id="isAlphaSpace-CharSequence-cs"><a href="#isAlphaSpace-CharSequence-cs" class="headerlink" title="isAlphaSpace(CharSequence cs)"></a>isAlphaSpace(CharSequence cs)</h3><p>同<code>isAlpha(CharSequence cs)</code>相似。判断字符串是否是Unicode字母或空格。</p><pre><code class="java">StringUtils.isAlphaSpace(null)   = falseStringUtils.isAlphaSpace(&quot;&quot;)     = trueStringUtils.isAlphaSpace(&quot;  &quot;)   = trueStringUtils.isAlphaSpace(&quot;abc&quot;)  = trueStringUtils.isAlphaSpace(&quot;ab c&quot;) = trueStringUtils.isAlphaSpace(&quot;ab2c&quot;) = falseStringUtils.isAlphaSpace(&quot;ab-c&quot;) = false</code></pre><h3 id="isAlphanumeric-CharSequence-cs"><a href="#isAlphanumeric-CharSequence-cs" class="headerlink" title="isAlphanumeric(CharSequence cs)"></a>isAlphanumeric(CharSequence cs)</h3><p>同<code>isAlpha(CharSequence cs)</code>相似。判断字符串是否是Unicode字母或数字。</p><h3 id="isAlphanumericSpace-CharSequence-cs"><a href="#isAlphanumericSpace-CharSequence-cs" class="headerlink" title="isAlphanumericSpace(CharSequence cs)"></a>isAlphanumericSpace(CharSequence cs)</h3><p>同<code>isAlpha(CharSequence cs)</code>相似。判断字符串是否是Unicode字母、空格或数字。</p><h3 id="isNumeric-CharSequence-cs"><a href="#isNumeric-CharSequence-cs" class="headerlink" title="isNumeric(CharSequence cs)"></a>isNumeric(CharSequence cs)</h3><p>判断字符串是否是数字。</p><pre><code class="java">StringUtils.isNumeric(&quot;123&quot;)  = trueStringUtils.isNumeric(&quot;12 3&quot;) = falseStringUtils.isNumeric(&quot;ab2c&quot;) = falseStringUtils.isNumeric(&quot;12-3&quot;) = falseStringUtils.isNumeric(&quot;12.3&quot;) = falseStringUtils.isNumeric(&quot;-123&quot;) = falseStringUtils.isNumeric(&quot;+123&quot;) = false</code></pre><h3 id="isNumericSpace-CharSequence-cs"><a href="#isNumericSpace-CharSequence-cs" class="headerlink" title="isNumericSpace(CharSequence cs)"></a>isNumericSpace(CharSequence cs)</h3><p>同<code>isNumeric(CharSequence cs)</code>相似。判断字符串是否是空格或数字。</p><h3 id="getDigits-String-str"><a href="#getDigits-String-str" class="headerlink" title="getDigits(String str)"></a>getDigits(String str)</h3><p>从字符串中提取出数字为字符串。</p><pre><code class="java">StringUtils.getDigits(null)  = nullStringUtils.getDigits(&quot;&quot;)    = &quot;&quot;StringUtils.getDigits(&quot;abc&quot;) = &quot;&quot;StringUtils.getDigits(&quot;1000$&quot;) = &quot;1000&quot;StringUtils.getDigits(&quot;1123~45&quot;) = &quot;12345&quot;StringUtils.getDigits(&quot;(541) 754-3010&quot;) = &quot;5417543010&quot;</code></pre><h3 id="isWhitespace-CharSequence-cs"><a href="#isWhitespace-CharSequence-cs" class="headerlink" title="isWhitespace(CharSequence cs)"></a>isWhitespace(CharSequence cs)</h3><p>判断是否是空格。</p><pre><code class="java">StringUtils.isWhitespace(null)   = falseStringUtils.isWhitespace(&quot;&quot;)     = trueStringUtils.isWhitespace(&quot;  &quot;)   = trueStringUtils.isWhitespace(&quot;abc&quot;)  = falseStringUtils.isWhitespace(&quot;ab2c&quot;) = falseStringUtils.isWhitespace(&quot;ab-c&quot;) = false</code></pre><h3 id="isAllLowerCase-CharSequence-cs"><a href="#isAllLowerCase-CharSequence-cs" class="headerlink" title="isAllLowerCase(CharSequence cs)"></a>isAllLowerCase(CharSequence cs)</h3><p>判断字符串是否都是小写。</p><pre><code class="java">StringUtils.isAllLowerCase(null)   = falseStringUtils.isAllLowerCase(&quot;&quot;)     = falseStringUtils.isAllLowerCase(&quot;  &quot;)   = falseStringUtils.isAllLowerCase(&quot;abc&quot;)  = trueStringUtils.isAllLowerCase(&quot;abC&quot;)  = falseStringUtils.isAllLowerCase(&quot;ab c&quot;) = falseStringUtils.isAllLowerCase(&quot;ab1c&quot;) = falseStringUtils.isAllLowerCase(&quot;ab/c&quot;) = false</code></pre><h3 id="isAllUpperCase-CharSequence-cs"><a href="#isAllUpperCase-CharSequence-cs" class="headerlink" title="isAllUpperCase(CharSequence cs)"></a>isAllUpperCase(CharSequence cs)</h3><p>同<code>isAllLowerCase</code>相反。判断字符串是否都是大写。</p><h3 id="isMixedCase-CharSequence-cs"><a href="#isMixedCase-CharSequence-cs" class="headerlink" title="isMixedCase(CharSequence cs)"></a>isMixedCase(CharSequence cs)</h3><p>同<code>isAllLowerCase</code>相似。判断字符串是否大小写都有。</p><h2 id="默认字符串"><a href="#默认字符串" class="headerlink" title="默认字符串"></a>默认字符串</h2><h3 id="defaultString-String-str"><a href="#defaultString-String-str" class="headerlink" title="defaultString(String str)"></a>defaultString(String str)</h3><p>得到默认字符串，默认空字符串。</p><pre><code class="java">StringUtils.defaultString(null)  = &quot;&quot;StringUtils.defaultString(&quot;&quot;)    = &quot;&quot;StringUtils.defaultString(&quot;bat&quot;) = &quot;bat&quot;</code></pre><h3 id="defaultString-String-str-String-defaultStr"><a href="#defaultString-String-str-String-defaultStr" class="headerlink" title="defaultString(String str, String defaultStr)"></a>defaultString(String str, String defaultStr)</h3><p>如果是null，则得到默认字符串。</p><pre><code class="java">StringUtils.defaultString(null, &quot;NULL&quot;)  = &quot;NULL&quot;StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;)    = &quot;&quot;StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;</code></pre><h3 id="defaultIfEmpty-T-str-T-defaultStr"><a href="#defaultIfEmpty-T-str-T-defaultStr" class="headerlink" title="defaultIfEmpty(T str, T defaultStr)"></a>defaultIfEmpty(T str, T defaultStr)</h3><p>同<code>defaultString(String str, String defaultStr)</code>相似。如果是空字符串，则得到默认字符串。</p><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><h3 id="reverse-final-String-str"><a href="#reverse-final-String-str" class="headerlink" title="reverse(final String str)"></a>reverse(final String str)</h3><p>反转字符串。</p><pre><code class="java">StringUtils.reverse(null)  = nullStringUtils.reverse(&quot;&quot;)    = &quot;&quot;StringUtils.reverse(&quot;bat&quot;) = &quot;tab&quot;</code></pre><h2 id="缩写字符串"><a href="#缩写字符串" class="headerlink" title="缩写字符串"></a>缩写字符串</h2><h3 id="abbreviate-String-str-int-maxWidth"><a href="#abbreviate-String-str-int-maxWidth" class="headerlink" title="abbreviate(String str, int maxWidth)"></a>abbreviate(String str, int maxWidth)</h3><p>缩写字符串为最大maxWidth长度的字符串，使用<code>...</code>作为缩写的后缀，maxWidth不能小于等于3。</p><pre><code class="java">StringUtils.abbreviate(&quot;&quot;, 4)        = &quot;&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, 6) = &quot;abc...&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, 7) = &quot;abcdefg&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, 8) = &quot;abcdefg&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, 4) = &quot;a...&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, 3) = IllegalArgumentException</code></pre><h3 id="abbreviate-String-str-String-abbrevMarker-int-maxWidth"><a href="#abbreviate-String-str-String-abbrevMarker-int-maxWidth" class="headerlink" title="abbreviate(String str, String abbrevMarker, int maxWidth)"></a>abbreviate(String str, String abbrevMarker, int maxWidth)</h3><p>缩写字符串为最大maxWidth长度的字符串，使用<code>abbrevMarker</code>作为缩写的后缀，maxWidth不能小于等于<code>abbrevMarker</code>的长度。</p><pre><code class="java">StringUtils.abbreviate(&quot;&quot;, &quot;...&quot;, 4)        = &quot;&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, &quot;.&quot;, 5)   = &quot;abcd.&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, &quot;.&quot;, 7)   = &quot;abcdefg&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, &quot;.&quot;, 8)   = &quot;abcdefg&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, &quot;..&quot;, 4)  = &quot;ab..&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, &quot;..&quot;, 3)  = &quot;a..&quot;StringUtils.abbreviate(&quot;abcdefg&quot;, &quot;..&quot;, 2)  = IllegalArgumentExceptionStringUtils.abbreviate(&quot;abcdefg&quot;, &quot;...&quot;, 3) = IllegalArgumentException</code></pre><h2 id="字符串钱后缀"><a href="#字符串钱后缀" class="headerlink" title="字符串钱后缀"></a>字符串钱后缀</h2><h3 id="startsWith-CharSequence-str-CharSequence-prefix"><a href="#startsWith-CharSequence-str-CharSequence-prefix" class="headerlink" title="startsWith(CharSequence str, CharSequence prefix)"></a>startsWith(CharSequence str, CharSequence prefix)</h3><p>判断某字符串是否包含有指定前缀的字符串。</p><pre><code class="java">StringUtils.startsWith(null, null)      = trueStringUtils.startsWith(null, &quot;abc&quot;)     = falseStringUtils.startsWith(&quot;abcdef&quot;, null)  = falseStringUtils.startsWith(&quot;abcdef&quot;, &quot;abc&quot;) = trueStringUtils.startsWith(&quot;ABCDEF&quot;, &quot;abc&quot;) = false</code></pre><h3 id="startsWithIgnoreCase-CharSequence-str-CharSequence-prefix"><a href="#startsWithIgnoreCase-CharSequence-str-CharSequence-prefix" class="headerlink" title="startsWithIgnoreCase(CharSequence str, CharSequence prefix)"></a>startsWithIgnoreCase(CharSequence str, CharSequence prefix)</h3><p>同<code>startsWith(CharSequence str, CharSequence prefix)</code>相似。忽略大小写。</p><h3 id="startsWithAny-CharSequence-sequence-CharSequence…-searchStrings"><a href="#startsWithAny-CharSequence-sequence-CharSequence…-searchStrings" class="headerlink" title="startsWithAny(CharSequence sequence, CharSequence… searchStrings)"></a>startsWithAny(CharSequence sequence, CharSequence… searchStrings)</h3><p>判断某字符串是否包含有其后任意一个指定前缀的字符串。</p><pre><code class="java">StringUtils.startsWithAny(null, null)      = falseStringUtils.startsWithAny(null, new String[] {&quot;abc&quot;})  = falseStringUtils.startsWithAny(&quot;abcxyz&quot;, null)     = falseStringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {&quot;&quot;}) = trueStringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {&quot;abc&quot;}) = trueStringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {null, &quot;xyz&quot;, &quot;abc&quot;}) = trueStringUtils.startsWithAny(&quot;abcxyz&quot;, null, &quot;xyz&quot;, &quot;ABCX&quot;) = falseStringUtils.startsWithAny(&quot;ABCXYZ&quot;, null, &quot;xyz&quot;, &quot;abc&quot;) = false</code></pre><h3 id="endsWith-CharSequence-str-CharSequence-suffix"><a href="#endsWith-CharSequence-str-CharSequence-suffix" class="headerlink" title="endsWith(CharSequence str, CharSequence suffix)"></a>endsWith(CharSequence str, CharSequence suffix)</h3><p>同<code>startsWith(CharSequence str, CharSequence prefix)</code>相反。</p><h3 id="endsWithIgnoreCase-CharSequence-str-CharSequence-suffix"><a href="#endsWithIgnoreCase-CharSequence-str-CharSequence-suffix" class="headerlink" title="endsWithIgnoreCase(CharSequence str, CharSequence suffix)"></a>endsWithIgnoreCase(CharSequence str, CharSequence suffix)</h3><p>同<code>startsWithIgnoreCase(CharSequence str, CharSequence prefix)</code>相反。</p><h3 id="endsWithAny-CharSequence-sequence-CharSequence…-searchStrings"><a href="#endsWithAny-CharSequence-sequence-CharSequence…-searchStrings" class="headerlink" title="endsWithAny(CharSequence sequence, CharSequence… searchStrings)"></a>endsWithAny(CharSequence sequence, CharSequence… searchStrings)</h3><p>同<code>startsWithAny(CharSequence sequence, CharSequence... searchStrings)</code>相反。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL基础知识整理</title>
      <link href="/2018/09/25/shu-ju-ku/postgresql-ji-chu-zhi-shi-zheng-li/"/>
      <url>/2018/09/25/shu-ju-ku/postgresql-ji-chu-zhi-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库操作DML"><a href="#数据库操作DML" class="headerlink" title="数据库操作DML"></a>数据库操作DML</h2><h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><p><code>CREATE TABLE</code>语句用于创建数据库中的表。语法是：</p><pre><code class="sql">CREATE TABLE 表名称 (列名1 数据类型,列名2 数据类型,列名3 数据类型,....);</code></pre><p>例：</p><pre><code class="sql">CREATE TABLE user (id integer,user_name varchar(255),email varchar(255),age integer,address varchar(255))</code></pre><p><strong>注意</strong>：字段类型<code>char</code>和<code>varchar</code>区别：</p><ul><li>容纳固定长度的字符串。</li><li>容纳可变长度的字符串。</li></ul><h3 id="CONSTRAINT"><a href="#CONSTRAINT" class="headerlink" title="CONSTRAINT"></a>CONSTRAINT</h3><p>约束、限制，常见的约束如下：</p><ul><li><code>CHECK</code>(检查约束)</li><li><code>NOT NULL</code>(非空约束)</li><li><code>UNIQUE</code>(唯一约束)</li><li><code>Primary Key</code>(主键)</li><li><code>Foreign Key</code>(外键)</li></ul><p>例：</p><pre><code class="sql">-- 各种约束的使用示例CREATE TABLE user (    id integer NOT NULL PRIMARY KEY,    corp_id integer REFERENCES corp (id),    user_name text UNIQUE,    age numeric CHECK (age &gt; 0));</code></pre><h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><p><code>ALTER TABLE</code>用来添加，删除或修改现有表中的列，也可以用来添加和删除现有表上的各种制约因素。语法如下：</p><pre><code class="sql">-- 现有表中添加一个新的列ALTER TABLE table ADD column datatype;-- 现有表中删除一个新的列ALTER TABLE table DROP COLUMN column;-- 现有表中更改数据类型的列ALTER TABLE table MODIFY COLUMN column datatype;-- 现有表中一列添加NOT NULL约束ALTER TABLE table MODIFY column datatype NOT NULL;-- 现有表中添加唯一约束ALTER TABLE table ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...);-- 现有表中添加CHECK约束ALTER TABLE table ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);-- 现有表中添加PRIMARY KEY约束ALTER TABLE table ADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...);-- 现有表中删除约束ALTER TABLE table DROP CONSTRAINT MyUniqueConstraint;-- 现有表中删除主键ALTER TABLE table DROP CONSTRAINT MyPrimaryKey;</code></pre><h3 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h3><p><code>DROP TABLE</code>语句是用来删除表定义及其所有相关的数据表的索引，规则，触发器和约束。语法如下：</p><pre><code class="sql">DROP TABLE table;</code></pre><h3 id="TRUNCATE-TABLE"><a href="#TRUNCATE-TABLE" class="headerlink" title="TRUNCATE TABLE"></a>TRUNCATE TABLE</h3><p><code>TRUNCATE TABLE</code>命令用于从现有的表删除完整的数据。在每个表上的DELETE（删除）具有相同的效果，但是，因为它没有实际扫描的表，它的速度快。语法如下：</p><pre><code class="sql">TRUNCATE TABLE  table;</code></pre><h3 id="DELETE-FROM"><a href="#DELETE-FROM" class="headerlink" title="DELETE FROM"></a>DELETE FROM</h3><p><code>DELETE FROM</code>用来从一个表中删除现有的记录。可以使用WHERE子句DELETE查询删除所选行，否则所有的记录会被删除。语法如下：</p><pre><code class="sql">DELETE FROM table WHERE [condition];</code></pre><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p><code>INSERT INTO</code>语句允许一个到一个表中插入新行。一个可以作为一个查询的结果，在一个时间或几行插入一行。基本语法如下：</p><pre><code class="sql">INSERT INTO table (column1, column2, column3,...columnN)]VALUES (value1, value2, value3,...valueN);</code></pre><blockquote><p><strong>注</strong>：<br>1.这里 column1, column2,…columnN是要插入数据的表中的列名。</p><ol start="2"><li>可以以任何顺序列出目标列名。 VALUES子句或查询的值都与显式或隐式的列列表从左到右。</li></ol></blockquote><p>如果要添加表中的所有列的值，可能不需要在SQL查询中指定列（次）名称。但要确保表中是在相同的顺序的列值的顺序。INSERT INTO语法如下：</p><pre><code class="sql">INSERT INTO table VALUES (value1,value2,value3,...valueN);</code></pre><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><code>UPDATE</code>被用来修改现有的表中的记录。可以使用<code>UPDATE</code>查询的<code>WHERE</code>子句更新选定行，否则会被更新的所有行。基本语法如下：</p><pre><code>UPDATE table SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition];</code></pre><h2 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><pre><code class="sql">SELECT column FROM table;</code></pre><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>找出表内的不同值的情况。</p><pre><code class="sql">SELECT DISTINCT column FROM table;</code></pre><p>例：</p><pre><code class="sql">SELECT DISTINCT id, email FROM user;</code></pre><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><pre><code class="sql">SELECT column FROM table WHERE [condition];</code></pre><h3 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND / OR"></a>AND / OR</h3><pre><code class="sql">SELECT column FROM table WHERE [condition1] [AND|OR] [condition2];</code></pre><h3 id="IN-NOT-IN"><a href="#IN-NOT-IN" class="headerlink" title="IN / NOT IN"></a>IN / NOT IN</h3><pre><code class="sql">SELECT column FROM table WHERE column IN (&#39;value1&#39;, &#39;value2&#39;, ...);</code></pre><p>例：</p><pre><code class="sql">SELECT * FROM user WHERE user_name IN (&#39;张三&#39;, &#39;李四&#39;);</code></pre><h3 id="BETWEEN-…-AND-…"><a href="#BETWEEN-…-AND-…" class="headerlink" title="BETWEEN … AND …"></a>BETWEEN … AND …</h3><pre><code class="sql">SELECT column FROM table WHERE column BETWEEN &#39;value1&#39; AND &#39;value2&#39;;</code></pre><p>例：</p><pre><code class="sql">SELECT * FROM user WHERE age BETWEEN 18 AND 25;</code></pre><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><pre><code class="sql">SELECT column FROM table WHERE column LIKE {模式};</code></pre><p>例：</p><pre><code class="sql">SELECT * FROM user WHERE user_name LIKE &#39;%张%&#39;;</code></pre><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><pre><code class="sql">SELECT column FROM table [WHERE condition] ORDER BY column [ASC, DESC];</code></pre><blockquote><p><strong>注</strong>：ASC（默认）代表结果会以由小往大的顺序列出，而DESC代表结果会以由大往小的顺序列出。</p></blockquote><p>例：</p><pre><code class="sql">SELECT user_name, email, age FROM user ORDER BY age DESC;</code></pre><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><pre><code class="sql">SELECT column1, SUM(column2) FROM table GROUP BY column1;</code></pre><p>例：</p><pre><code class="sql">SELECT user_name, SUM(age) FROM user GROUP BY user_name;</code></pre><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><p>对函数产生的值来设定条件。</p><pre><code class="sql">SELECT column1, SUM(column2) FROM table GROUP BY column1 HAVING [condition];</code></pre><p>例：</p><pre><code class="sql">SELECT user_name, SUM(ages) FROM user GROUP BY user_name HAVING SUM(age) &gt; 1500;</code></pre><h3 id="ALIAS"><a href="#ALIAS" class="headerlink" title="ALIAS"></a>ALIAS</h3><blockquote><p>SELECT ‘表别名’.’列名’ AS ‘列别名’ FROM table AS ‘表别名’;</p></blockquote><p>例：</p><pre><code class="sql">SELECT u.user_name AS name, sum(age) ages FROM user AS u GROUP BY u.store_name;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><code>AVG</code> (平均)</li><li><code>COUNT</code> (计数)</li><li><code>MAX</code> (最大值)</li><li><code>MIN</code> (最小值)</li><li><code>SUM</code> (总合)</li></ul><pre><code class="sql">SELECT fun_name(column) FROM table;</code></pre><p>例：</p><pre><code class="sql">SELECT count(u.id) AS user_count FROM user AS u;</code></pre><h3 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h3><p>INNER JOIN: 如果表中有至少一个匹配，则返回行；<br>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行；<br>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行；<br>FULL JOIN: 只要其中一个表中存在匹配，就返回行。</p><p>例：</p><pre><code class="sql">SELECT u.uesr_name, c.corp_name FROM user AS u LEFT JOIN corp AS c ON c.id = u.corp_id;</code></pre><h2 id="SQL进阶"><a href="#SQL进阶" class="headerlink" title="SQL进阶"></a>SQL进阶</h2><h3 id="UNION-UNION-ALL"><a href="#UNION-UNION-ALL" class="headerlink" title="UNION / UNION ALL"></a>UNION / UNION ALL</h3><p><code>UNION</code>用于合并两个或多个SELECT语句的结果，不返回任何重复的行。<code>UNION ALL</code>运算符语句，则包括重复行的结果。使用UNION，每个SELECT选择的列数必须具有相同的，相同数目的列表达式相同的数据类型，并让它们在相同的顺序，但它们不必是相同的长度。语法如下：</p><pre><code class="sql">SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]UNION [UNION ALL]SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]</code></pre><h3 id="INTERSECT-INTERSECT-ALL"><a href="#INTERSECT-INTERSECT-ALL" class="headerlink" title="INTERSECT / INTERSECT ALL"></a>INTERSECT / INTERSECT ALL</h3><p>和<code>UNION</code>指令类似，<code>INTERSECT</code>也是对两个SQL语句所产生的结果做处理的。不同的地方是，<code>UNION</code>基本上是一个<code>OR</code>(如果这个值存在于第一句或是第二句，它就会被选出)，而<code>INTERSECT</code>则比较像<code>AND</code>(这个值要存在于第一句和第二句才会被选出)。<code>UNION</code>是并集，而<code>INTERSECT</code>是交集。<code>INTERSECT ALL</code>则包含交集后的重复数据。语法如下：</p><pre><code class="sql">SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]INTERSECT [INTERSECT ALL]SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]</code></pre><h3 id="EXCEPT-EXCEPT-ALL"><a href="#EXCEPT-EXCEPT-ALL" class="headerlink" title="EXCEPT / EXCEPT ALL"></a>EXCEPT / EXCEPT ALL</h3><p><code>EXCEPT</code>用于求差集，其将查询在前一个结果集中但是不再后面一个结果集中的记录。<code>EXCEPT ALL</code>则包含交集后的重复数据。语法如下：</p><pre><code class="sql">SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]EXCEPT [EXCEPT ALL]SELECT column1 [, column2 ]FROM table1 [, table2 ][WHERE condition]</code></pre><blockquote><p><strong>注</strong>：在其他数据库求差集的关键字是：<code>MINUS</code>。</p></blockquote><h3 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h3><p><code>SUBQUERY</code>即子查询，子查询也是一个普通查询，目的是将用子查询返回的数据将被用来在主查询中作为条件，以进一步限制要检索的数据。可以使用子查询的有SELECT，INSERT，UPDATE和DELETE语句，与运算符如=，&lt;，&gt;，&gt;=，&lt;=，IN等一起使用。有几个子查询必须遵循的规则：</p><ul><li>必须用括号括起来的子查询。</li><li>子查询只能有一个在SELECT子句中的列，除非多列在主查询的查询来比较其选定的列。</li><li>ORDER BY不能使用在子查询中，虽然主查询就可以使用ORDER BY。GROUP BY可以用来执行相同的功能在子查询中的ORDER BY。</li><li>子查询返回多于一行只能用于使用多值的运算符，如为IN，EXISTS，IN，ANY / SOME，ALL运算符。</li></ul><p>使用示例如下：</p><pre><code class="sql">-- SELECT语句中的子查询SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY WHERE SALARY &gt; 45000);-- INSERT语句的子查询INSERT INTO COMPANY_BKP SELECT * FROM COMPANY WHERE ID IN (SELECT ID FROM COMPANY);-- UPDATE语句的子查询UPDATE COMPANY SET SALARY = SALARY * 0.50 WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt;= 27);-- UPDATE语句的子查询DELETE FROM COMPANY WHERE AGE IN (SELECT AGE FROM COMPANY_BKP WHERE AGE &gt; 27 );</code></pre><h3 id="EXISTS-NOT-EXISTS"><a href="#EXISTS-NOT-EXISTS" class="headerlink" title="EXISTS / NOT EXISTS"></a>EXISTS / NOT EXISTS</h3><p><code>EXISTS</code>用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。<code>NOT EXISTS</code>的作用与<code>EXISTS</code>正好相反。如果子查询没有返回行，则满足了<code>NOT EXISTS</code>中的<code>WHERE</code>子句。语法如下： </p><pre><code class="sql">EXISTS subquery</code></pre><p>EXISTS 和 IN 的比较：</p><ul><li>EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOLEAN值。EXISTS内部有一个子查询语句(SELECT … FROM…)，我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。而IN引导的子查询只能返回一个字段</li><li>EXISTS : 强调的是是否返回结果集，不要求知道返回什么，IN则需要知道返回的字段值。</li><li>EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</li></ul><h3 id="CONCATENATE"><a href="#CONCATENATE" class="headerlink" title="CONCATENATE"></a>CONCATENATE</h3><p>连接字符串。有的时候，我们有需要将由不同列获得的资料串连在一起。每一种数据库都有提供方法来达到这个目的。</p><ul><li>Oracle: CONCAT(), || </li><li>SQL Server: + </li><li>MySQL: CONCAT() </li><li>PostgreSQL: CONCAT(), || </li></ul><p>PostgreSQL的<code>CONCAT()</code>的语法如下：</p><blockquote><p>concat(str “any” [, str “any” [, …] ])</p></blockquote><p>PostgreSQL的<code>||</code>的语法如下：</p><blockquote><p>string || string<br>string || non-string 或 non-string || string</p></blockquote><p>例：</p><pre><code class="sql">SELECT u.user_name || &#39; &#39; || u.age FROM user AS u;</code></pre><h3 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING"></a>SUBSTRING</h3><p>截取字符串。</p><ul><li>Oracle: SUBSTR()</li><li>SQL Server: SUBSTRING()</li><li>MySQL: SUBSTR(), SUBSTRING()</li><li>PostgreSQL: SUBSTRING()</li></ul><p>PostgreSQL的SUBSTRING()语法如下：</p><ul><li>substring(string [from int] [for int]) 截取子字符串。</li><li>substring(string from pattern) 截取匹配POSIX正则表达式的子字符串。</li><li>substring(string from pattern for escape) 截取匹配SQL正则表达式的子字符串。</li></ul><p>例：</p><pre><code class="sql">-- 得到homsubstring(&#39;Thomas&#39; from 2 for 3);-- 得到massubstring(&#39;Thomas&#39; from &#39;...$&#39;)-- 得到omasubstring(&#39;Thomas&#39; from &#39;%#&quot;o_a#&quot;_&#39; for &#39;#&#39;)</code></pre><h3 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM"></a>TRIM</h3><p>SQL中的<code>TRIM</code>函数是用来移除掉一个字符串中的字头或字尾。最常见的用途是移除字首或字尾的空白。这个函数在不同的数据库中有不同的名称： </p><ul><li>Oracle: LTRIM(), RTRIM()</li><li>SQL Server: LTRIM(), RTRIM()</li><li>MySQL: TRIM(), LTRIM(), RTRIM()</li><li>PostgreSQL: TRIM(), BTRIM(), LTRIM(), RTRIM()</li></ul><p>PostgreSQL的TRIM()语法如下：</p><ul><li>trim([leading | trailing | both] [characters] from string) 从字符串string的开头/结尾/两边删除只包含characters中字符(缺省是空白)的最长的字符串。</li><li>btrim(string text [, characters text]) 从string开头和结尾删除只包含 characters中字符(缺省是空白)的最长字符串。</li><li>ltrim(string text [, characters text]) 从字符串string的开头删除只包含characters 中字符(缺省是一个空白)的最长的字符串。</li><li>rtrim(string text [, characters text]) 从字符串string的结尾删除只包含characters中字符(缺省是个空白)的最长的字符串。</li></ul><pre><code class="sql">-- 得到Tomtrim(both &#39;x&#39; from &#39;xTomxx&#39;)-- 得到trimbtrim(&#39;xyxtrimyyx&#39;, &#39;xy&#39;)-- 得到trimltrim(&#39;zzzytrim&#39;, &#39;xyz&#39;)-- 得到trimrtrim(&#39;trimxxxx&#39;, &#39;x&#39;)</code></pre><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><p><code>CASE</code>表达式是一种通用的条件表达式，类似于其它编程语言中的<code>if/else</code>语句。</p><pre><code class="sql">CASE WHEN [condition] THEN result     [WHEN ...]     [ELSE result]END</code></pre><p>示例如下：</p><pre><code class="sql">SELECT sex,     CASE WHEN sex = 0 THEN &#39;女&#39;          WHEN sex = 1 THEN &#39;男&#39;          ELSE &#39;未知&#39;     END FROM user;</code></pre><h3 id="COALESCE"><a href="#COALESCE" class="headerlink" title="COALESCE"></a>COALESCE</h3><p><code>COALESCE</code>返回它的第一个非<code>NULL</code>的参数值。如果所有参数都是NULL那么返回NULL。它常用于在显示数据时用缺省值替换NULL。语法如下：</p><pre><code class="sql">COALESCE(value [, ...])</code></pre><p>使用示例：</p><pre><code class="sql">SELECT COALESCE(NULL, NULL, GETDATE());</code></pre><h3 id="NULLIF"><a href="#NULLIF" class="headerlink" title="NULLIF"></a>NULLIF</h3><p>当且仅当value1等于value2时，<code>NULLIF</code>才返回null。否则它返回value1。这些可以用于执行上面给出的<code>COALESCE</code>例子的反例。语法如下：</p><pre><code class="sql">NULLIF(value1, value2)</code></pre><h3 id="GREATEST-LEAST"><a href="#GREATEST-LEAST" class="headerlink" title="GREATEST / LEAST"></a>GREATEST / LEAST</h3><p>GREATEST和LEAST函数从一个任意数字表达式的列表里选取最大或者最小的数值。 这些表达式必须都可以转换成一个普通的数据类型，它将会是结果类型。列表中的NULL值将被忽略。只有所有表达式的结果都是 NULL 的时候，结果才会是 NULL。语法如下：</p><pre><code class="sql">GREATEST(value [, ...])LEAST(value [, ...])</code></pre><blockquote><p><strong>注意</strong>：GREATEST和LEAST都不是 SQL 标准，但却是很常见的扩展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git知识点整理</title>
      <link href="/2018/09/24/ruan-jian-gong-ju/git-zhi-shi-dian-zheng-li/"/>
      <url>/2018/09/24/ruan-jian-gong-ju/git-zhi-shi-dian-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基本概念。"><a href="#1-Git基本概念。" class="headerlink" title="1. Git基本概念。"></a>1. Git基本概念。</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p><img src="http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg" alt="Git工作空间"></p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="1-文件状态"><a href="#1-文件状态" class="headerlink" title="(1).文件状态"></a>(1).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交(<code>committed</code>)</strong>、<strong>已修改(<code>modified</code>)</strong>和<strong>已暂存(<code>staged</code>)</strong>。</p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre><code class="bash">git config --global user.name &quot;Jerry Mouse&quot;git config --global user.email &quot;jerry@yiibai.com&quot;</code></pre><p>列出Git设置</p><pre><code class="bash">git config --listgit config -l</code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre><code class="bash">Git fetch origin mastergit log -p master..origin/mastergit merge origin/master</code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="1-git-pull示例："><a href="#1-git-pull示例：" class="headerlink" title="(1). git pull示例："></a>(1). git pull示例：</h3><pre><code class="bash">git pull origin master</code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。 </li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p><img src="http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png" alt="merge和rebase"></p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看</li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[<stash>] 删除某一个进度，默认删除最新进度</stash></li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre><code class="bash"># 恢复工作进度git stash pop [--index] [&lt;stash&gt;]--index 参数：不仅恢复工作区，还恢复暂存区&lt;stash&gt; 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度# 这是git stash保存进度的完整命令形式git stash [save message] [-k|--no-keep-index] [--patch]-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注# git stash save &quot;这是保存的进度&quot;</code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么?"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么?</h2><pre><code class="bash">git rm --cachedgit rmgit commit</code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre><code class="bash"># 列出现有的标签git tag# 打标签git tag -a v1.01 -m &quot;Relase version 1.01&quot;# 查看相应标签的版本信息git show v1.4</code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre><code class="bash"># 查看本地分支git branch# 查看远程分支git branch -r# 创建本地分支(注意新分支创建后不会自动切换为当前分支)git branch [name]# 切换分支git checkout [name]# 创建新分支并立即切换到新分支git checkout -b [name]# 强制删除一个分支git branch -D [name]# 合并分支(将名称为[name]的分支与当前分支合并)git merge [name]# 查看各个分支最后提交信息git br -v# 查看已经被合并到当前分支的分支git br --merged# 查看尚未被合并到当前分支的分支git br --no-merged</code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre><code class="bash"># 克隆jQuery的版本库 git clone https://github.com/jquery/jquery.git git clone -o jQuery https://github.com/jquery/jquery.git</code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre><code class="bash"># 列出所有远程主机git remote# 使用-v选项，可以参看远程主机的网址git remote -v# 可以查看该主机的详细信息git remote show &lt;主机名&gt;# 添加远程主机git remote add &lt;主机名&gt; &lt;网址&gt;# 删除远程主机git remote rm &lt;主机名&gt;# 修改远程主机名称git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre><code class="bash"># 取回所有分支(branch)的更新到本地git fetch &lt;远程主机名&gt;# 取回某的特定分支的更新git fetch &lt;远程主机名&gt; &lt;分支名&gt;# 取回origin主机的master分支的更新git fetch origin master# 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支git merge origin/mastergit rebase origin/master</code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre><code class="bash"># 取回origin主机的next分支，与本地的master分支合并git pull origin next:master# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin next# 上面的命令实质上等同于先做git fetch，再做git merge。git fetch origingit merge origin/next# 合并需要采用rebase模式git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre><code class="bash"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建git push origin master# 省略了本地分支，以下等同，删除origin主机的master分支git push origin :mastergit push origin --delete master# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略git push origin# 如果当前分支只有一个追踪分支，那么主机名都可以省略。git push# 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git pushgit push -u origin master# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机git push --all origin# 强制推送git push --force origin# git push不会推送标签(tag)，除非使用–tags选项git push origin --tags</code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git flow</a>。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><p><img src="http://static.blinkfox.com/ghost/imagegit_flow.png" alt="Git Flow流程图"></p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre><code class="bash">git branch developgit push -u origin develop</code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre><code class="bash">git checkout -b some-feature develop# Optionally, push branch to origin:git push -u origin some-feature# 做一些改动git statusgit add some-filegit commit</code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre><code class="bash">git pull origin developgit checkout developgit merge --no-ff some-featuregit push origin developgit branch -d some-feature# If you pushed branch to origin:git push origin --delete some-feature</code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre><code class="bash">git checkout -b release-0.1.0 develop# Optional: Bump version number, commit# Prepare release, commit</code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre><code class="bash">git checkout mastergit merge --no-ff release-0.1.0git pushgit checkout developgit merge --no-ff release-0.1.0git pushgit branch -d release-0.1.0# If you pushed branch to origin:git push origin --delete release-0.1.0   git tag -a v0.1.0 mastergit push --tags</code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre><code class="bash">git checkout -b hotfix-0.1.1 master</code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre><code class="bash">git checkout mastergit merge --no-ff hotfix-0.1.1git pushgit checkout developgit merge --no-ff hotfix-0.1.1git pushgit branch -d hotfix-0.1.1git tag -a v0.1.1 mastergit push --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之状态模式</title>
      <link href="/2018/09/21/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-tai-mo-shi/"/>
      <url>/2018/09/21/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-tai-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>状态模式(<code>State Pattern</code>)</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)，状态模式是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态角色</li><li><code>ConcreteState</code>: 具体状态角色类</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/State.jpg" alt="状态模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_State.jpg" alt="状态模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的状态角色接口：</p><pre><code class="java">/** * 抽象状态角色 * Created by blinkfox on 16/7/12. */public interface IState {    /**     * 抽象方法1     */    void handle1();    /**     * 抽象方法2     */    void handle2();}</code></pre><p>接下来，是多个具体的状态角色类，分别如下：</p><pre><code class="java">/** * 具体状态角色类1 * Created by blinkfox on 16/7/12. */public class ConcreteState1 implements IState {    /**     * 具体状态角色类1中的方法1     */    @Override    public void handle1() {        System.out.println(&quot;执行了具体状态角色类1中的方法1...&quot;);    }    /**     * 具体状态角色类1中的方法2     */    @Override    public void handle2() {        System.out.println(&quot;执行了具体状态角色类1中的方法2...&quot;);    }}</code></pre><pre><code class="java">/** * 具体状态角色类2 * Created by blinkfox on 16/7/12. */public class ConcreteState2 implements IState {    /**     * 具体状态角色类2中的方法1     */    @Override    public void handle1() {        System.out.println(&quot;执行了具体状态角色类2中的方法1...&quot;);    }    /**     * 具体状态角色类2中的方法2     */    @Override    public void handle2() {        System.out.println(&quot;执行了具体状态角色类2中的方法2...&quot;);    }}</code></pre><p>然后，是环境类：</p><pre><code class="java">/** * 环境角色类 * Created by blinkfox on 16/7/12. */public class Context {    // 当前状态    private IState state;    /**     * 构造方法     * @param state     */    public Context(IState state) {        this.state = state;    }    /**     * 方法1     */    public void handle1() {        this.state.handle1();    }    /**     * 方法2     */    public void handle2() {        this.state.handle2();    }}</code></pre><p>最后，是用于测试状态模式的客户端场景类：</p><pre><code class="java">/** * 状态模式的客户端场景累 * Created by blinkfox on 16/7/12. */public class StateClient {    public static void main(String[] args) {        Context context = new Context(new ConcreteState1());        context.handle1();        context.handle2();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>状态模式的优点：</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>状态模式的缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><blockquote><p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之代理模式</title>
      <link href="/2018/09/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dai-li-mo-shi/"/>
      <url>/2018/09/20/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>代理模式(<code>Proxy Pattern</code>)</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做<code>Proxy</code>或<code>Surrogate</code>，它是一种对象结构型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>代理模式包含如下角色：</p><ul><li><code>Subject</code>: 抽象主题角色</li><li><code>RealSubject</code>: 真实主题角色</li><li><code>Proxy</code>: 代理主题角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg" alt="代理模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的主题接口和真实主题类：</p><pre><code class="java">package com.blinkfox.patterns.proxy;/** * 抽象主题类 * Created by blinkfox on 2017/1/1. */public interface ISubject {    /**     * 定义一个方法     */    public void request();}</code></pre><pre><code class="java">package com.blinkfox.patterns.proxy;/** * 真实主题类 * Created by blinkfox on 2017/1/1. */public class RealSubject implements ISubject {    /**     * 实现方法     */    @Override    public void request() {        System.out.println(&quot;真实主题类请求方法...&quot;);    }}</code></pre><p>然后，是代理类：</p><pre><code class="java">package com.blinkfox.patterns.proxy;/** * 代理类 * Created by blinkfox on 2017/1/1. */public class Proxy implements ISubject {    private ISubject subject;    public Proxy(ISubject subject) {        this.subject = subject;    }    @Override    public void request() {        this.before();        this.subject.request();        this.after();    }    /**     * 预处理     */    private void before() {        System.out.println(&quot;执行前(before)的处理...&quot;);    }    /**     * 善后处理     */    private void after() {        System.out.println(&quot;执行后(after)的处理...&quot;);    }}</code></pre><p>最后，是客户端场景测试类：</p><pre><code class="java">package com.blinkfox.patterns.proxy;/** * 代理模式客户端场景类 * Created by blinkfox on 2017/1/1. */public class ProxyClient {    public static void main(String[] args) {        ISubject subject = new RealSubject();        Proxy proxy = new Proxy(subject);        proxy.request();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>代理模式的优点：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li><li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对真实对象的使用权限。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>代理模式的缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>同步化(Synchronization)代理</strong>：使几个用户能够同时使用一个对象而没有冲突。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVEL2.x模板指南</title>
      <link href="/2018/09/19/hou-duan/java/mvel2.x-mo-ban-zhi-nan/"/>
      <url>/2018/09/19/hou-duan/java/mvel2.x-mo-ban-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://github.com/mvel/mvel" target="_blank" rel="noopener">MVEL</a>最初作为Mike Brock创建的 Valhalla项目的表达式计算器（<code>expression evaluator</code>）。Valhalla本身是一个早期的类似 Seam 的“开箱即用”的Web 应用框架，而 Valhalla 项目现在处于休眠状态， MVEL则成为一个继续积极发展的项目。相比最初的<code>OGNL</code>、<code>JEXL</code>和<code>JUEL</code>等项目，而它具有远超它们的性能、功能和易用性 - 特别是集成方面。它不会尝试另一种JVM语言，而是着重解决嵌入式脚本的问题。关于MVEL的语法请参考<a href="http://blinkfox.com/mvel-2-xyu-fa-zhi-nan/" target="_blank" rel="noopener">MVEL 2.x语法指南</a></p></blockquote><p>MVEL 2.0提供了一个新的，更强大的，统一的模板引擎，汇集了1.2中引入的许多模板概念。 不幸的是，1.2中的模板引擎的架构不足以用于常规维护，并且决定从头开始完全重写模板引擎。</p><h2 id="一、MVEL-2-0基本模板"><a href="#一、MVEL-2-0基本模板" class="headerlink" title="一、MVEL 2.0基本模板"></a>一、MVEL 2.0基本模板</h2><p>MVEL模板由纯文本文档中的<code>orb-tags</code>组成。 Orb标记表示引擎将在运行时计算模板的动态元素。</p><p>如果你熟悉FreeMarker，这种类型的语法将不会完全陌生。</p><h3 id="1-一个简单的模板"><a href="#1-一个简单的模板" class="headerlink" title="1. 一个简单的模板"></a>1. 一个简单的模板</h3><pre><code class="java">Hello, @{person.getSex() == &#39;F&#39; ? &#39;Ms.&#39; : &#39;Mr.&#39;} @{person.name}This e-mail is to thank you for your interest in MVEL Templates 2.0.</code></pre><p>此模板展示了可以在简单文本中嵌入表达式。当计算结果时，输出可能如下所示：</p><pre><code class="java">Hello, Ms. Sarah PetersonThis e-mail is to thank you for your interest in MVEL Templates 2.0.</code></pre><h3 id="2-转义-符号"><a href="#2-转义-符号" class="headerlink" title="2. 转义@符号"></a>2. 转义@符号</h3><p>当然，由于@符号用于表示<code>orb-tag</code>的开头，因此您可能需要对其进行转义，以防止其被编译器处理。幸运的是，只有一种情况，即当你实际上需要输出‘@{‘字符串在您的模板上时。</p><p>由于编译器需要@和{组合触发orb识别，你可以自由使用@符号而不转义它们。例如：</p><pre><code class="java">Email any questions to: foo@bar.com@{date}@include{&#39;disclaimer.html&#39;}</code></pre><p>但是在你需要一个@符号挨着一个orb-tag的情况下，你需要通过重复它两次来避免它：</p><pre><code class="java">@{username}@@@{domain}</code></pre><p>这是两个@转义一个符号，第三个@是标签的开始。如果你感觉这看起来太乱，你可以使用替代方法，即使用表达式标签，如下所示：</p><pre><code class="java">@{username}@{&#39;@&#39;}@{domain}</code></pre><h2 id="二、MVEL-2-0-Orb标签"><a href="#二、MVEL-2-0-Orb标签" class="headerlink" title="二、MVEL 2.0 Orb标签"></a>二、MVEL 2.0 Orb标签</h2><p>本文包含了MVEL 2.0模板引擎中所有开箱即用的orb标签。</p><h3 id="1-Orb表达式"><a href="#1-Orb表达式" class="headerlink" title="1. @{} Orb表达式"></a>1. @{} Orb表达式</h3><p>@{}表达式是orb-tag的最基本形式。它包含一个对字符串求值的值表达式，并附加到输出模板中。例如：</p><pre><code class="java">Hello, my name is @{person.name}</code></pre><h3 id="2-code-静默代码标签"><a href="#2-code-静默代码标签" class="headerlink" title="2. @code{} 静默代码标签"></a>2. @code{} 静默代码标签</h3><p>静默代码标记允许您在模板中执行MVEL表达式代码。它不返回值，并且不以任何方式影响模板的格式。</p><pre><code class="java">@code{age = 23; name = &#39;John Doe&#39;}@{name} is @{age} years old</code></pre><p>该模板将计算出：John Doe is 23 years old。</p><h3 id="3-if-else-控制流标签"><a href="#3-if-else-控制流标签" class="headerlink" title="3. @if{}@else{} 控制流标签"></a>3. @if{}@else{} 控制流标签</h3><p>@if{}和@else{}标签在MVEL模板中提供了完全的if-then-else功能。 例如：</p><pre><code class="java">@if{foo != bar}   Foo not a bar!@else{bar != cat}   Bar is not a cat!@else{}   Foo may be a Bar or a Cat!@end{}</code></pre><p>MVEL模板中的所有块必须用<code>@end{}</code>标签来终止，除非是<code>if-then-else</code>结构，其中<code>@else{}</code>标记表示前一个控制语句的终止。</p><h3 id="4-foreach-Foreach迭代"><a href="#4-foreach-Foreach迭代" class="headerlink" title="4. @foreach{} Foreach迭代"></a>4. @foreach{} Foreach迭代</h3><p>foreach标签允许您在模板中迭代集合或数组。 注意：foreach的语法已经在MVEL模板2.0中改变，以使用foreach符号来标记MVEL语言本身的符号。</p><pre><code class="java">@foreach{item : products}  - @{item.serialNumber}@end{}</code></pre><p>MVEL 2.0要求您指定一个迭代变量。虽然MVEL 1.2假设您没有指定别名，但由于对该默认操作有一些抱怨，因此已被删除。</p><h3 id="5-多重迭代"><a href="#5-多重迭代" class="headerlink" title="5. 多重迭代"></a>5. 多重迭代</h3><p>您可以通过逗号分隔迭代在一个foreach循环中一次性迭代多个集合：</p><pre><code class="java">@foreach{var1 : set1, var2 : set2}  @{var1}-@{var2}@end{}</code></pre><h3 id="6-分隔"><a href="#6-分隔" class="headerlink" title="6. 分隔"></a>6. 分隔</h3><p>你可以通过在<code>@end{}</code>标签中指定迭代器的文本分隔符。</p><pre><code class="java">@foreach{item : people}@{item.name}@end{&#39;, &#39;}</code></pre><p>将返回类似这样的结果：John, Mary, Joseph。</p><h3 id="7-include-包含模板文件"><a href="#7-include-包含模板文件" class="headerlink" title="7. @include{} 包含模板文件"></a>7. @include{} 包含模板文件</h3><p>您可以使用此标签将模板文件包含到MVEL模板中。</p><pre><code class="java">@include{&#39;header.mv&#39;}This is a test template.</code></pre><p>您还可以通过在模板名称后面添加分号在include标签内执行MVEL表达式：</p><pre><code class="java">@include {&#39;header.mv&#39;; title =&#39;Foo Title&#39;}</code></pre><h3 id="8-includeNamed-包括一个命名模板"><a href="#8-includeNamed-包括一个命名模板" class="headerlink" title="8. @includeNamed{} 包括一个命名模板"></a>8. @includeNamed{} 包括一个命名模板</h3><p>命名模板是已经通过TemplateRegistry预先编译并传递到运行时的模板，或者已在模板本身中声明的模板。 您只需添加：</p><pre><code class="java">@includeNamed {&#39;fooTemplate&#39;}@includeNamed {&#39;footerTemplate&#39;，showSomething = true}</code></pre><p>你也可以在<code>@includeNamed{}</code>标签中执行MVEL代码，就像<code>@include{}</code>标签一样。</p><h3 id="9-declare-声明一个模板"><a href="#9-declare-声明一个模板" class="headerlink" title="9. @declare{} 声明一个模板"></a>9. @declare{} 声明一个模板</h3><p>除了包括外部文件的外部模板，并以编程方式传递它们之外，您还可以从模板中声明模板。 它允许你做这样的事情：</p><pre><code class="java">@declare{&#39;personTemplate&#39;} Name: @{name} Age:  @{age}@end{}@includeNamed{&#39;personTemplate&#39;; name=&#39;John Doe&#39;; age=22}</code></pre><h3 id="10-comment-注释标签"><a href="#10-comment-注释标签" class="headerlink" title="10. @comment{} 注释标签"></a>10. @comment{} 注释标签</h3><p>注释标签允许您向模板添加不可见的注释。 例如：</p><pre><code class="java">@comment{  This is a comment}Hello: @{name}!</code></pre><h2 id="三、MVEL-2-0模板集成"><a href="#三、MVEL-2-0模板集成" class="headerlink" title="三、MVEL 2.0模板集成"></a>三、MVEL 2.0模板集成</h2><p>使用MVEL模板是直接和容易的。 与常规MVEL表达式一样，它们可以解释性地执行，或者预编译并重新用于更快的评估。</p><h3 id="1-org-mvel-templates-TemplateRuntime-类"><a href="#1-org-mvel-templates-TemplateRuntime-类" class="headerlink" title="1. org.mvel.templates.TemplateRuntime 类"></a>1. org.mvel.templates.TemplateRuntime 类</h3><p><code>TemplateRuntime</code>类是模板引擎的中心。您可以通过<code>eval()</code>方法将要计算的模板传递给模板引擎。</p><p>一般来说，模板引擎遵循上下文和变量绑定的所有相同规则，使用一组重载的<code>eval()</code>方法。</p><p>下面是一个解析模板的简单例子：</p><pre><code class="java">String template = &quot;Hello, my name is @{name.toUpperCase()}&quot;);Map vars = new HashMap();vars.put(&quot;name&quot;, &quot;Michael&quot;);String output = (String) TemplateRuntime.eval(template, vars);</code></pre><p>在执行结束时，“output”变量将包含字符串：</p><pre><code class="java">Hello, my name is MICHAEL</code></pre><h3 id="2-org-mvel-templates-TemplateCompiler类"><a href="#2-org-mvel-templates-TemplateCompiler类" class="headerlink" title="2. org.mvel.templates.TemplateCompiler类"></a>2. org.mvel.templates.TemplateCompiler类</h3><p><code>TemplateCompiler</code>类允许预先编译模板。</p><p>当编译模板时，将生成一个紧凑，可重用的评估树，可以快速用于计算模板。它直接使用：</p><pre><code class="java">String template = &quot;1 + 1 = @{1+1}&quot;;// 编译模板CompiledTemplate compiled = TemplateCompiler.compileTemplate(template);// 执行模板String output = (String) TemplateRuntime.execute(compiled);</code></pre><p>在执行结束时，“output”变量将包含字符串：</p><pre><code class="java">1 + 1 = 2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MVEL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVEL 2.x语法指南</title>
      <link href="/2018/09/18/hou-duan/java/mvel2.x-yu-fa-zhi-nan/"/>
      <url>/2018/09/18/hou-duan/java/mvel2.x-yu-fa-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="MVEL-2-x语法指南"><a href="#MVEL-2-x语法指南" class="headerlink" title="MVEL 2.x语法指南"></a>MVEL 2.x语法指南</h1><p><a href="https://github.com/mvel/mvel" target="_blank" rel="noopener">MVEL</a>全称为：MVFLEX Expression Language，是用来计算Java语法所编写的表达式值的表达式语言。MVEL的语法很大程度上受到Java语法的启发，但为了使表达式语法更高效,还是有一些基本差异，例如可以像正则表达式一样直接支持集合、数组和字符串匹配的运算。</p><p>除了表达式语言之外，MVEL还用作配置和字符串构造的模板语言。这里还有一个关于<a href="https：//en.wikipedia.org/wiki/MVEL">MVEL</a>介绍信息的wiki页面是：https：//en.wikipedia.org/wiki/MVEL。</p><p>MVEL 2.x表达式主要包括以下特性：</p><ul><li>属性表达式</li><li>布尔表达式</li><li>方法调用</li><li>变量赋值</li><li>函数定义</li></ul><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><p>MVEL是基于Java语法的表达式语言，具有特定于MVEL的一些明显差异。与Java不同，MVEL是动态类型化（可选类型化），意味着在源代码中不需要类型限定。</p><p>MVEL可以方便的集成到产品中使用。Maven的集成方式如下：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mvel&lt;/groupId&gt;    &lt;artifactId&gt;mvel2&lt;/artifactId&gt;    &lt;version&gt;2.2.8.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>一个MVEL表达式，简单的可以是单个标识符，复杂的则可能是一个充满了方法调用和内部集合创建的庞大的布尔表达式。使用MVEL提供的API。可以动态得到表达式的执行结果。</p><h3 id="1-简单属性表达式"><a href="#1-简单属性表达式" class="headerlink" title="1. 简单属性表达式"></a>1. 简单属性表达式</h3><pre><code class="java">user.name</code></pre><p>在这个表达式中，我们只有一个标识符（user.name），在MVEL中我们称它为属性表达式，因为表达式的唯一目的就是从上下文中提取出变量或者对象的属性。属性表达式是最常见的用途之一，通过它，MVEL可以用来作为一个高性能，易使用的反射优化器。</p><p>MVEL甚至可以用来计算布尔表达式：</p><pre><code class="java">user.name ==&#39;John Doe&#39;</code></pre><p>与Java一样，MVEL支持所有优先级规则，包括通过括号来控制执行顺序。</p><pre><code class="java">(user.name == &#39;John Doe&#39;) &amp;&amp; ((x * 2) - 1) &gt; 20</code></pre><h3 id="2-复合语句"><a href="#2-复合语句" class="headerlink" title="2. 复合语句"></a>2. 复合语句</h3><p>您可以使用分号来表示语句的终止，使用任意数量的语句编写脚本。分号在所有情况下都是必需的，除非在脚本中只有一个语句或最后一个语句。</p><pre><code class="java">statement1; statement2; statement3</code></pre><blockquote><p><strong>注意</strong>：statement3语句后可以缺少分号。</p></blockquote><p>另外，换行不能替代分号来作为一个语句的结束标识。</p><h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h3><p>MVEL是被设计为一个集成语言作为核心，允许开发人员提供简单的脚本设置绑定和逻辑。因此，MVEL表达式使用“last value out”原则（输出最后值原则）。这意味着，尽管MVEL支持return关键字，但却没必要使用它。例如：</p><pre><code class="java">a = 10;b = (a = a * 2) + 10;a;</code></pre><p>在该示例中，表达式返回a的值，因为<code>a;</code>是表达式的最后一个值。它在功能上与下面的脚本等价：</p><pre><code class="java">a = 10;b = (a = a * 2) + 10;return a;</code></pre><h2 id="二、值判断"><a href="#二、值判断" class="headerlink" title="二、值判断"></a>二、值判断</h2><p>在MVEL中所有的判断是否相等，都是对值的判断，而没有对引用的判断，因此表达式<code>foo == &#39;bar&#39;</code>等价于Java中的<code>foo.equals(&quot;bar&quot;)</code>。</p><h3 id="1-判断空值"><a href="#1-判断空值" class="headerlink" title="1. 判断空值"></a>1. 判断空值</h3><p>MVEL提供了一个特殊的字符来表示值为空的情况，叫作<code>empty</code>，例如：</p><pre><code class="java">foo == empty</code></pre><p>若foo满足空的任何条件，这个表达式值都为true。</p><h3 id="2-判断Null值"><a href="#2-判断Null值" class="headerlink" title="2. 判断Null值"></a>2. 判断Null值</h3><p>MVEL中，<code>null</code>和<code>nil</code>都可以用来表示一个Null值，如：</p><pre><code class="java">foo == null;foo == nil; // 和null一样</code></pre><h3 id="3-强制转换"><a href="#3-强制转换" class="headerlink" title="3. 强制转换"></a>3. 强制转换</h3><p>当两个不同类型且没有可比性的值进行比较时，MVEL会应用类型强制转换系统，即将左边的值强制转换成右边的值的类型，反之亦然。如：</p><pre><code class="java">&quot;123&quot; == 123;</code></pre><p>这个表达式的值为true,因为为了执行比较，强制类型转换系统会隐式的将数字<code>123</code>转换成字符串。</p><h2 id="三、内联Lists、Maps和数组Arrays"><a href="#三、内联Lists、Maps和数组Arrays" class="headerlink" title="三、内联Lists、Maps和数组Arrays"></a>三、内联Lists、Maps和数组Arrays</h2><p>MVEL允许你使用简单优雅的语法来表示Lists，Mpas和数组Arrays。 且看下面的示例：</p><pre><code class="java">[&quot;Bob&quot; : new Person(&quot;Bob&quot;), &quot;Michael&quot; : new Person(&quot;Michael&quot;)]</code></pre><p>这个表达式的功能等价于：</p><pre><code class="java">Map map = new HashMap();map.put(&quot;Bob&quot;, new Person(&quot;Bob&quot;));map.put(&quot;Michael&quot;, new Person(&quot;Michael&quot;));</code></pre><p>用这种结构描述MVEL内部数据结构，功能非常强大，你可以在任何地方使用它，甚至可以作为方法的参数使用，如：</p><pre><code class="java">something.someMethod([&quot;foo&quot; : &quot;bar&quot;]);</code></pre><h3 id="1-Lists"><a href="#1-Lists" class="headerlink" title="1. Lists"></a>1. Lists</h3><p>Lists用以下格式来表示：”[item1, item2, …]”，如：</p><pre><code class="java">[&quot;Jim&quot;, &quot;Bob&quot;, &quot;Smith&quot;]</code></pre><h3 id="2-Maps"><a href="#2-Maps" class="headerlink" title="2. Maps"></a>2. Maps</h3><p>Maps用以下格式来表示：”[key1 : value1, key2: value2, …]”，如：</p><pre><code class="java">[&quot;Foo&quot; : &quot;Bar&quot;, &quot;Bar&quot; : &quot;Foo&quot;]</code></pre><h3 id="3-数组Arrays"><a href="#3-数组Arrays" class="headerlink" title="3. 数组Arrays"></a>3. 数组Arrays</h3><p>数组Arrays用以下格式来表示：”{item1, item2, …}”，如：</p><pre><code class="java">{&quot;Jim&quot;, &quot;Bob&quot;, &quot;Smith&quot;}</code></pre><h3 id="4-数组强制转换"><a href="#4-数组强制转换" class="headerlink" title="4. 数组强制转换"></a>4. 数组强制转换</h3><p>关于内联数组，需要知道的一个非常重要的方面是，它可以被强制转换成其它类型的数组，当你声明一个数组时，是不直接指定其类型的，但你可以通过将其传递给一个接收int[]类型参数的方法来指定。如：</p><pre><code class="java">foo.someMethod({1,2,3,4});</code></pre><p>在这种情况下，当MVEL发现目标方法接收的是一个int[]，会自动的将{1,2,3,4}转换成int[]类型。</p><h2 id="四、属性导航"><a href="#四、属性导航" class="headerlink" title="四、属性导航"></a>四、属性导航</h2><p>MVEL属性导航遵循在其他语言（如Groovy，OGNL，EL等）中bean属性表达式中公认惯例的使用方式。和其它语言必须通过底层的方法来控制权限不同的是，MVEL提供了一种单一的，统一的语法来访问属性，静态字段和maps等。</p><h3 id="1-Bean属性"><a href="#1-Bean属性" class="headerlink" title="1. Bean属性"></a>1. Bean属性</h3><p>大多数java开发者都熟悉getter/setter模式，并在java对象中用它来封装属性的访问权限。例如，你可能会通过下面的方式访问一个对象的属性：</p><pre><code class="java">user.getManager().getName();</code></pre><p>为了简化此操作，您可以使用以下表达式访问相同的属性：</p><pre><code class="java">user.manager.name</code></pre><blockquote><p><strong>注意：</strong>当一个对象中的字段的作用域是public时，MVEL仍然倾向于通过get方法来访问其属性。</p></blockquote><h3 id="2-Bean的安全属性导航"><a href="#2-Bean的安全属性导航" class="headerlink" title="2. Bean的安全属性导航"></a>2. Bean的安全属性导航</h3><p>有时，当你的表达式中会含有null元素时，这时就需要你进行一个为空判断，否则就会发生错误。当你使用null-safe操作符时你可以简化这个操作：</p><pre><code class="java">user.?manager.name</code></pre><p>它的功能相当于：</p><pre><code class="java">if (user.manager != null) { return user.manager.name; } else { return null; }</code></pre><h3 id="3-集合"><a href="#3-集合" class="headerlink" title="3. 集合"></a>3. 集合</h3><p>集合的遍历也可以通过简单的语法来实现：</p><h4 id="1-List的访问"><a href="#1-List的访问" class="headerlink" title="(1). List的访问"></a>(1). List的访问</h4><p>List可以像访问数组一样访问，如：</p><pre><code class="java">user[5]</code></pre><p>这等价与java中的代码：</p><pre><code class="java">user.get(5);</code></pre><h4 id="2-Map的访问"><a href="#2-Map的访问" class="headerlink" title="(2). Map的访问"></a>(2). Map的访问</h4><p>Map的访问和访问数组也非常相似，不同的是，在访问Map时索引值可以是任意对象，如：</p><pre><code class="java">user[&quot;foobar&quot;]</code></pre><p>这等价与java中的代码：</p><pre><code class="java">user.get(&quot;foobar&quot;);</code></pre><p>当Map的key是String类型时，还可以使用特殊的方式来访问，如：</p><pre><code class="java">user.foobar</code></pre><h3 id="4-字符串作数组"><a href="#4-字符串作数组" class="headerlink" title="4. 字符串作数组"></a>4. 字符串作数组</h3><p>为了能使用属性的索引（迭代也是如此），所有的字符串都可以看成是一个数组，在MVEL中你可以用下面的方式来获取一个字符串变量的第一个字符：</p><pre><code class="java">foo = &quot;My String&quot;;foo[0]; // returns &#39;M&#39;</code></pre><h2 id="五、文字常量"><a href="#五、文字常量" class="headerlink" title="五、文字常量"></a>五、文字常量</h2><p>在脚本语言中，一段文字（常量）用来代表一个固定的值。</p><h3 id="1-字符串常量"><a href="#1-字符串常量" class="headerlink" title="1. 字符串常量"></a>1. 字符串常量</h3><p>字符串常量可以用一对单引号或一对双引号来界定。如：</p><pre><code class="java">&quot;This is a string literal&quot;&#39;This is also string literal&#39;</code></pre><h4 id="字符串转义字符"><a href="#字符串转义字符" class="headerlink" title="字符串转义字符"></a>字符串转义字符</h4><ul><li>\ - 代表一个反斜杠。</li><li>\n - 换行符</li><li>\r - 回车符</li><li>\u#### - Unicode字符 (如: /uAE00)</li><li>### - 八进制字符 (如: /73)</li></ul><h3 id="2-数字常量"><a href="#2-数字常量" class="headerlink" title="2. 数字常量"></a>2. 数字常量</h3><p>整数可以表示为十进制（基数为10），8进制（基数为8），或十六进制（基数为16）。</p><p>一个十进制数字，不从零开始（相对于8进制、16进制而言），可以表示任意数，如：</p><pre><code class="java">125 // 十进制</code></pre><p>一个八进制数，以0为前缀，后面跟着0到7内的数字。</p><pre><code class="java">0353 // 八进制</code></pre><p>一个十六进制，以0X为前缀，后面可以跟着0-9，A-F范围内的数字。</p><pre><code class="java">0xAFF0 // 十六进制</code></pre><h3 id="3-浮点型常量"><a href="#3-浮点型常量" class="headerlink" title="3. 浮点型常量"></a>3. 浮点型常量</h3><p>浮点数由整数和由点/周期字符表示的小数部分组成，带有可选的类型后缀。</p><pre><code class="java">10.503 // double型94.92d // double型14.5f // float型</code></pre><h3 id="4-大数字常量"><a href="#4-大数字常量" class="headerlink" title="4. 大数字常量"></a>4. 大数字常量</h3><p>您可以使用后缀B和I（必须大写）来表示BigDecimal和BigInteger文字，如：</p><pre><code class="java">104.39484B // BigDecimal8.4I // BigInteger</code></pre><h3 id="5-布尔常量"><a href="#5-布尔常量" class="headerlink" title="5. 布尔常量"></a>5. 布尔常量</h3><p>布尔型常量用保留关键字true和false来表示。</p><h3 id="6-空常量"><a href="#6-空常量" class="headerlink" title="6. 空常量"></a>6. 空常量</h3><p>用null或nil来表示。</p><h2 id="六、类型常量"><a href="#六、类型常量" class="headerlink" title="六、类型常量"></a>六、类型常量</h2><p>类型常量的处理方式与Java中的相同，格式为：”<packagename>.<classname>“。</classname></packagename></p><p>所以一个类可以这样限定：</p><pre><code class="java">java.util.HashMap</code></pre><p>或者如果类已经通过或者通过外部配置被导入，则它被简单地通过其非限定名称来引用：</p><pre><code class="java">HashMap</code></pre><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>嵌套类不能通过MVEL 2.0中的标准点表示法（如Java中）来访问。 相反，你必须用$符号限定这些类。</p><pre><code class="java">org.proctor.Person$BodyPart</code></pre><h2 id="七、流程控制"><a href="#七、流程控制" class="headerlink" title="七、流程控制"></a>七、流程控制</h2><p>MVEL的强大已经超出了简单的表达式。事实上，MVEL提供了一系列的程序流程控制操作符来方便你进行高级的脚本操作。</p><h3 id="1-If-Then-Else"><a href="#1-If-Then-Else" class="headerlink" title="1. If-Then-Else"></a>1. If-Then-Else</h3><p>MVEL提供了完整的C/Java式的if-then-else块，如：</p><pre><code class="java">if (var &gt; 0) {   System.out.println(&quot;Greater than zero!&quot;);} else if (var == -1) {    System.out.println(&quot;Minus one!&quot;);} else {    System.out.println(&quot;Something else!&quot;);}</code></pre><h3 id="2-三目运算符"><a href="#2-三目运算符" class="headerlink" title="2. 三目运算符"></a>2. 三目运算符</h3><p>其实就是Java中的条件表达式，如：</p><pre><code class="java">var &gt; 0 ? &quot;Yes&quot; : &quot;No&quot;;</code></pre><p>可以嵌套三目运算符</p><pre><code class="java">var &gt; 0 ? &quot;Yes&quot; : (var == -1 ? &quot;Minus One!&quot; : &quot;No&quot;)</code></pre><h3 id="3-Foreach"><a href="#3-Foreach" class="headerlink" title="3. Foreach"></a>3. Foreach</h3><p>MVEL的强大特性之一就是其Foreach操作符，在功能和语法上，他都类似于java1.5中的for each操作符，它接收用冒号隔开的两个参数，第一个是当前元素的一个域变量，而第二个是要迭代的集合或数组。如下所示：</p><pre><code class="java">count = 0;foreach (name : people) {   count++;   System.out.println(&quot;Person #&quot; + count + &quot;:&quot; + name);}System.out.println(&quot;Total people: &quot; + count);</code></pre><p>因为MVEL将字符串视作一个可以迭代的对象，所以你可以用foreach语句来迭代一个字符串（一个字符接一个字符的）：</p><pre><code class="java">str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;foreach (el : str) {   System.out.print(&quot;[&quot;+ el + &quot;]&quot;); }</code></pre><p>上面的示例将会输出：</p><pre><code class="java">[A][B][C][D][E][F][G][H][I][J][K][L][M][N][O][P][Q][R][S][T][U][V][W][X][Y][Z]</code></pre><p>你也可以利用MVEL进行计数（从1开始）：</p><pre><code class="java">foreach (x : 9) {    System.out.print(x);}</code></pre><p>这会输出：</p><pre><code class="java">123456789</code></pre><p><strong>注意：</strong>像java5.0一样，在MVEL2.0中，可以将foreach简化成关键字for来使用，如：</p><pre><code class="java">for (item : collection) { ... }</code></pre><h3 id="4-for循环"><a href="#4-for循环" class="headerlink" title="4. for循环"></a>4. for循环</h3><p>MVEL实现了标准的C语言的for循环：</p><pre><code class="java">for (int i =0; i &lt; 100; i++) {    System.out.println(i);}</code></pre><h3 id="5-Do-While-Do-Until"><a href="#5-Do-While-Do-Until" class="headerlink" title="5. Do While, Do Until"></a>5. Do While, Do Until</h3><p>和java中的意义一样，MVEL也实现了Do While,Do Until，While和Until意义正好相反。</p><pre><code class="java">do {    x = something();} while (x != null);</code></pre><p>在语义上相当于：</p><pre><code class="java">do {   x = something();}until (x == null);</code></pre><h3 id="6-While-Until"><a href="#6-While-Until" class="headerlink" title="6. While, Until"></a>6. While, Until</h3><p>MVEL中实现了标准的While，并添加了一个与之相反的Until。</p><pre><code class="java">while (isTrue()) {   doSomething();}</code></pre><p>或者写成</p><pre><code class="java">until (isFalse()) {   doSomething();}</code></pre><h2 id="八、投影和交集"><a href="#八、投影和交集" class="headerlink" title="八、投影和交集"></a>八、投影和交集</h2><p>简单地说，投影是一种描述集合的方式。 通过非常简单的语法，您可以检索集合中非常复杂的对象模型。</p><p>假设，你有一个User对象的集合。 每个对象都有一个Parent。 现在你想获得集合users中的所有parent的name的列表（假设Parent中有字段name），你可以这样来写：</p><pre><code class="java">parentNames = (parent.name in users);</code></pre><p>您甚至可以执行嵌套操作，假设，User对象有个集合成员叫做familyMembers，现在我们想获得一个所有家庭成员姓名的集合：</p><pre><code class="java">familyMembers = (name in (familyMembers in users));</code></pre><h2 id="九、赋值"><a href="#九、赋值" class="headerlink" title="九、赋值"></a>九、赋值</h2><p>MMVEL允许你对表达式中的变量进行赋值，以便在运行时获取，或在表达式内部使用。因为MVEL是动态类型语言，所以你不必为了声明一个变量而指定其类型。当然，你也可以选择指定。</p><pre><code class="java">str =“My String”; // validString str =“My String”; // valid</code></pre><p>与java语言不同的是，当给一个指定类型的变量赋值时，MVEL会提供自动的类型转换（可行的话），如：</p><pre><code class="java">String num = 1;assert num instanceof String＆amp;＆amp; num ==“1”;</code></pre><p>对于动态类型变量而言，你要想对其进行类型转换，你只需要将值转换成相应的类型既可：</p><pre><code class="java">num =（String）1;assert num instanceof String＆amp;＆amp; num ==“1”;</code></pre><h2 id="十、函数定义"><a href="#十、函数定义" class="headerlink" title="十、函数定义"></a>十、函数定义</h2><p>MVEL可以使用def或function关键字来定义本地函数。</p><p>函数必须是先声明后引用，唯一例外的是递归调用的时候。</p><h3 id="1-一个简单示例"><a href="#1-一个简单示例" class="headerlink" title="1. 一个简单示例"></a>1. 一个简单示例</h3><p>定义一个简单函数：</p><pre><code class="java">def hello() { System.out.println(&quot;Hello!&quot;); }</code></pre><p>定义了一个没有参数的函数<code>hello</code>.当调用该函数时会在控制台打印”Hello!” 一个MVEL定义的函数就像任何常规的方法调用。</p><pre><code class="java">hello(); // 调用函数</code></pre><h3 id="2-传参和返回值"><a href="#2-传参和返回值" class="headerlink" title="2. 传参和返回值"></a>2. 传参和返回值</h3><p>函数可以接收参数和返回一个值，看下面的示例：</p><pre><code class="java">def addTwo(a, b) {    a + b;}</code></pre><p>这个函数会接收两个参数(a和b)，然后将这两个变量相加。因为MVEL遵循last-value-out原则，所以结果将会被返回。因此，你可以这样来使用这个函数：</p><pre><code class="java">val = addTwo(5, 2);assert val == 10;</code></pre><p>当然，也可以使用return关键字来强制从程序内部返回一个函数值。</p><h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h3><p>MVEL支持闭包,然而其功能与本地java函数没有任何关联。</p><pre><code class="java">// 定义一个接收一个参数的函数def someFunction(f_ptr) { f_ptr(); }// 定义变量avar a = 10;// 传递函数闭包someFunction(def { a * 10 });</code></pre><h2 id="十一、Lambda表达式"><a href="#十一、Lambda表达式" class="headerlink" title="十一、Lambda表达式"></a>十一、Lambda表达式</h2><p>MVEL允许定义Lambda方法，如下所示：</p><pre><code class="java">threshold = def (x) { x &gt;= 10 ? x : 0 };result = cost + threshold(lowerBound);</code></pre><p>上面的例子定义了一个Lambda，并将其赋值给变量”threshold”.Lambda实质上就是一个用来给变量赋值的函数，也是闭包。</p><p>翻译原文：<a href="http://mvel.documentnode.com/" target="_blank" rel="noopener">http://mvel.documentnode.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MVEL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring基础介绍</title>
      <link href="/2018/09/17/hou-duan/java/spring-ji-chu-jie-shao/"/>
      <url>/2018/09/17/hou-duan/java/spring-ji-chu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring-概述"><a href="#一、Spring-概述" class="headerlink" title="一、Spring 概述"></a>一、Spring 概述</h2><h3 id="（一）Spring-的简史"><a href="#（一）Spring-的简史" class="headerlink" title="（一）Spring 的简史"></a>（一）Spring 的简史</h3><p><a href="https://spring.io/" target="_blank" rel="noopener">Spring</a> 的历史网上有很多的介绍，下面是 Spring 发展历程的一个简介。</p><h4 id="1-第一阶段：xml-配置"><a href="#1-第一阶段：xml-配置" class="headerlink" title="1. 第一阶段：xml 配置"></a>1. 第一阶段：xml 配置</h4><p>在 Spring 1.x 时代，使用 Spring 开发满眼都是 xml 配置的 Bean，随着项目的扩大，我们需要把 xml 配置文件放到不同的配置文件里，那时候需要频繁地在开发的类和配置文件之间切换。</p><h4 id="2-第二阶段：注解配置"><a href="#2-第二阶段：注解配置" class="headerlink" title="2. 第二阶段：注解配置"></a>2. 第二阶段：注解配置</h4><p>在 Spring 2.x 时代，随着 JDK 1.5 带来的注解支持，Spring 提供了声明 Bean 的注解（如：@Component、@Service），大大减少了配置量。这时 Spring 圈子里存在着一种争论：注解配置和 xml 配置究竟哪个更好？我们最终的选择是应用的基本配置（如：数据库配置）用 xml，业务配置用注解。</p><h4 id="3-第三阶段：Java-配置"><a href="#3-第三阶段：Java-配置" class="headerlink" title="3. 第三阶段：Java 配置"></a>3. 第三阶段：Java 配置</h4><p>从 Spring 3.x 到现在，Spring 提供了 Java 配置的能力，使用 Java 配置可以让你更理解你配置的 Bean。我们目前刚好处于这个时代，Spring 4.x 和 Spring Boot 都推荐使用 Java 配置。</p><h3 id="（二）Spring-概述"><a href="#（二）Spring-概述" class="headerlink" title="（二）Spring 概述"></a>（二）Spring 概述</h3><p>Spring 框架是一个轻量级的企业级开发的一站式解决方案。所谓解决方案就是可以基于 Spring 解决 JavaEE 开发的所有问题。Spring 框架主要提供了<code>IoC</code>容器、AOP、数据访问、Web 开发、消息、测试等相关技术的支持。</p><p>Spring 使用简单的 POJO（<code>Plain Old Java Object</code>，即无任何限制的普通Java对象）来进行企业级开发。每一个被 Spring 管理的 Java 对象都被称之为 Bean；而 Spring 提供了一个 IoC 容器用来初始化对象，解决对象间的依赖管理和对象的使用。</p><h4 id="1-Spring-的模块"><a href="#1-Spring-的模块" class="headerlink" title="1. Spring 的模块"></a>1. Spring 的模块</h4><p>Spring 是模块化的，这意味着你可以只使用你需要的Spring的模块。如下图所示：</p><p><img src="http://static.blinkfox.com/spring_moudle.png" alt="Spring 模块"></p><p>图中的每个最小单元，Spring 都至少有一个对应的 jar 包。</p><h5 id="（1）核心容器（Core-Contariner）"><a href="#（1）核心容器（Core-Contariner）" class="headerlink" title="（1）核心容器（Core Contariner）"></a>（1）核心容器（Core Contariner）</h5><ul><li>Spring-Core：核心工具类，Spring 其他模块大量使用 Spring-Core</li><li>Spring-Beans：Spring 定义 Bean 的支持</li><li>Spring-Context：运行时 Spring 容器</li><li>Spring-Context-Support：容器对第三方包的集成支持</li><li>Spring-Expression：使用表达式语言在运行时查询和操作对象</li></ul><h5 id="（2）AOP"><a href="#（2）AOP" class="headerlink" title="（2）AOP"></a>（2）AOP</h5><ul><li>Spring-AOP：基于代理的 AOP 支持</li><li>Spring-Aspects：基于 AspectJ 的 AOP 支持</li></ul><h5 id="（3）消息（Messaging）"><a href="#（3）消息（Messaging）" class="headerlink" title="（3）消息（Messaging）"></a>（3）消息（Messaging）</h5><ul><li>Spring-Messaging：对消息架构和协议的支持</li></ul><h5 id="（4）Web"><a href="#（4）Web" class="headerlink" title="（4）Web"></a>（4）Web</h5><ul><li>Spring-Web：提供基础的 Web 集成的功能，在 Web 项目中提供 Spring 的容器</li><li>Spring-Webmvc：提供基于 Servlet 的 Spring MVC</li><li>Spring-WebSocket：提供 WebSocket 功能</li><li>Spring-Webmvc-Portlet：提供 Portlet 环境功能</li></ul><h5 id="（5）数据访问-集成（Data-Access-Integration）"><a href="#（5）数据访问-集成（Data-Access-Integration）" class="headerlink" title="（5）数据访问/集成（Data Access/Integration）"></a>（5）数据访问/集成（Data Access/Integration）</h5><ul><li>Spring-JDBC：提供以 JDBC 访问数据库的支持</li><li>Spring-TX：提供编程式和声明式的事务支持</li><li>Spring-ORM：提供对对象/关系映射技术的支持</li><li>Spring-OXM：提供对对象/xml 映射技术的支持</li><li>Spring-JMS：提供对 JMS 的支持</li></ul><h4 id="1-Spring-的生态"><a href="#1-Spring-的生态" class="headerlink" title="1. Spring 的生态"></a>1. Spring 的生态</h4><p>Spring 发展到现在已经不仅仅是 Spring 框架本身的内容，Spring 目前提供了大量的基于 Spring 的项目，可以用来更深入地降低我们的开发难度，提高开发效率。<br>目前 Spring 的生态里主要有以下项目，我们可以根据自己项目的需要来选择使用相应的项目。</p><ul><li>Spring Boot：使用默认开发配置来实现快速开发</li><li>Spring XD：用来简化大数据应用开发</li><li>Spring Cloud：为分布式系统开发提供工具集</li><li>Spring Data：对主流关系型和 NoSQL 数据库的支持</li><li>Spring Integration：通过消息机制对企业集成模式（EIP）的支持</li><li>Spring Batch：简化及优化大量数据的批处理操作</li><li>Spring Security：通过认证和授权保护应用</li><li>Spring HATEOAS：基于 HATEOAS 原则简化 REST 服务开发</li><li>Spring Social：与社交网络 API（如：Facebook、新浪微博等）的集成</li><li>Spring AMQP：对基于 AMQP 的消息的支持</li><li>Spring Mobile：提供对手机设备检测的功能，给不同的设备返回不同的页面的功能</li><li>Spring for Android：主要提供在 Android 上消费 RESTful API 的功能</li><li>Spring Web Flow：基于 SpringMVC 提供基于向导流程式的 Web 应用开发</li><li>Spring Web Services：提供了基于协议有限的 SOAP/Web 服务</li><li>Spring LDAP：简化使用 LDAP 开发</li><li>Spring Session：提供一个 API 及实现来管理用户会话信息</li></ul><h2 id="二、Spring-项目快速搭建"><a href="#二、Spring-项目快速搭建" class="headerlink" title="二、Spring 项目快速搭建"></a>二、Spring 项目快速搭建</h2><p>这里我们使用目前 Java 主流的项目构建工具<a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven</a>来搭建项目。</p><h3 id="（一）Maven-介绍"><a href="#（一）Maven-介绍" class="headerlink" title="（一）Maven 介绍"></a>（一）Maven 介绍</h3><p>Apache Maven 是一个基于项目对象模型（Project Object Model，POM）的软件项目管理工具。Maven 可用来管理项目的依赖、编译、打包、文档等信息。使用 Maven 来管理项目时，项目依赖的 jar 包将不再包含在项目内，而是集中放置在用户目录下的 .m2 文件夹下。关于 Maven 的详细安装介绍可参考<a href="http://blinkfox.com/linux-debianxia-mavende-an-zhuang-he-shi-yong/" target="_blank" rel="noopener">这里</a>。</p><h3 id="（二）创建项目"><a href="#（二）创建项目" class="headerlink" title="（二）创建项目"></a>（二）创建项目</h3><p>在创建项目之前，须确保你的计算机上已经安装好有 Java 和 Maven 环境。然后，打开终端通过以下简单的命令就可以在你的当前目录下创建一个 Jave web 的项目结构：</p><pre><code class="bash">mvn archetype:generate -DgroupId=com.blinkfox -DartifactId=springdemo -DpackageName=com.blinkfox.springdemo -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</code></pre><p>其中<code>-DgroupId=com.blinkfox</code>是组织名，<code>-DartifactId=springdemo</code>是该组织下的项目名称，<code>-DarchetypeArtifactId=maven-archetype-webapp</code>代表创建一个简单的 webapp 项目。</p><p>创建项目的时候，Maven会自动下载一些需要用到的 jar 包和 Maven 插件。如果顺利创建成功的话，就会在你的当前目录下看到名为 springdemo 的项目，其中包含<code>src</code>的文件夹和<code>pom.xml</code>文件。且在你的终端会看到如下输出：</p><p><img src="http://static.blinkfox.com/maven_build_project.png" alt="Maven创建项目成功"></p><h3 id="（三）添加-Spring-依赖"><a href="#（三）添加-Spring-依赖" class="headerlink" title="（三）添加 Spring 依赖"></a>（三）添加 Spring 依赖</h3><p>接下来需要通过修改 pom.xml 来添加 Spring 的依赖，添加编译插件，且将编译级别设置为1.7，pom.xml文件的修改如下：</p><pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.blinkfox&lt;/groupId&gt;    &lt;artifactId&gt;springdemo&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springdemo Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;properties&gt;        &lt;java.version&gt;1.7&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;springdemo&lt;/finalName&gt;        &lt;!-- 指定maven的默认操作为 --&gt;        &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;${java.version}&lt;/source&gt;                    &lt;target&gt;${java.version}&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="三、Spring-基础配置"><a href="#三、Spring-基础配置" class="headerlink" title="三、Spring 基础配置"></a>三、Spring 基础配置</h2><p>Spring 框架本身有四大原则：</p><ul><li>使用 POJO 进行轻量级和最小侵入式开发</li><li>通过依赖注入和面向接口编程来实现松耦合</li><li>通过 AOP 和默认习惯进行声明式编程</li><li>使用 AOP 和模板(template)减少模式化代码</li></ul><p>Spring 的所有功能设计和实现都是基于此四大原则。</p><h3 id="（一）依赖注入"><a href="#（一）依赖注入" class="headerlink" title="（一）依赖注入"></a>（一）依赖注入</h3><h4 id="1-重点说明"><a href="#1-重点说明" class="headerlink" title="1. 重点说明"></a>1. 重点说明</h4><p>我们经常说的控制反转（Inversion of Control，IoC）和依赖注入（dependency injection，DI）在 Spring 环境下是等同的概念，控制反转是通过依赖注入实现的。所谓依赖注入指的是容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。</p><p>依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。如果你希望你的类具备某项功能的时候，是继承自一个具有此功能的父类好呢？还是组合另外一个具有这个功能的类好呢？答案是不言而喻的，继承一个父类，之类将与父类耦合，组合另外一个类则使耦合度大大降低。</p><p>Spring IoC 容器（ApplicationContext）负责创建 Bean，并通过容器将功能类 Bean 注入到你需要的 Bean 中。Spring 提供使用 xml、注解、Java 配置、groovy 配置实现 Bean 的创建和注入。</p><p>无论是 xml 配置、注解配置还是 Java 配置，都被称为配置元数据，所谓元数据即描述数据的数据。元数据本身不具备任何可执行的能力，只能通过外界代码来对这些元数据行解析后进行一些有意义操作。Spring 容器解析这些配置元数据进行 Bean 初始化、配置和管理依赖。</p><p>声明 Bean 的注解：</p><ul><li><code>@Component</code>: 组件，没有明确角色</li><li><code>@Controller</code>: 在展现层（MVC -&gt; Spring MVC）使用</li><li><code>@Service</code>: 在业务逻辑层（service层）使用</li><li><code>@Repository</code>: 在数据访问层（dao层）使用</li></ul><p>注入 Bean 的注解，一般情况下通用：</p><ul><li><code>@Autowired</code>: Spring 提供的注解</li><li><code>@Inject</code>: JSR-330 提供的注解</li><li><code>@Resource</code>: JSR-250 提供的注解</li></ul><p><code>@Autowired</code>、<code>@Inject</code>、<code>@Resource</code>可注解在 set 方法上或者属性上，推荐注解在属性上，优点是代码更少、层次更清晰。</p><h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h4><p>（1）编写功能类的 Bean。</p><pre><code class="java">package com.blinkfox.service.impl;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/27. */@Servicepublic class FunctionService {    public String sayHello(String word) {        return &quot;Hello &quot; + word + &quot;!&quot;;    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Service 注解声明当前 FunctionService 类是 Spring 管理的一个 Bean。其中，使用 @Component、@Service、@Repository、@Controller 是等效的，可根据需要选用。</li></ol></blockquote><p>（2）使用功能类的 Bean。</p><pre><code class="java">package com.blinkfox.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/27. */@Servicepublic class UseFunctionService {    @Autowired    private FunctionService functionService;    public String sayHello(String word) {        return functionService.sayHello(word);    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Service 注解声明当前 UseFunctionService 类是 Spring 管理的一个 Bean。</li><li>使用 @Autowired 将 FunctionService 的实体 Bean 注入到 UseFunctionService 中，让 UseFunctionService 具备 FunctionService 的功能，此处使用 JSR-330 的 @Inject 注解或者 JSR-250 的 @Resource 注解是等效的。</li></ol></blockquote><p>（3）配置类。</p><pre><code class="java">package com.blinkfox.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * Created by blinkfox on 2016/10/27. */@Configuration@ComponentScan(&quot;com.blinkfox.service.impl&quot;)public class DiConfig {}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Configuration 注解声明当前类是一个配置类。</li><li>使用 @ComponentScan 将 自动扫描包名下所有使用的 @Component、@Service、@Repository、@Controller 类，并注册为 Bean。</li></ol></blockquote><p>（4）运行。</p><pre><code class="java">package com.blinkfox.maintest;import com.blinkfox.config.DiConfig;import com.blinkfox.service.impl.UseFunctionService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * Created by blinkfox on 2016/10/27. */public class FunctionMain {    public static void main(String[] args) {        AnnotationConfigApplicationContext context =                new AnnotationConfigApplicationContext(DiConfig.class);        UseFunctionService useFunctionService = context.getBean(UseFunctionService.class);        System.out.println(useFunctionService.sayHello(&quot;Spring&quot;));        context.close();    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 AnnotationConfigApplicationContext 作为 Spring 容器，接收使用一个配置类作为参数。</li><li>获得声明配置的 UseFunctionService 的 Bean。</li></ol></blockquote><h3 id="（二）Java-配置"><a href="#（二）Java-配置" class="headerlink" title="（二）Java 配置"></a>（二）Java 配置</h3><h4 id="1-重点说明-1"><a href="#1-重点说明-1" class="headerlink" title="1. 重点说明"></a>1. 重点说明</h4><p>Java 配置是 Spring4.x 推荐的配置方式，可以完全替代 xml 配置；Java 配置也是 Spring Boot 推荐的配置方式。</p><p>Java 配置是通过 @Configuration 和 @Bean 来实现的。</p><ul><li>@Configuration 声明当前类是一个配置类，相当于一个Spring配置的 xml 文件。</li><li>@Bean 注解在方法上，声明当前方法的返回值是一个 Bean。</li></ul><p>何时使用 Java 配置或者注解配置呢？我们主要的原则是：全局配置使用 Java 配置（如数据库相关配置、MVC相关配置），业务 Bean 的配置使用注解配置（@Service、@Component、@Repository、@Controller）。</p><h4 id="2-Java配置代码示例"><a href="#2-Java配置代码示例" class="headerlink" title="2. Java配置代码示例"></a>2. Java配置代码示例</h4><p>（1）编写功能类的 Bean</p><pre><code class="java">package com.blinkfox.service.impl;/** * Created by blinkfox on 2016/10/27. */// 1public class JavaConfigService {    public String sayHello(String word) {        return &quot;Hello &quot; + word + &quot;!&quot;;    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>此处没有使用 @Service 声明 Bean。</li></ol></blockquote><p>（2）使用功能类的 Bean</p><pre><code class="java">package com.blinkfox.service.impl;/** * Created by blinkfox on 2016/10/27. */// 1public class UseJavaConfigService {    // 2    private JavaConfigService javaConfigService;    public void setJavaConfigService(JavaConfigService javaConfigService) {        this.javaConfigService = javaConfigService;    }    public String sayHello(String word) {        return javaConfigService.sayHello(word);    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>此处没有使用 @Service 声明 Bean。</li><li>此处没有使用 @Autowired 注解注入 Bean。</li></ol></blockquote><p>（3）Java 配置类</p><pre><code class="java">package com.blinkfox.config;import com.blinkfox.service.impl.JavaConfigService;import com.blinkfox.service.impl.UseJavaConfigService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Created by blinkfox on 2016/10/27. */@Configuration // 1public class JavaConfig {    @Bean  // 2    public JavaConfigService javaConfigService() {        return new JavaConfigService();    }    @Bean    public UseJavaConfigService useJavaConfigService() {        UseJavaConfigService useJavaConfigService = new UseJavaConfigService();        useJavaConfigService.setJavaConfigService(javaConfigService()); // 3        return useJavaConfigService;    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @Configuration 注解表明当前类是一个配置类，这意味着这个类型里可能有0个或者多个 @Bean 注解，此处没有使用包扫描，是因为所有的 Bean 都在此类中定义了。</li><li>使用 @Bean 注解声明当前方法 JavaConfigService 的返回值是一个 Bean，Bean的名称是方法名。</li><li>注入 FunctionService 的 Bean 时候直接调用 javaConfigService()。</li></ol></blockquote><p>（4）运行</p><pre><code class="java">package com.blinkfox.maintest;import com.blinkfox.config.JavaConfig;import com.blinkfox.service.impl.UseJavaConfigService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * Created by blinkfox on 2016/10/27. */public class JavaConfigMain {    public static void main(String[] args) {        AnnotationConfigApplicationContext context =                new AnnotationConfigApplicationContext(JavaConfig.class);        UseJavaConfigService useJavaConfigService = context.getBean(UseJavaConfigService.class);        System.out.println(useJavaConfigService.sayHello(&quot;Spring Java Config&quot;));        context.close();    }}</code></pre><h3 id="（三）AOP"><a href="#（三）AOP" class="headerlink" title="（三）AOP"></a>（三）AOP</h3><h4 id="1-重点说明-2"><a href="#1-重点说明-2" class="headerlink" title="1. 重点说明"></a>1. 重点说明</h4><p>AOP：面向切面编程，是面向对象编程（OOP）的补充。</p><p>Spring 的 AOP 的存在目的是为了解耦。AOP 可以让一组类共享相同的行为。在 OOP 中只能通过继承和实现接口来共享相同的行为，从而使代码的耦合度增强，且类继承只能为单继承，阻碍更多行为添加到一组类上，AOP 弥补了 OOP 的不足。</p><p>Spring 支持 AspectJ 的注解式切面编程。</p><ul><li>使用 @AspectJ 声明是一个切面。</li><li>使用 @After、@Before、Around 定义通知（advice）类型，可直接将拦截规则（切点）作为参数。</li><li>其中 @After、@Before、Around 参数的拦截规则为切点（PointCut），为了使切点复用，可使用 @PointCut 专门定义拦截规则，然后在 @After、@Before、Around 的参数中调用。</li><li>其中符合条件的每一个拦截处为连接点（JoinPoint）。</li></ul><p>Spring本身在事务处理（@Transcational）和数据缓存（@Cacheable）等都使用注解拦截。下面示例将演示基于注解和方法规则的拦截方式，演示一种模拟记录操作的日志系统的实现。</p><h4 id="2-注解拦截代码示例"><a href="#2-注解拦截代码示例" class="headerlink" title="2. 注解拦截代码示例"></a>2. 注解拦截代码示例</h4><p>（1）添加 Spring aop 支持及 AspectJ 依赖。</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;4.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;    &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>（2）编写拦截规则的注解。</p><pre><code class="java">package com.blinkfox.annotation;import java.lang.annotation.*;/** * Created by blinkfox on 2016/10/29. */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LogAction {    String name() default &quot;这是默认的操作名称&quot;;}</code></pre><blockquote><p><strong>代码解释</strong>：<br>注解本身是没有功能的，就和 xml 一样。注解和 xml 都是一种元数据，元数据即解释数据的数据，这就是所谓的配置。注解的功能来自用这个注解的地方。</p></blockquote><p>（3）编写使用注解的被拦截类。</p><pre><code class="java">package com.blinkfox.service.impl;import com.blinkfox.annotation.LogAction;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/29. */@Servicepublic class DemoAnnotationService {    @LogAction(name = &quot;注解式拦截的 add 操作&quot;)    public void add() {    }}</code></pre><p>（4）编写使用方法规则被拦截规类。</p><pre><code class="java">package com.blinkfox.service.impl;import org.springframework.stereotype.Service;/** * Created by blinkfox on 2016/10/29. */@Servicepublic class DemoMethodService {    public void add() {    }}</code></pre><p>（5）编写切面。</p><pre><code class="java">package com.blinkfox.aop;import com.blinkfox.annotation.LogAction;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import java.lang.reflect.Method;/** * Created by blinkfox on 2016/10/29. */@Aspect // 1@Component // 2public class LogAspect {    @Pointcut(&quot;@annotation(com.blinkfox.annotation.LogAction)&quot;) // 3    public void annotationPointCut() {    }    @After(&quot;annotationPointCut()&quot;) // 4    public void after(JoinPoint joinPoint) {        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        Method method = signature.getMethod();        LogAction logAction = method.getAnnotation(LogAction.class);        System.out.println(&quot;---注解式拦截:&quot; + logAction.name()); // 5    }    @After(&quot;execution(* com.blinkfox.service.impl.DemoMethodService.*(..))&quot;) // 6    public void before(JoinPoint joinPoint) {        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        Method method = signature.getMethod();        System.out.println(&quot;---方法规则式拦截:&quot; + method.getName());    }}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>通过 @Aspect 注解声明一个切面。</li><li>通过 @Component 让此切面成为 Spring 容器管理的Bean。</li><li>通过 @PointCut 注解声明切点。</li><li>通过 @After 注解声明一个通知类型，并使用 @PointCut定义的切点。</li><li>通过可获得注解上的属性，然后做日志记录相关的操作，下面相同。</li><li>通过 @Before 注解声明一个通知类型，此通知直接使用拦截规则作为参数。</li></ol></blockquote><p>（6）配置类。</p><pre><code class="java">package com.blinkfox.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;/** * Created by blinkfox on 2016/10/29. */@Configuration@ComponentScan(&quot;com.blinkfox&quot;)@EnableAspectJAutoProxypublic class AopConfig {}</code></pre><blockquote><p><strong>代码解释</strong>：</p><ol><li>使用 @EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ的支持。</li></ol></blockquote><p>（6）运行。</p><pre><code class="java">package com.blinkfox.maintest;import com.blinkfox.config.AopConfig;import com.blinkfox.service.impl.DemoAnnotationService;import com.blinkfox.service.impl.DemoMethodService;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * Created by blinkfox on 2016/10/29. */public class AopMain {    public static void main(String[] args) {        AnnotationConfigApplicationContext context =                new AnnotationConfigApplicationContext(AopConfig.class);        DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class);        DemoMethodService demoMethodService = context.getBean(DemoMethodService.class);        demoAnnotationService.add();        demoMethodService.add();        context.close();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之工厂方法模式</title>
      <link href="/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-gong-han-fang-fa-mo-shi/"/>
      <url>/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><p>工厂方法模式(<code>Factory Method Pattern</code>)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/FactoryMethod.jpg" alt="工厂方法模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="http://static.blinkfox.com/seq_FactoryMethod.jpg" alt="工厂方法模式时序图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是抽象的产品类和具体的产品类：</p><pre><code class="java">/** * 抽象产品类 * Created by blinkfox on 16-6-29. */public abstract class Product {    /**     * 产品类的公共方法     */    public void method1() {        System.out.println(&quot;这是产品类的公共方法&quot;);    }    /**     * 抽象方法     */    public abstract void method2();}</code></pre><pre><code class="java">/** * 具体产品类1 * Created by blinkfox on 16-6-29. */public class ConcreteProduct1 extends Product {    @Override    public void method2() {        System.out.println(&quot;ConcreteProduct1的method2方法&quot;);    }}</code></pre><pre><code class="java">/** * 具体产品类2 * Created by blinkfox on 16-6-29. */public class ConcreteProduct2 extends Product {    @Override    public void method2() {        System.out.println(&quot;ConcreteProduct2的method2方法&quot;);    }}</code></pre><p>然后，是抽象的工厂类和具体的工厂类：</p><pre><code class="java">/** * 抽象的工厂类 * Created by blinkfox on 16-6-29. */public abstract class Factory {    /**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T&gt;     * @return     */    public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);}</code></pre><pre><code class="java">/** * 具体生产产品的工厂类 * Created by blinkfox on 16-6-29. */public class ConcreteFactory extends Factory {    /**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T&gt;     * @return     */    @Override    public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) {        Product product = null;        try {            product = (Product) Class.forName(c.getName()).newInstance();        } catch (Exception e) {            System.out.println(&quot;生产产品出错&quot;);            e.printStackTrace();        }        return (T) product;    }}</code></pre><p>最后，是客户端场景类：</p><pre><code class="java">/** * 工厂方法模式客户端场景类 * Created by blinkfox on 16-6-29. */public class Client {    public static void main(String[] args) {        Factory factory = new ConcreteFactory();        Product product1 = factory.createProduct(ConcreteProduct1.class);        product1.method1();        product1.method2();        Product product2 = factory.createProduct(ConcreteProduct2.class);        product2.method1();        product2.method2();    }}</code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>工厂方法模式的优点：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>工厂方法模式的缺点：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="五、模式扩展"><a href="#五、模式扩展" class="headerlink" title="五、模式扩展"></a>五、模式扩展</h2><p>工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：</p><pre><code class="java">/** * 简单工厂模式中的工厂类 * Created by blinkfox on 16-6-29. */public class SimpleFactory {    /**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T&gt;     * @return     */    public static  &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) {        Product product = null;        try {            product = (Product) Class.forName(c.getName()).newInstance();        } catch (Exception e) {            System.out.println(&quot;生产产品出错&quot;);            e.printStackTrace();        }        return (T) product;    }}</code></pre><pre><code class="java">/** * 简单工厂模式客户端场景类 * Created by blinkfox on 16-6-29. */public class SimpleClient {    public static void main(String[] args) {        Product product1 = SimpleFactory.createProduct(ConcreteProduct1.class);        product1.method1();        product1.method2();        Product product2 = SimpleFactory.createProduct(ConcreteProduct2.class);        product2.method1();        product2.method2();    }}</code></pre><p>运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。</p><h3 id="2-多工厂类工厂方法模式"><a href="#2-多工厂类工厂方法模式" class="headerlink" title="2. 多工厂类工厂方法模式"></a>2. 多工厂类工厂方法模式</h3><p>当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：</p><p>多工厂模式的抽象工厂类：</p><pre><code class="java">/** * 生成多个产品的抽象工厂类 * Created by blinkfox on 16-7-2. */public abstract class MultiFactory {    /**     * 生成某种产品的方法     * @return     */    public abstract Product createProduct();}</code></pre><p>第一种产品的创建工厂实现：</p><pre><code class="java">/** * 生成产品1的具体工厂类1 * Created by blinkfox on 16-7-2. */public class ConcreteFactory1 extends MultiFactory {    /**     * 生成产品1的方法     * @return     */    @Override    public Product createProduct() {        return new ConcreteProduct1();    }}</code></pre><p>第二种产品的创建工厂实现：</p><pre><code class="java">/** * 生成产品2的具体工厂类2 * Created by blinkfox on 16-7-2. */public class ConcreteFactory2 extends MultiFactory {    /**     * 生成产品2的方法     * @return     */    @Override    public Product createProduct() {        return new ConcreteProduct2();    }}</code></pre><p>多工厂模式的客户端场景类</p><pre><code class="java">/** * 多工厂方法模式客户端场景类 * Created by blinkfox on 16-7-2. */public class MultiClient {    public static void main(String[] args) {        Product concreteProduct1 = (new ConcreteFactory1()).createProduct();        concreteProduct1.method1();        concreteProduct1.method2();        Product concreteProduct2 = (new ConcreteFactory2()).createProduct();        concreteProduct1.method1();        concreteProduct1.method2();    }}</code></pre><h3 id="3-工厂方法的单例模式"><a href="#3-工厂方法的单例模式" class="headerlink" title="3. 工厂方法的单例模式"></a>3. 工厂方法的单例模式</h3><p>单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。</p><p>下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下：</p><pre><code class="java">/** * 工厂方法模式中的单例类 * Created by blinkfox on 16-7-4. */public class Singleton {    /**     * 私有化构造方法，不允许new产生一个对象     */    private Singleton() {}    /**     * 工厂方法模式中的单例模式业务方法     */    public void doSomething() {        System.out.println(&quot;工厂方法模式中的单例模式方法。。。&quot;);    }}</code></pre><p>以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：</p><pre><code class="java">/** * 生成单例的工厂类 * Created by blinkfox on 16-7-4. */public class SingletonFactory {    private static Singleton singleton;    static {        try {            Class c = Class.forName(Singleton.class.getName());            // 获得无参构造            Constructor constructor = c.getDeclaredConstructor();            // 设置无参构造是可访问的            constructor.setAccessible(true);            // 产生一个实例对象            singleton = (Singleton) constructor.newInstance();        } catch (Exception e) {            e.printStackTrace();            System.out.println(&quot;生成单例的工厂类方法中生成单例出错&quot;);zuihou        }    }    public static Singleton getSingleton() {        return singleton;    }}</code></pre><p>最后是工厂方法单例模式的客户端场景类：</p><pre><code class="java">/** * 工厂方法单例模式客户端场景类 * Created by blinkfox on 16-7-4. */public class SingleClient {    public static void main(String[] args) {        Singleton singleton = SingletonFactory.getSingleton();        singleton.doSomething();    }}</code></pre><h3 id="4-工厂方法的延迟初始化"><a href="#4-工厂方法的延迟初始化" class="headerlink" title="4. 工厂方法的延迟初始化"></a>4. 工厂方法的延迟初始化</h3><p>何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：</p><pre><code class="java">/** * 延迟加载的工厂类 * Created by blinkfox on 16-7-4. */public class LazyFactory {    private static final Map&lt;String, Product&gt; lazyMap = new HashMap&lt;String, Product&gt;();    public static synchronized Product createProduct(String type) {        Product product = null;        // 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中        if (lazyMap.containsKey(type)) {            return lazyMap.get(type);        }        // 根据类型创建具体的产品对象        if (&quot;product1&quot;.equals(type)) {            product = new ConcreteProduct1();        } else {            product = new ConcreteProduct2();        }        // 同时把对象放到缓存容器中        lazyMap.put(&quot;type&quot;, product);        return product;    }}</code></pre><p>上面即为延迟加载的工厂类。代码比较简单，通过定义一个<code>map</code>容器来容纳所有产生的对象，如果在<code>map</code>容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到<code>map</code>容器中，以便下次调用。</p><p>延迟加载的工厂模式客户端场景类代码如下：</p><pre><code class="java">/** * 延迟加载的工厂模式客户端场景类 * Created by blinkfox on 16-7-4. */public class LazyClient {    public static void main(String[] args) {        Product product1 = LazyFactory.createProduct(&quot;product1&quot;);        Product product11 = LazyFactory.createProduct(&quot;product1&quot;);    }}</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之装饰模式</title>
      <link href="/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-shi-mo-shi/"/>
      <url>/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p><strong>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。<strong>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><p>策略模式是一种<strong>对象结构型</strong>模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>装饰模式包含如下角色：</p><ul><li><code>Component</code>: 抽象构件</li><li><code>ConcreteComponent</code>: 具体构件</li><li><code>Decorator</code>: 抽象装饰类</li><li><code>ConcreteDecorator</code>: 具体装饰类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Decorator.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/seq_Decorator.jpg" alt="装饰模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个抽象构件接口：</p><pre><code class="java">/** * 抽象构件 * Created by blinkfox on 16-6-26. */public interface Component {    // 接口方法    void operate();}</code></pre><p>然后是具体构件实现类：</p><pre><code class="java">/** * 具体构件 * Created by blinkfox on 16-6-26. */public class ConcreteComponent implements Component {    /**     * 具体实现方法     */    @Override    public void operate() {        System.out.println(&quot;do Something...&quot;);    }}</code></pre><p>接着是装饰角色：</p><pre><code class="java">/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * Created by blinkfox on 16-6-26. */public class Decorator implements Component {    private Component component;    /**     * 通过构造函数传递被修饰者     * @param component     */    public Decorator(Component component) {        this.component = component;    }    /**     * 委托给被修饰者执行     */    @Override    public void operate() {        this.component.operate();    }}</code></pre><p>下面是具体的装饰类：</p><pre><code class="java">/** * 具体的装饰类1 * Created by blinkfox on 16-6-26. */public class ConcreteDecorator1 extends Decorator {    /**     * 通过构造函数传递被修饰者     * @param component     */    public ConcreteDecorator1(Component component) {        super(component);    }    /**     * 定义自己的修饰方法1     */    private void method1() {        System.out.println(&quot;method1修饰...&quot;);    }    /**     * 重写父类的operate方法     */    public void operate() {        this.method1();        super.operate();    }}</code></pre><pre><code class="java">/** * 具体的装饰类2 * Created by blinkfox on 16-6-26. */public class ConcreteDecorator2 extends Decorator {    /**     * 通过构造函数传递被修饰者     * @param component     */    public ConcreteDecorator2(Component component) {        super(component);    }    /**     * 定义自己的修饰方法2     */    private void method2() {        System.out.println(&quot;method2修饰...&quot;);    }    /**     * 重写父类的operate方法     */    public void operate() {        this.method2();        super.operate();    }}</code></pre><p>最后是客户端的场景类：</p><pre><code class="java">/** * 装饰模式的客户端场景类 * Created by blinkfox on 16-6-26. */public class Client {    public static void main(String[] args) {        Component component = new ConcreteComponent();        // 第一修饰        component = new ConcreteDecorator1(component);        // 第二修饰        component = new ConcreteDecorator2(component);        // 修饰后运行        component.operate();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li><strong>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，<em>关联关系的缺点是比继承关系要创建更多的对象</em>。</li><li><strong>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的缺点：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面向对象设计之策略模式</title>
      <link href="/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ce-lue-mo-shi/"/>
      <url>/2018/09/14/ruan-jian-she-ji/she-ji-mo-shi/java-mian-xiang-dui-xiang-she-ji-zhi-ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以<strong>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</strong>。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</strong>。</p></blockquote><p>策略模式是一种对象行为型模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Strategy1.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/strategy2.jpg" alt="策略模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个策略接口：</p><pre><code class="java">public interface IStrategy {    /**     * 策略模式的运算法则     */    public void doSomething();}</code></pre><p>然后是具体的策略实现类：</p><pre><code class="java">public class ConcreteStrategy1 implements IStrategy {    @Override    public void doSomething() {        System.out.println(&quot;具体策略的策略方法1&quot;);    }}</code></pre><pre><code class="java">public class ConcreteStrategy2 implements IStrategy {    @Override    public void doSomething() {        System.out.println(&quot;具体策略的策略方法2&quot;);    }}</code></pre><p>接着是封装角色的类：</p><pre><code class="java">public class Context {    // 抽象策略    private IStrategy strategy;    /**     * 构造函数设置具体策略     * @param strategy     */    public Context(IStrategy strategy) {        this.strategy = strategy;    }    /**     * 封装后的策略方法     */    public void doAnything() {        this.strategy.doSomething();    }}</code></pre><p>最后是客户端的调用策略类：</p><pre><code class="java">public class Client {    public static void main(String[] args) {        // 声明一个具体的策略        IStrategy strategy = new ConcreteStrategy1();        // 声明上下文对象        Context context = new Context(strategy);        // 执行封装后的方法        context.doAnything();    }}</code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript基础教程</title>
      <link href="/2018/09/14/qian-duan/javascript-ji-chu-jiao-cheng/"/>
      <url>/2018/09/14/qian-duan/javascript-ji-chu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JavaScript介绍"><a href="#一、JavaScript介绍" class="headerlink" title="一、JavaScript介绍"></a>一、JavaScript介绍</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a>是目前所有主流浏览器上唯一支持的脚本语言，这也是早期<code>JavaScript</code>的唯一用途。其主要作用是在不与服务器交互的情况下修改<code>HTML</code>页面内容，因此其最关键的部分是<code>DOM</code>（文档对象模型），也就是<code>HTML</code>元素的结构。通过<code>Ajax</code>可以使<code>HTML</code>页面通过<code>JavaScript</code>，在不重新加载页面的情况下从服务器上获取数据并显示，大幅提高用户体验。通过<code>JavaScript</code>，使<code>Web</code>页面发展成胖客户端成为可能。</p><h3 id="语言的性质"><a href="#语言的性质" class="headerlink" title="语言的性质"></a>语言的性质</h3><p>本节对<code>JavaScript</code>的性质做简要介绍，以帮你理解一些疑问。</p><p><code>JavaScript</code>和<code>ECMAScript</code>（JavaScript versus ECMAScript）<br>编程语言称为<code>JavaScript</code>，语言标准被称为<code>ECMAScript</code>。他们有不同名字的原因是因为“Java”已经被注册为商标（属于Oracle）。目前，只有<code>Mozilla</code>被正式允许使用“JavaScript”名称，因为很久以前他们得到一份许可。因此，开放的语言标准拥有不同的名字。当前的<code>JavaScript</code>版本是<code>ECMAScript 6</code>，<code>ECMAScript 7</code>当前是开发版。</p><p><code>JavaScript</code>之父，<code>Brendan Eich</code><a href="http://yanhaijing.com/javascript/2013/06/22/javascript-designing-a-language-in-10-days/" target="_blank" rel="noopener">迅速了创建一门编程语言</a>。（否则，Netscape将使用其他技术）。他借鉴了几门其他语言的一些特性：</p><ul><li>JavaScript借鉴了Java的语法和如何区分原始值和对象。</li><li>JavaScript的函数设计受Scheme和AWK的启发——他们（的函数）都是第一类（first-class）对象，并且在语言中广泛使用。闭包使他们（函数）变成强大的工具。</li><li>Self影响了JavaScript独一无二的面向对象编程(OOP)风格。它的核心思想（在这里我们没有提到）非常优雅，基于此创建的语言非常少。但后面会提到一个简单的模式照顾大部分用例。JavaScript面向对象编程的杀手级特性是你可以直接创建对象。不需要先创建类或其他类似的东西。</li><li>Perl和Python影响了JavaScript字符串，数组和正则表达式的操作。</li></ul><p><code>JavaScript</code>在最初的时候并不是一个完善的语言，因此也导致<code>JavaScript</code>遗留了很多令人诟病的问题。在开发稍大规模的应用时会显得力不从心，但是由于<code>JavaScript</code>本身是一种非常灵活的语言，因此在它的基础上开发程序库比较容易，因此出现了一大批非常优秀的第三方库，如<a href="http://jquery.com/" target="_blank" rel="noopener">jQuery</a>，<a href="http://extjs.org.cn/" target="_blank" rel="noopener">ExtJS</a>，<a href="http://underscorejs.org/" target="_blank" rel="noopener">underscorejs</a>，<a href="http://backbonejs.org/" target="_blank" rel="noopener">backbone</a>等等，由于这些第三方库，<code>JavaScript</code>变得非常简单。其中<code>jQuery</code>的使用非常广泛，它大幅简化了<code>DOM</code>和<code>Ajax</code>，已经成为了很多网站的标配。<code>jQuery</code>虽然基于<code>JavaScript</code>，但它提供了另外一种编程范式，也就是逻辑式编程，与<code>SQL</code>和正则表达式类似。</p><h3 id="JavaScript能做什么"><a href="#JavaScript能做什么" class="headerlink" title="JavaScript能做什么"></a>JavaScript能做什么</h3><p><img src="http://static.blinkfox.com/js1.png" alt="JavaScript项目在Github所占比例"></p><p>如上图，<code>JavaScript</code>作为<a href="https://github.com/" target="_blank" rel="noopener">Github</a>上最流行、最火的编程语言，几乎无所不能。这里是<a href="https://segmentfault.com/u/puyart" target="_blank" rel="noopener">PuYart</a>的关于<a href="https://segmentfault.com/a/1190000003767058" target="_blank" rel="noopener"><code>JavaScript</code>就要统治世界了</a>的文章，可以让我们了解<code>JavaScript</code>到底能做什么的一些介绍。</p><ol><li>Web前端(各种前端工具类库、前端框架、动画效果、数据可视化等)</li><li>服务端开发(<a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>)</li><li>移动应用或者<code>Hybrid App</code>(Cordova)</li><li>桌面应用(<a href="http://nwjs.io/" target="_blank" rel="noopener">NW.js</a>、<a href="http://electron.atom.io/" target="_blank" rel="noopener">Electron</a>)</li><li>游戏(<a href="http://unity3d.com/cn/" target="_blank" rel="noopener">Unity3D</a>、<a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/catalog/../1-about-cocos2d-js/1-1-a-brief-history/zh.md" target="_blank" rel="noopener">Cocos2d-js</a>、<a href="http://pomelo.netease.com/" target="_blank" rel="noopener">Pomelo</a>)</li><li>VR(<a href="https://www.phodal.com/blog/why-javascript-will-use-vr-world/" target="_blank" rel="noopener">JavaScript在VR世界的应用</a>)</li><li>硬件、嵌入式物联网等(<a href="http://blog.jobbole.com/46055/" target="_blank" rel="noopener">Tessel：用JavaScript做嵌入式开发</a>)</li><li>操作系统(<a href="http://node-os.com/" target="_blank" rel="noopener">NodeOS</a>)</li></ol><blockquote><p>Atwood’s Law: any application that can be written in JavaScript, will eventually be written in JavaScript.(Atwood定律：凡是能用JavaScript写出来的，最终都会用JavaScript写出来。)</p></blockquote><h2 id="二、-JavaScript语法"><a href="#二、-JavaScript语法" class="headerlink" title="二、 JavaScript语法"></a>二、 JavaScript语法</h2><h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>了解<code>JavaScript</code>的语法，先来了解两个主要的语法类型：语句和表达式。</p><ul><li>语句通常是“做某些事情”。程序是一组语句的序列。举个例子，下面声明（创建）一个变量 <code>foo</code>： </li></ul><pre><code class="javascript">var foo;</code></pre><ul><li>表达式是产生“值”。他们通常位于赋值操作的右边、函数参数等。举个例子： </li></ul><pre><code class="javascript">3 * 7</code></pre><p>语句和表达式之间的区别最好通过实例说明，<code>JavaScript</code>（像Java）有两种不同的方式实现<code>if-then-else</code>。一种是用语句：</p><pre><code class="javascript">var x;if (y &gt;= 0) {    x = y;} else {    x = -y;}</code></pre><p>另一种是表达式：</p><pre><code class="javascript">var x = y &gt;= 0 ? y : -y;</code></pre><p>你可以将后者作为函数参数（但前者不行）：</p><pre><code class="javascript">myFunction(y &gt;= 0 ? y : -y)</code></pre><p>最后，每当<code>JavaScript</code>期待一个语句，你也可以用一个表达式代替。例如：</p><pre><code class="javascript">foo(bar(7, 1));</code></pre><p><code>foo(...);</code>是一个语句（也叫做表达式语句），<code>bar(7, 1)</code>则是一个表达式。他们都实现函数调用。</p><h3 id="流程控制语句和语句块"><a href="#流程控制语句和语句块" class="headerlink" title="流程控制语句和语句块"></a>流程控制语句和语句块</h3><p>流程控制语句，其语句体可以是单条语句。举两个例子：</p><pre><code class="javascript">if (obj !== null) obj.foo();while (x &gt; 0) x--;</code></pre><p>然而，任何语句总能被语句块代替，花括号包含零或多条语句。因此，你也可以这样写：</p><pre><code class="javascript">if (obj !== null) {    obj.foo();}while (x &gt; 0) {    x--;}</code></pre><p>为便于程序的阅读和维护，推荐使用后一种方式，即语句块方式。</p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p><code>JavaScript</code>中的分号是<a href="http://www.2ality.com/2011/05/semicolon-insertion.html" target="_blank" rel="noopener">可选的</a>。但省略（分号）可能会带来意想不到的结果，所以我建议还是写上分号。</p><p>正如上面所看到的，分号作为语句的结尾，但语句块不需要。仅有一种情况下你能看到语句块后面有分号——<strong>函数表达式后面的函数体块</strong>。<strong>表达式作为语句的结尾，后面是分号</strong>：</p><pre><code class="javascript">var x = 3 * 7;var f = function () { };</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>JavaScript</code>的注释有两种形式：单行注释和多行注释。单行注释以<code>//</code>开头，以换行符结尾：</p><pre><code class="javascript">x++; // 单行（single-line）注释</code></pre><p>多行注释用<code>/**/</code>包裹</p><pre><code class="javascript">/*  这是多行注释 多行哦 */</code></pre><h2 id="三、变量和赋值"><a href="#三、变量和赋值" class="headerlink" title="三、变量和赋值"></a>三、变量和赋值</h2><p><code>JavaScript</code>中的变量在使用前必须先声明，否则会报错引用错误（Reference Error）：</p><pre><code class="javascript">var foo;  // 声明变量“foo”</code></pre><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>你可以在声明变量的同时为其赋值：</p><pre><code class="javascript">var foo = 6;</code></pre><p>你也可以给已经存在的变量重新赋值：</p><pre><code class="javascript">foo = 4;  // 更改变量的值</code></pre><h3 id="复合赋值操作符"><a href="#复合赋值操作符" class="headerlink" title="复合赋值操作符"></a>复合赋值操作符</h3><p>有很多复合赋值操作符，例如+=。下面的两个赋值操作等价：</p><pre><code class="javascript">x += 1;x = x + 1;</code></pre><h3 id="标识符和变量名"><a href="#标识符和变量名" class="headerlink" title="标识符和变量名"></a>标识符和变量名</h3><p>标识符就是事物的名字，在<code>JavaScript</code>中他们扮演不同的语法角色。例如，变量的名称是一个标识符。</p><p>大体上，标识符的第一个字符可以是任何<code>Unicode</code>字符、美元标志符（$）或下划线（_）。后面可以是任意字符和数字。因此，下面全是合法的标识符：</p><pre><code class="javascript">arg0_tmp$elemπ</code></pre><blockquote><p><strong>注意</strong>：首字符不能是数字，如果是数字的话，该如何区分是数字还是变量呢？</p></blockquote><p>一些标识符是“保留关键字”——他们是语法的一部分，不能用作变量名。从技术上讲，下面三个标识符不是保留字，但也不应该作为变量名：</p><pre><code class="javascript">Infinity NaN undefined</code></pre><h2 id="四、值"><a href="#四、值" class="headerlink" title="四、值"></a>四、值</h2><p><code>JavaScript</code>有所有我们期待的编程语言值类型：布尔，数字，字符串，数组等。<code>JavaScript</code>中的所有值都有属性。每个属性有一个键（或名字）和一个值。你可以使用点（.）操作符读取属性：</p><pre><code class="javascript">value.propKey</code></pre><p>举个例子：字符串<code>abc</code>有属性<code>lenght</code>（长度）</p><pre><code class="javascript">var str = &#39;abc&#39;;console.log(str.length); // 得到3</code></pre><p>上面的代码也可以写成下面这样：</p><pre><code class="javascript">&#39;abc&#39;.length // 得到3</code></pre><p>点操作符也可以用来给属性赋值：</p><pre><code class="javascript">var obj = {};  // 空对象obj.foo = 123; // 创建属性“foo”，设置它为123console.log(obj.foo); // 得到123</code></pre><p>你也可以通过它（.）调用方法：</p><pre><code class="javascript">&#39;hello&#39;.toUpperCase(); // 得到HELLO</code></pre><p>上面，我们在值<code>hello</code>上面调用方法<code>toUpperCase()</code>。</p><h3 id="原始类型值和对象"><a href="#原始类型值和对象" class="headerlink" title="原始类型值和对象"></a>原始类型值和对象</h3><p>JavaScript定义了不同值之间的区别：</p><ul><li>原始值包括：<code>boolean</code>，<code>number</code>，<code>string</code>，<code>null</code>和<code>undefined</code>。</li><li>所有其他的值都是对象。实际上对象被定义为——所有不为原始值的值。</li></ul><p>两者之间的主要区别在于他们是如何被比较的：每一个对象有一个独一无二的标志，并且仅和自己相等：</p><pre><code class="javascript">var obj1 = {};  // 一个空对象var obj2 = {};  // 另一个空对象obj1 === obj2   // falseobj1 === obj1   // true</code></pre><p>相反，所有原始值只要编码值相同就被认为是相同的：</p><pre><code class="javascript">var prim1 = 123;var prim2 = 123;prim1 === prim2 // true</code></pre><h3 id="原始类型值"><a href="#原始类型值" class="headerlink" title="原始类型值"></a>原始类型值</h3><p>下面全是原始类型值（简称：原始值）：</p><ul><li>布尔类型：true，false</li><li>数字类型：1736，1.351</li><li>字符串类型: ‘abc’，”abc”</li><li><p>两个“无值（non-values）”：undefined，null<br>原始值的特征：</p></li><li><p><strong>值做比较时,“内容”做比较</strong>。</p></li></ul><pre><code class="javascript">3 === 3 // true&#39;abc&#39; === &#39;abc&#39; // true</code></pre><ul><li><strong>无法更改</strong>：值的属性无法更改，无法添加和移除属性，获取未知属性总返回undefined。</li></ul><pre><code class="javascript">var str = &#39;abc&#39;;str.foo = 3; // try to create property `foo` ⇒ no effectstr.foo  // unknown property ⇒  undefined</code></pre><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h4><p>所有非原始值的值都是对象。最常见的几种对象类型是：</p><ul><li>简单对象（类型是<code>Object</code>）能通过对象字面量创建：</li></ul><pre><code class="javascript">{    firstName: ‘Jane’,     lastName: ‘Doe’}</code></pre><p>上面的对象有两个属性：<code>firstName</code>属性的值是“Jane”，<code>lastName</code>属性的值是“Doe”。</p><ul><li>数组（类型是<code>Array</code>）能通过数组字面量创建：</li></ul><pre><code class="javascript">[ ‘apple’, ‘banana’, ‘cherry’ ]</code></pre><p>上面的数组有三个元素，可以通过数字索引访问。例如“apple”的索引是0。</p><ul><li>正则表达式对象（类型是<code>RegExp</code>）能通过正则表达式字面量创建。</li></ul><pre><code class="javascript">/^a+b+$/</code></pre><h4 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h4><ul><li><strong>比较的是引用</strong>：比较的是标识符，每个值有自己的标识符。</li></ul><pre><code class="javascript">{} === {}  // 两个不同的空对象, falsevar obj1 = {};var obj2 = obj1;obj1 === obj2   // true</code></pre><ul><li><strong>默认可以更改</strong>。</li></ul><pre><code class="javascript">var obj = {};obj.foo = 123;obj.foo //123</code></pre><p>所有的数据结构（如数组）都是对象，但并不是所有的对象都是数据结构。例如：正则表达式是对象，但不是数据结构。</p><h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h3><p><code>JavaScript</code>有两个“无值）”：<code>undefined</code>和<code>null</code>。</p><p><code>undefined</code>的意思是“没有值”。未初始化的变量是<code>undefined</code>：</p><pre><code class="javascript">var foo;foo // undefined</code></pre><p>读取不存在的属性时，将返回<code>undefined</code>：</p><pre><code class="javascript">  &gt; var obj = {}; // 空对象  &gt; obj.foo // undefined</code></pre><p>缺省的参数也是<code>undefined</code>：</p><pre><code class="javascript">function f(x) {    return x;}f(); //undefined</code></pre><p><code>null</code>的意思是“没有对象”。它被用来表示对象的无值（参数，链上的对象等）。</p><p>通常情况下你应该把<code>undefined</code>和<code>null</code>看成是等价的，如果他们代表相同意义的无值的话。检查他们的一种方式是通过严格比较：</p><pre><code class="javascript">if (x === undefined || x === null) {    ...}</code></pre><p>另一种在实际中使用的方法是认为undefined 和 null 都是false：</p><pre><code class="javascript">if (!x) {    ...}</code></pre><blockquote><p><strong>警告</strong>：false，0，NaN 和 “” 都被当作false。</p></blockquote><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>对象类型的实例<code>Foo</code>（包括内建类型，例如Array和其他自定义类型）从对象<code>Foo.prototype</code>上获取方法。你可以通过读取这个方法的方式（不是调用）验证这点：</p><pre><code class="javascript">[].push === Array.prototype.push  // true</code></pre><p>相反，<strong>原始类型是没有类型的，所以每个原始类型有一个关联类型，称之为包装类型</strong>：</p><ul><li>布尔值的包装类型是 Boolean。布尔值从Boolean.prototype上获取方法：</li></ul><pre><code class="javascript">  &gt; true.toString === Boolean.prototype.toString    //true</code></pre><blockquote><p>注意：包装类型名字的首字母是大写的B。如果在JavaScript中布尔值的类型可以访问，那么它可能会被转换为布尔对象。</p></blockquote><ul><li>数字值的包装类型是<code>Number</code>。</li><li>字符串值的包装类型是<code>String</code>。</li></ul><p>包装类型也有实例（他们的实例是对象），但不常用。相反，包装类型有其他用处：<strong>如果你将他们作为函数调用，他们可以将值转换为原始类型</strong>。</p><pre><code class="javascript">Number(&#39;123&#39;) //123String(true)  //&#39;true&#39;</code></pre><h3 id="通过typeof和instanceof将值分类"><a href="#通过typeof和instanceof将值分类" class="headerlink" title="通过typeof和instanceof将值分类"></a>通过typeof和instanceof将值分类</h3><p>有两个操作符可以用来将值分类：<code>typeof</code>主要用于原始值，<code>instanceof</code>主要用于对象。</p><h4 id="typeof-使用方法如下："><a href="#typeof-使用方法如下：" class="headerlink" title="typeof 使用方法如下："></a>typeof 使用方法如下：</h4><p><code>typeof «value»</code></p><p><code>typeof</code>返回描述<code>value</code>“类型”的一个字符串。例如：</p><pre><code class="javascript">typeof true //&#39;boolean&#39;typeof &#39;abc&#39; //&#39;string&#39;typeof {} // 空对象字面量,&#39;object&#39;typeof [] // 空数组字面量,&#39;object&#39;</code></pre><p>下面列出了<code>typeof</code>操作的所有结果：</p><pre><code>操作数 结果undefined    &#39;undefined&#39;null    &#39;object&#39;Boolean value    &#39;boolean&#39;Number value    &#39;number&#39;String value    &#39;string&#39;Function    &#39;function&#39;All other values    &#39;object&#39;</code></pre><p>有两个结果和我们上面说的的原始值与对象是矛盾的：</p><ul><li>函数的类型是<code>function</code>而不是<code>object</code>。因为函数（类型为“function”）是对象（类型是对象）的子类型，这不是一个错误。</li><li><code>null</code>的类型是<code>object</code>。这是一个bug，但从没被修复，因为修复后会破坏现有的代码。</li></ul><h4 id="instanceof使用方法如下："><a href="#instanceof使用方法如下：" class="headerlink" title="instanceof使用方法如下："></a>instanceof使用方法如下：</h4><p><code>«value» instanceof «Constr»</code></p><p>如果<code>value</code>是一个对象，并且<code>value</code> 是由构造函数<code>Constr</code>创建的（参考：类）。例如：</p><pre><code class="javascript">var b = new Bar();  // 通过构造函数Bar创建对象b instanceof Bar    //true{} instanceof Object    //true[] instanceof Array //true</code></pre><h3 id="深入阅读"><a href="#深入阅读" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript/" target="_blank" rel="noopener">探索JavaScript中Null和Undefined的深渊</a></li></ul><h2 id="五、布尔"><a href="#五、布尔" class="headerlink" title="五、布尔"></a>五、布尔</h2><p>布尔类型原始值包括<code>true</code>和<code>false</code>。下面的操作符会得到布尔值：</p><ul><li>二元逻辑运算符：&amp;&amp;（与），||（或）</li><li>前缀逻辑运算符：!（非）</li><li>等值运算符：=== !== == !=</li><li>比较运算符（字符串或数字）：&gt; &gt;= &lt; &lt;=</li></ul><h3 id="真值和假值"><a href="#真值和假值" class="headerlink" title="真值和假值"></a>真值和假值</h3><p>每当<code>JavaScript</code>希望一个布尔值时（例如：if语句的条件），可以使用任何值。它将被理解（转换）为<code>true</code>或<code>false</code>。下面的值被理解为<code>false</code>：</p><ul><li>undefined, null</li><li>布尔: false</li><li>数字: 0, NaN</li><li>字符串: ‘’</li></ul><p>所有其他值被认为<code>true</code>。被理解为<code>false</code>的值称为假值，被理解为<code>true</code>的值称为真值。可以使用<code>Boolean</code>作为函数，测试值被理解为什么。</p><pre><code class="javascript">Boolean(undefined)  //falseBoolean(0)    //falseBoolean(3)    //true</code></pre><h3 id="二元逻辑运算符"><a href="#二元逻辑运算符" class="headerlink" title="二元逻辑运算符"></a>二元逻辑运算符</h3><p><code>JavaScript</code>中的<strong>二元逻辑运算符是短路运算</strong>——如果第一个操作数可以确定结果，第二个操作数将不被验证（运算）。例如，在下面的代码中，函数<code>foo()</code>永远不会被调用。</p><pre><code class="javascript">false &amp;&amp; foo()true || foo()</code></pre><p>此外，<strong>二元逻辑运算符会返回操作数中的一个</strong>，可能是一个布尔值，也可能不是。</p><ul><li><strong>与</strong>：如果第一个操作数是假值，返回第一个。否则返回第二个操作数。</li></ul><pre><code class="javascript">NaN &amp;&amp; &#39;abc&#39;    //NaN123 &amp;&amp; &#39;abc&#39;    //&#39;abc&#39;</code></pre><ul><li><strong>或</strong>：如果第一个操作数是真值，返回第一个。否则，返回第二个操作数。</li></ul><pre><code class="javascript">&#39;abc&#39; || 123    //&#39;abc&#39;&#39;&#39; || 123   //123</code></pre><h3 id="等值运算符"><a href="#等值运算符" class="headerlink" title="等值运算符"></a>等值运算符</h3><p>在<code>JavaScript</code>中检测相等，你可以使用严格相等（<code>===</code>）和严格不等（<code>!==</code>）。或者你也可以使用非严格相等（<code>==</code>）和非严格不等（<code>!=</code>）。</p><blockquote><p><strong>经验规则：总是用严格运算符，假装非严格运算符不存在。严格相等更安全。</strong></p></blockquote><h3 id="深入阅读-1"><a href="#深入阅读-1" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2014/04/25/strict-equality-exemptions/" target="_blank" rel="noopener">在JavaScript中什么时候使用==是正确的？</a></li></ul><h2 id="六、数字"><a href="#六、数字" class="headerlink" title="六、数字"></a>六、数字</h2><p><code>JavaScript</code>中的<strong>所有数字都是浮点型</strong>（虽然大部分的JavaScript引擎内部也使用整数）。至于为什么这样设计，查看这里（<a href="http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points" target="_blank" rel="noopener">每一个JavaScript开发者应该了解的浮点知识</a>）。</p><pre><code class="javascript">1 === 1.0   //true</code></pre><p>特殊数字：</p><ul><li><code>NaN</code> (“不是一个数字 not a number”): 错误值。</li></ul><pre><code class="javascript">Number(&#39;xyz&#39;)  // &#39;xyz&#39; 不能被转换为数字得到:NaN</code></pre><ul><li><code>Infinity</code>：也是最大错误值（无穷大）</li></ul><pre><code class="javascript">3 / 0   //InfinityMath.pow(2, 1024)  // 数字太大了,得到Infinity</code></pre><p><code>Infinity</code>有时很有用，因为它比任何其他数字都大。同样，<code>-Infinity</code> 比其他任何数字都小。</p><ul><li><code>JavaScript</code>有两个零，<code>+0</code>和<code>-0</code>。它（js引擎）通常不让你看到，并简单将两个零都显示为0：</li></ul><pre><code class="javascript">+0  //0-0  //0</code></pre><p>因此最好假装只有一个零（正如我们看到假值时所做的那样：<strong>-0 和 +0 都是假值</strong>）。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><code>JavaScript</code>中有下列算数运算符：</p><pre><code class="javascript">加: number1 + number2减: number1 - number2乘: number1 * number2除: number1 / number2模: number1 % number2自增: ++variable, variable++自减: –variable, variable–负值: -value正值（转换为数字）: +value</code></pre><p>全局对象<code>Math</code>通过函数提供更多算数运算操作。</p><p><code>JavaScript</code>中也有位运算符（例如：&amp;）。</p><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><p>字符串可以直接通过字符串字面量创建。这些字面量被单引号或双引号包裹。反斜线（\）转义字符并且产生一些控制字符。例如：</p><pre><code class="javascript">&#39;abc&#39;&quot;abc&quot;&#39;Did she say &quot;Hello&quot;?&#39;&quot;Did she say \&quot;Hello\&quot;?&quot;&#39;That\&#39;s nice!&#39;&quot;That&#39;s nice!&quot;&#39;Line 1\nLine 2&#39;  // 换行&#39;Backlash: \\&#39;</code></pre><p>可以通过方括号访问单个字符：</p><pre><code class="javascript">var str = &#39;abc&#39;;str[1]    //&#39;b&#39;</code></pre><p><code>length</code>属性是字符串的字符数量。</p><pre><code class="javascript">&#39;abc&#39;.length  //3</code></pre><blockquote><p><strong>提醒</strong>：字符串是不可变的，如果你想改变现有字符串，你需要创建一个新的字符串。</p></blockquote><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>字符串可以通过加号操作符（+）拼接，如果其中一个操作数为字符串，会将另一个操作数也转换为字符串。</p><pre><code class="javascript">var msgCount = 3;&#39;You have &#39;+ msgCount + &#39; messages&#39; //&#39;You have 3 messages&#39;</code></pre><p>连续执行拼接操作可以使用<code>+=</code>操作符：</p><pre><code class="javascript">var str = &#39;&#39;;str += &#39;Multiple &#39;;str += &#39;pieces &#39;;str += &#39;are concatenated.&#39;;console.log(str); //&#39;Multiple pieces are concatenated.&#39;</code></pre><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>字符串有许多有用的方法。例如：</p><pre><code class="javascript">&#39;abc&#39;.slice(1)  // 复制子字符串,得到索引1及其之后的字符串，即：&#39;bc&#39;&#39;abc&#39;.slice(1, 2)   //得到索引1和2之间的字符串，即：&#39;b&#39;&#39;\t xyz  &#39;.trim()  // 移除空白字符，即：&#39;xyz&#39;&#39;mjölnir&#39;.toUpperCase()   //转成大写，即：&#39;MJÖLNIR&#39;&#39;abc&#39;.indexOf(&#39;b&#39;)  // 查找第一个b的索引，即：1&#39;abc&#39;.indexOf(&#39;x&#39;)    //没有返回-1</code></pre><h2 id="八、语句"><a href="#八、语句" class="headerlink" title="八、语句"></a>八、语句</h2><h3 id="条件（Conditionals）"><a href="#条件（Conditionals）" class="headerlink" title="条件（Conditionals）"></a>条件（Conditionals）</h3><p><code>if</code>语句通过布尔条件决定执行那个分支：</p><pre><code class="javascript">if (myvar === 0) {    // then}if (myvar === 0) {    // then} else {    // else}if (myvar === 0) {    // then} else if (myvar === 1) {    // else-if} else if (myvar === 2) {    // else-if} else {    // else}</code></pre><p>下面的<code>switch</code>语句，furit的值决定那个分支被执行。</p><pre><code class="javascript">switch (fruit) {    case &#39;banana&#39;:        // ...        break;    case &#39;apple&#39;:        // ...        break;    default:  // 所有其他情况        // ...}</code></pre><h3 id="循环（Loops）"><a href="#循环（Loops）" class="headerlink" title="循环（Loops）"></a>循环（Loops）</h3><p>for 循环的格式如下：</p><pre><code class="javascript">for(初始化; 当条件成立时循环; 下一步操作)</code></pre><p>例子：</p><pre><code class="javascript">for (var i=0; i &lt; arr.length; i++) {    console.log(arr[i]);}</code></pre><p>当条件成立时<code>while</code>循环继续循环它的循环体。</p><pre><code class="javascript">// 和上面的for循环相等var i = 0;while (i &lt; arr.length) {    console.log(arr[i]);    i++;}</code></pre><p>当条件成立时，<code>do-while</code>循环继续循环。由于条件位于循环体之后，所以循环体总是被至少至少执行一次。</p><pre><code class="javascript">do {    // ...} while(条件);</code></pre><p>在所有的循环中：</p><ul><li>break中断循环</li><li>continue开始一个新的循环迭代</li></ul><h2 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a>九、函数</h2><p>定义函数的一种方法是通过函数声明：</p><pre><code class="javascript">function add(param1, param2) {    return param1 + param2;}</code></pre><p>上面的代码定义一个名称叫做<code>add</code>的函数，有两个参数<code>param1</code>和<code>param2</code>，并且返回参数的和。下面是如何调用这个函数：</p><pre><code class="javascript">add(6, 1)   //7add(&#39;a&#39;, &#39;b&#39;)   //&#39;ab&#39;</code></pre><p>另一种定义<code>add()</code>函数的方法是通过函数表达式：</p><pre><code class="javascript">var add = function (param1, param2) {    return param1 + param2;};</code></pre><p>函数表达式产生一个值，因此可以直接将函数作为参数传递给其他函数：</p><pre><code class="javascript">someOtherFunction(function (p1, p2) { ... });</code></pre><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><p>函数声明会被提升，他们全被移动到当前作用域开始之处。这允许你在函数声明之前调用它们：</p><pre><code class="javascript">function foo() {    bar();  // 没问题，bar被提升    function bar() {        ...    }}</code></pre><blockquote><p><strong>注意</strong>：虽然变量声明也会被提升，但赋值的过程不会被提升：</p></blockquote><pre><code class="javascript">function foo() {    bar();  // 有问题，bar是undefined    var bar = function () {        // ...    };}</code></pre><h3 id="特殊变量参数"><a href="#特殊变量参数" class="headerlink" title="特殊变量参数"></a>特殊变量参数</h3><p><strong>在<code>JavaScript</code>中你可以调用任意函数并传递任意数量的参数</strong>——语言绝不会“抱怨”（参数检测）。都可以正常工作，然而，使所有参数可访问需要通过特殊变量<code>arguments</code>。<code>arguments</code>看起来像数组，但它没有数组的方法（称为类数组 array-like）。</p><pre><code class="javascript">function f() { return arguments }var args = f(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);args.length //3args[0]  // 获取索引为0的元素,&#39;a&#39;</code></pre><h3 id="太多或太少参数"><a href="#太多或太少参数" class="headerlink" title="太多或太少参数"></a>太多或太少参数</h3><p>让我们通过下面的函数探索<code>JavaScript</code>中传递太多或太少参数时如何处理</p><pre><code class="javascript">function f(x, y) {    console.log(x, y);}</code></pre><p>多出的参数将被忽略（可以通过<code>arguments</code>访问）：</p><pre><code class="javascript">f(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)    //a b</code></pre><p>缺少的参数将会是<code>undefined</code>：</p><pre><code class="javascript">f(&#39;a&#39;)    //a undefinedf() //undefined undefined</code></pre><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>下面是一个常见模式，给参数设置默认值：</p><pre><code class="javascript">function pair(x, y) {    x = x || 0;  // (*)    y = y || 0;    return [ x, y ];}</code></pre><p>在<code>（*）</code>这行，如果x是真值（除了：<code>null</code>，<code>undefined</code> 等），         操作符返回x。否则，它返回第二个操作数。</p><pre><code class="javascript">pair()  //[ 0, 0 ]pair(3) //[ 3, 0 ]pair(3, 5)  //[ 3, 5 ]</code></pre><h3 id="强制数量"><a href="#强制数量" class="headerlink" title="强制数量"></a>强制数量</h3><p>如果你想强制参数的数量，你可以检测<code>arguments.length</code>：</p><pre><code class="javascript">function pair(x, y) {    if (arguments.length !== 2) {        throw new Error(&#39;Need exactly 2 arguments&#39;);    }    ...}</code></pre><h3 id="将arguments-转换为数组"><a href="#将arguments-转换为数组" class="headerlink" title="将arguments 转换为数组"></a>将arguments 转换为数组</h3><p><code>arguments</code>不是一个数组，它仅仅是类数组（array-like）：它有一个<code>length</code>属性，并且你可以通过方括号索引方式访问它的元素。然而，你不能移除元素，或在它上面调用任何数组方法。因此，有时你需要将其转换为数组。这就是下面函数的作用。</p><pre><code class="javascript">function toArray(arrayLikeObject) {    return [].slice.call(arrayLikeObject);}</code></pre><h2 id="十、异常处理"><a href="#十、异常处理" class="headerlink" title="十、异常处理"></a>十、异常处理</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener">异常处理</a>最常见的方式像下面这样：</p><pre><code class="javascript">function throwException() {    throw new Error(&#39;Problem!&#39;);}try {    throwException();} catch (e) {    console.log(e);  // 错误：信息    console.log(e.stack);  // 非标准，但大部分浏览器支持}</code></pre><p>try分支包裹易出错的代码，如果try分支内部抛出异常，catch分支将会执行。</p><h2 id="十一、严格模式"><a href="#十一、严格模式" class="headerlink" title="十一、严格模式"></a>十一、严格模式</h2><p>严格模式开启检测和一些其他措施，使<code>JavaScript</code>变成更整洁的语言。推荐使用严格模式。为了开启严格模式，只需在<code>JavaScript</code>文件或<code>script</code>标签第一行添加如下语句：</p><pre><code class="javascript">&#39;use strict&#39;;</code></pre><p>你也可以在每个函数上选择性开启严格模式，只需将上面的代码放在函数的开头：</p><pre><code class="javascript">function functionInStrictMode() {    &#39;use strict&#39;;}</code></pre><p>下面的两小节看下严格模式的三大好处。</p><h3 id="明确错误"><a href="#明确错误" class="headerlink" title="明确错误"></a>明确错误</h3><p>让我们看一个例子，严格模式给我们明确的错误，否则<code>JavaScript</code>总是静默失败：下面的函数<code>f()</code> 执行一些非法操作，它试图更改所有字符串都有的只读属性——<code>length</code>：</p><pre><code class="javascript">function f() {    &#39;abc&#39;.length = 5;}</code></pre><p>当你调用上面的函数，它静默失败，赋值操作被简单忽略。让我们将<code>f()</code>在严格模式下运行：</p><pre><code class="javascript">function f_strict() {    &#39;use strict&#39;;    &#39;abc&#39;.length = 5;}</code></pre><p>现在浏览器报给我们一些错误：</p><pre><code class="javascript">f_strict()  // TypeError: Cannot assign to read only property &#39;length&#39; of abc</code></pre><h3 id="不是方法的函数中的this"><a href="#不是方法的函数中的this" class="headerlink" title="不是方法的函数中的this"></a>不是方法的函数中的this</h3><p>在严格模式下，不作为方法的函数中的<code>this</code>值是<code>undefined</code>：</p><pre><code class="javascript">function f_strict() {    &#39;use strict&#39;;    return this;}console.log(f_strict() === undefined);  // true</code></pre><p>在非严格模式下，<code>this</code>的值是被称作全局对象（<code>global object</code>）（在浏览器里是<code>window</code>）：</p><pre><code class="javascript">function f() {    return this;}console.log(f() === window);  // true</code></pre><h3 id="不再自动创建全局变量"><a href="#不再自动创建全局变量" class="headerlink" title="不再自动创建全局变量"></a>不再自动创建全局变量</h3><p>在非严格模式下，如果你给不存在的变量赋值，<code>JavaScript</code>会自动创建一个全局变量：</p><pre><code class="javascript">function f() { foo = 5 }f()  // 不会报错foo // 5</code></pre><p>在严格模式下，这会产生一个错误：</p><pre><code class="javascript">function f_strict() { &#39;use strict&#39;; foo2 = 4; }f_strict()  // ReferenceError: foo2 is not defined</code></pre><h3 id="深入阅读-2"><a href="#深入阅读-2" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2013/12/28/demystifying-this-in-javascript" target="_blank" rel="noopener">揭秘javascript中谜一样的this</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/30/javascript-this-keyword" target="_blank" rel="noopener">JavaScript中的this关键字</a></li></ul><h2 id="十二、变量作用域和闭包"><a href="#十二、变量作用域和闭包" class="headerlink" title="十二、变量作用域和闭包"></a>十二、变量作用域和闭包</h2><p>在<code>JavaScript</code>中，你必须使用变量之前，通过<code>var</code>声明变量：</p><pre><code class="javascript">var x;x = 3;y = 4;  // ReferenceError: y is not defined</code></pre><p>你可以用一条<code>var</code>语句声明和初始化多个变量：</p><pre><code class="javascript">var x = 1, y = 2, z = 3;</code></pre><p>但我建议每个变量使用一条语句。因此，我将上面的语句重写为：</p><pre><code class="javascript">var x = 1;var y = 2;var z = 3;</code></pre><p>由于提升（见下文），最好在函数顶部声明变量。</p><h3 id="变量和函数作用域"><a href="#变量和函数作用域" class="headerlink" title="变量和函数作用域"></a>变量和函数作用域</h3><p>变量的作用域总是整个函数（没有块级作用域）。例如：</p><pre><code class="javascript">function foo() {    var x = -3;    if (x &lt; 0) {  // (*)        var tmp = -x;        ...    }    console.log(tmp);  // 3}</code></pre><p>我们可以看到tmp变量不仅在（*）所在行的语句块存在，它在整个函数内都存在。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>变量声明会被提升：声明会被移到函数的顶部，但赋值过程不会。举个例子，在下面的函数中<code>（*）</code>行位置声明了一个变量。</p><pre><code class="javascript">function foo() {    console.log(tmp); // undefined    if (false) {        var tmp = 3;  // (*)    }}</code></pre><p>在内部，上面的函数被执行像下面这样：</p><pre><code class="javascript">function foo() {    var tmp;  // declaration is hoisted    console.log(tmp);    if (false) {        tmp = 3;  // assignment stays put    }}</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>每个函数保持和函数体内部变量的连接，甚至离开创建它的作用域之后。例如：</p><pre><code class="javascript">function createIncrementor(start) {    return function () {  // (*)        return start++;    }}</code></pre><p>在<code>（*）</code>行开始的函数在它创建时保留上下文，并在内部保存一个<code>start</code>活动值：</p><pre><code class="javascript">var inc = createIncrementor(5);inc()   // 5inc() // 6inc()   // 7</code></pre><p>闭包是一个函数加上和其作用域链的链接。因此，<code>createIncrementor()</code>返回的是一个闭包。</p><h3 id="IIFE：模拟块级作用域"><a href="#IIFE：模拟块级作用域" class="headerlink" title="IIFE：模拟块级作用域"></a>IIFE：模拟块级作用域</h3><p>有时你想模拟一个块，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做 <code>IIFE</code>(立即执行函数表达式(<code>Immediately Invoked Function Expression</code>))：</p><pre><code class="javascript">(function () {  // 块开始    var tmp = ...;  // 非全局变量}());  // 块结束</code></pre><p>上面你会看到函数表达式被立即执行。外面的括号用来阻止它被解析成函数声明；只有函数表达式能被立即调用。函数体产生一个新的作用域并使<code>tmp</code>变为局部变量。</p><h3 id="闭包实现变量共享"><a href="#闭包实现变量共享" class="headerlink" title="闭包实现变量共享"></a>闭包实现变量共享</h3><p>下面是个经典问题，如果你不知道，会让你费尽思量。因此，先浏览下，对问题有个大概的了解。</p><p>闭包保持和外部变量的连接，有时可能和你想像的行为不一致：</p><pre><code class="javascript">var result = [];for (var i=0; i &lt; 5; i++) {    result.push(function () { return i });  // (*)}console.log(result[1]()); // 5 (不是 1)console.log(result[3]()); // 5 (不是 3)</code></pre><p><code>(*)</code>行的返回值总是当前的i值，而不是当函数被创建时的i值。当循环结束后，i的值是5，这是为什么数组中的所有函数的返回值总是一样的。如果你想捕获当前变量的快照，你可以使用<code>IIFE</code>：</p><pre><code class="javascript">for (var i=0; i &lt; 5; i++) {    (function (i2) {        result.push(function () { return i2 });    }(i));  // 复制当前的i}</code></pre><p>深入阅读</p><ul><li><a href="http://yanhaijing.com/javascript/2013/08/30/understanding-scope-and-context-in-javascript" target="_blank" rel="noopener">认识javascript中的作用域和上下文</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting" target="_blank" rel="noopener">JavaScript的作用域和提升机制</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript" target="_blank" rel="noopener">了解JavaScript的执行上下文</a></li></ul><h2 id="十三、对象和继承"><a href="#十三、对象和继承" class="headerlink" title="十三、对象和继承"></a>十三、对象和继承</h2><p>和所有的值类型一样，对象有属性。事实上，你可以将对象当作一组属性的集合，每个属性都是一对（键和值）。键是字符串，值可以是任意<code>JavaScript</code>值。到目前为止，我们仅仅见过键是标识符的属性，因为点操作符处理的键必须为标识符。在这节，你讲见到另一种访问属性的方法，能将任意字符串作为键。</p><h3 id="单个对象"><a href="#单个对象" class="headerlink" title="单个对象"></a>单个对象</h3><p>在<code>JavaScript</code>中，你可以直接创建对象，通过对象字面量：</p><pre><code class="javascript">var jane = {    name: &#39;Jane&#39;,    describe: function () {        &#39;use strict&#39;;        return &#39;Person named &#39;+this.name;    }};</code></pre><p>上面的对象有两个属性：<code>name</code>和<code>describe</code>。你能读（“get”）和 写（“set”）属性：</p><pre><code class="javascript">jane.name  // get，&#39;Jane&#39;jane.name = &#39;John&#39;;  // setjane.newProperty = &#39;abc&#39;;  // 自动创建</code></pre><p>属性是函数如<code>describe</code>可以被当作方法调用。当调用他们时可以在它们内部通过this引用对象。</p><pre><code class="javascript">jane.describe()  // 调用方法,&#39;Person named John&#39;jane.name = &#39;Jane&#39;;jane.describe() // &#39;Person named Jane&#39;</code></pre><p><code>in</code>操作符用来检测一个属性是否存在：</p><pre><code class="javascript">&#39;newProperty&#39; in jane   // true&#39;foo&#39; in jane   // false</code></pre><p>若读取一个不存在的属性，将会得到<code>undefined</code>值。因此上面的两个检查也可以像下面这样：</p><pre><code class="javascript">jane.newProperty !== undefined  // truejane.foo !== undefined  // false</code></pre><p><code>delete</code>操作符用来删除一个属性：</p><pre><code class="javascript">delete jane.newProperty //true&#39;newProperty&#39; in jane   //false</code></pre><h3 id="任意键属性"><a href="#任意键属性" class="headerlink" title="任意键属性"></a>任意键属性</h3><p>属性的键可以是任意字符串。到目前为止，我们看到的对象字面量中的和点操作符后的属性关键字。按这种方法你只能使用标识符。如果你想用其他任意字符串作为键名，你必须在对象字面量里加上引号，并使用方括号获取和设置属性。</p><pre><code class="javascript">var obj = { &#39;not an identifier&#39;: 123 };obj[&#39;not an identifier&#39;]    //123obj[&#39;not an identifier&#39;] = 456;</code></pre><p>方括号允许你动态计算属性关键字：</p><pre><code class="javascript">var x = &#39;name&#39;;jane[x]; // &#39;Jane&#39;jane[&#39;na&#39;+&#39;me&#39;]; // &#39;Jane&#39;</code></pre><h3 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h3><p>如果你引用一个方法，它将失去和对象的连接。就其本身而言，函数不是方法，其中的<code>this</code>值为<code>undefined</code>（严格模式下）。</p><pre><code class="javascript">var func = jane.describe;func()  // TypeError: Cannot read property &#39;name&#39; of undefined</code></pre><p>解决办法是使用函数内置的<code>bind()</code>方法。它创建一个新函数，其<code>this</code>值固定为给定的值。</p><pre><code class="javascript">var func2 = jane.describe.bind(jane);func2() // &#39;Person named Jane&#39;</code></pre><h3 id="方法内部的函数"><a href="#方法内部的函数" class="headerlink" title="方法内部的函数"></a>方法内部的函数</h3><p>每个函数都有一个特殊变量<code>this</code>。如果你在方法内部嵌入函数是很不方便的，因为你不能从函数中访问方法的<code>this</code>。下面是一个例子，我们调用<code>forEach</code>循环一个数组：</p><pre><code class="javascript">var jane = {    name: &#39;Jane&#39;,    friends: [ &#39;Tarzan&#39;, &#39;Cheeta&#39; ],    logHiToFriends: function () {        &#39;use strict&#39;;        this.friends.forEach(function (friend) {            // 这里的“this”是undefined            console.log(this.name + &#39; says hi to &#39; + friend);        });    }}</code></pre><p>调用<code>logHiToFriends</code>会产生错误：</p><pre><code class="javascript">jane.logHiToFriends()   // TypeError: Cannot read property &#39;name&#39; of undefined</code></pre><p>有两种方法修复这问题。</p><ul><li>将<code>this</code>存储在不同的变量。</li></ul><pre><code class="javascript">logHiToFriends: function () {    &#39;use strict&#39;;    var that = this;    this.friends.forEach(function (friend) {        console.log(that.name + &#39; says hi to &#39; + friend);    });}</code></pre><ul><li>forEach的第二个参数允许提供<code>this</code>值。</li></ul><pre><code class="javascript">logHiToFriends: function () {    &#39;use strict&#39;;    this.friends.forEach(function (friend) {        console.log(this.name + &#39; says hi to &#39; + friend);    }, this);}</code></pre><p>在<code>JavaScript</code>中函数表达式经常被用作函数参数。时刻小心函数表达式中的<code>this</code>。</p><h3 id="构造函数：对象工厂"><a href="#构造函数：对象工厂" class="headerlink" title="构造函数：对象工厂"></a>构造函数：对象工厂</h3><p>除了作为“真正”的函数和方法，函数还在JavaScript中扮演第三种角色：<strong>如果通过new操作符调用，他们会变为构造函数，对象的工厂</strong>。构造函数是对其他语言中的类的粗略模拟。约定俗成，构造函数的第一个字母大写。例如：</p><pre><code class="javascript">// 设置实例数据function Point(x, y) {    this.x = x;    this.y = y;}// 方法Point.prototype.dist = function () {    return Math.sqrt(this.x*this.x + this.y*this.y);};</code></pre><p>我们看到构造函数分为两部分：首先，<code>Point</code>函数设置实例数据。其次，<code>Point.prototype</code>属性包含对象的方法。前者的数据是每个实例私有的，后面的数据是所有实例共享的。</p><p>我们通过new操作符调用<code>Point</code>：</p><pre><code class="javascript">var p = new Point(3, 5);p.x //3p.dist();    //5.830951894845301</code></pre><p>p是<code>Point</code>的一个实例：</p><pre><code class="javascript">p instanceof Point  //truetypeof p    //&#39;object&#39;</code></pre><h3 id="深入阅读-3"><a href="#深入阅读-3" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2013/08/23/javascript-inheritance-how-to-shoot-yourself-in-the-foot-with-prototypes" target="_blank" rel="noopener">Javascript继承 原型的陷阱</a></li><li><a href="http://yanhaijing.com/javascript/2013/08/30/encapsulation-of-javascript" target="_blank" rel="noopener">Javascript 封装问题</a></li></ul><h2 id="十四、数组"><a href="#十四、数组" class="headerlink" title="十四、数组"></a>十四、数组</h2><p>数组是数组元素的序列，能通过整数索引方法数组元素，数组索引从0开始。</p><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>数组字面量创建数组很方便：</p><pre><code class="javascript">&gt; var arr = [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];</code></pre><p>上面的数组有三个元素：分别是字符串“a”，“b”， “c”。你可以通过整数索引访问它们：</p><pre><code class="javascript">arr[0]  //&#39;a&#39;arr[0] = &#39;x&#39;;arr// [ &#39;x&#39;, &#39;b&#39;, &#39;c&#39; ]</code></pre><p><code>length</code>属性总表示一个数组有多少项元素。</p><pre><code class="javascript">arr.length    //3</code></pre><p>除此之外它也可以用来从数组上移除尾部元素：</p><pre><code class="javascript">arr.length = 2; arr // [ &#39;x&#39;, &#39;b&#39; ]</code></pre><p><code>in</code>操作符也可以在数组上工作。</p><pre><code class="javascript">1 in arr // arr在索引为1处是否有元素？,true5 in arr // arr在索引为5处是否有元素？false</code></pre><p>值得注意的是数组是对象，因此可以有对象属性：</p><pre><code class="javascript">arr.foo = 123;arr.foo   // 123</code></pre><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>数组有许多方法。举些例子：</p><pre><code class="javascript">var arr = [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];arr.slice(1, 2)  // 复制元素，[ &#39;b&#39; ]arr.slice(1)    // [ &#39;b&#39;, &#39;c&#39; ]arr.push(&#39;x&#39;)  // 在末尾添加一个元素，4arr // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;x&#39; ]arr.pop()  // 移除最后一个元素，&#39;x&#39;arr   // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]arr.shift()  // 移除第一个元素，&#39;a&#39;arr // [ &#39;b&#39;, &#39;c&#39; ]arr.unshift(&#39;x&#39;)  // 在前面添加一个元素，3arr // [ &#39;x&#39;, &#39;b&#39;, &#39;c&#39; ]arr.indexOf(&#39;b&#39;)  // 查找给定项在数组中的索引，若不存在返回-1，// 1arr.indexOf(&#39;y&#39;)  // -1arr.join(&#39;-&#39;)  // 将元素拼接为一个字符串，&#39;x-b-c&#39;arr.join(&#39;&#39;)    // &#39;xbc&#39;arr.join()  // &#39;x,b,c&#39;</code></pre><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>有几种方法可以遍历数组元素。其中两个最重要的是<code>forEach</code>和<code>map</code>。</p><p><code>forEach</code>遍历整个数组，并将当前元素和它的索引传递给一个函数：</p><pre><code class="javascript">[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ].forEach(function (elem, index) {  // (*)    console.log(index + &#39;. &#39; + elem);});</code></pre><p>上面代码的输出</p><pre><code class="javascript">0. a1. b2. c</code></pre><p>注意<code>（*）</code>行的函数参数是可省略的。例如：它可以只有一个参数<code>elem</code>。</p><p><code>map</code>创建一个新数组，通过给每个存在数组元素应用一个函数：</p><pre><code class="javascript">[1,2,3].map(function (x) {     return x*x });// [ 1, 4, 9 ]</code></pre><h3 id="深入阅读-4"><a href="#深入阅读-4" class="headerlink" title="深入阅读"></a>深入阅读</h3><ul><li><a href="http://yanhaijing.com/javascript/2014/01/17/fun-with-javascript-native-array-functions" target="_blank" rel="noopener">有趣的javascript原生数组函数</a></li></ul><h2 id="十五、正则表达式"><a href="#十五、正则表达式" class="headerlink" title="十五、正则表达式"></a>十五、正则表达式</h2><p><code>JavaScript</code>内建支持正则表达式。他们被双斜线分隔：</p><pre><code class="javascript">/^abc$//[A-Za-z0-9]+/</code></pre><h3 id="方法-test-：测试是否匹配"><a href="#方法-test-：测试是否匹配" class="headerlink" title="方法 test()：测试是否匹配"></a>方法 test()：测试是否匹配</h3><pre><code class="javascript">/^a+b+$/.test(&#39;aaab&#39;)   // true/^a+b+$/.test(&#39;aaa&#39;)    // false</code></pre><h3 id="方法-exec-：匹配和捕获组"><a href="#方法-exec-：匹配和捕获组" class="headerlink" title="方法 exec()：匹配和捕获组"></a>方法 exec()：匹配和捕获组</h3><pre><code class="javascript">/a(b+)a/.exec(&#39;_abbba_aba_&#39;)    // [ &#39;abbba&#39;, &#39;bbb&#39; ]</code></pre><p>返回的数组第一项（索引为0）是完整匹配，捕获的第一个分组在第二项（索引为1），等。有一种方法可以反复调用获取所有匹配。</p><h3 id="方法-replace-：搜索并替换"><a href="#方法-replace-：搜索并替换" class="headerlink" title="方法 replace()：搜索并替换"></a>方法 replace()：搜索并替换</h3><pre><code class="javascript">&#39;&lt;a&gt; &lt;bbb&gt;&#39;.replace(/&lt;(.*?)&gt;/g, &#39;[$1]&#39;) // &#39;[a] [bbb]&#39;</code></pre><p><code>replace</code>的第一个参数必须是正则表达式，并且开启全局搜索（<code>/g</code>标记），否则仅第一个匹配项会被替换。有一种方法使用一个函数来计算替换项。</p><h2 id="十六、数学"><a href="#十六、数学" class="headerlink" title="十六、数学"></a>十六、数学</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="noopener">Math</a>是一个有算数功能的对象。例如：</p><pre><code class="javascript">Math.abs(-2) // 2Math.pow(3, 2) // 3^2 = 9Math.max(2, -1, 5) //5Math.round(1.9) // 2Math.cos(Math.PI)  // 预定义常量π，-1</code></pre><h2 id="十七、标准库的其他功能"><a href="#十七、标准库的其他功能" class="headerlink" title="十七、标准库的其他功能"></a>十七、标准库的其他功能</h2><p><code>JavaScript</code>标准库相对简单，但有很多其他东西你可以使用：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date</a>：日期构造函数，主要功能有转换和创建日期字符串，访问日期组成部分（年，小时等）。<br><a href="http://www.2ality.com/2011/08/json-api.html" target="_blank" rel="noopener">JSON</a>：一个对象，功能是转换和生成<code>JSON</code>数据。<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/console" target="_blank" rel="noopener">console.*</a>方法：浏览器的具体方法，不是语言成分的部分，但他们也可以在<a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>中工作。</p><h2 id="十八、下一步学什么？"><a href="#十八、下一步学什么？" class="headerlink" title="十八、下一步学什么？"></a>十八、下一步学什么？</h2><p>在你学会了这篇文章的基础教程后，你可以转到大部分章节末尾提到的高级教程。此外，我建议你看下面的资源：</p><ul><li>Style guides: I have written <a href="http://www.2ality.com/2013/07/meta-style-guide.html" target="_blank" rel="noopener">a guide to style guides</a></li><li><a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore.js</a>: 一个弥补JavaScript标准库缺少的功能的库</li><li><a href="http://jsbooks.revolunet.com/" target="_blank" rel="noopener">JSbooks – free JavaScript books</a></li><li><a href="http://uptodate.frontendrescue.org/" target="_blank" rel="noopener">Frontend rescue: how to keep up to date on frontend technologies</a></li><li><a href="http://yanhaijing.com/" target="_blank" rel="noopener">http://yanhaijing.com</a> 当然还有我的博客也非常不错哦</li><li><a href="http://yanhaijing.com/es5" target="_blank" rel="noopener">http://yanhaijing.com/es5</a> 如果你想成为高手，我建议阅读<code>ecmascript</code>规范</li><li><a href="http://yanhaijing.com/javascript/2013/12/11/24-JavaScript-best-practices-for-beginners" target="_blank" rel="noopener">给javascript初学者的24条最佳实践</a></li><li><a href="http://yanhaijing.com/javascript/2014/04/23/seven-javascript-quirks-i-wish-id-known-about" target="_blank" rel="noopener">我希望我知道的七个JavaScript技巧</a></li></ul><p>参考自原文：<a href="http://www.2ality.com/2013/06/basic-javascript.html" target="_blank" rel="noopener">http://www.2ality.com/2013/06/basic-javascript.html</a><br>参考自译文：<a href="http://yanhaijing.com/basejs/" target="_blank" rel="noopener">http://yanhaijing.com/basejs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache Commons Collections包和简介</title>
      <link href="/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/"/>
      <url>/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><a href="http://commons.apache.org/" target="_blank" rel="noopener">Apache Commons</a>是Apache软件基金会的项目，曾经隶属于<code>Jakarta</code>项目。<code>Commons</code>的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：<code>Proper</code>（是一些已发布的项目）、<code>Sandbox</code>（是一些正在开发的项目）和<code>Dormant</code>（是一些刚启动或者已经停止维护的项目）。</p><p><a href="http://commons.apache.org/proper/commons-collections/" target="_blank" rel="noopener">Commons Collections</a>包为Java标准的<code>Collections API</code>提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p><h2 id="一、包结构介绍"><a href="#一、包结构介绍" class="headerlink" title="一、包结构介绍"></a>一、包结构介绍</h2><blockquote><p>注意：Commons Collections的最新版是4.1，但由于工作中大多还是3.x的版本，这里就以3.x中的最后一个版本3.2.2作使用介绍。</p></blockquote><p>以下是Collections的包结构和简单介绍，如果你想了解更多的各个包下的接口和实现，请参考<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/index.html" target="_blank" rel="noopener">Apache Commons Collections 3.2.2 API文档</a>。</p><ul><li><code>org.apache.commons.collections</code> – CommonsCollections自定义的一组公用的接口和工具类</li><li><code>org.apache.commons.collections.bag</code> – 实现Bag接口的一组类</li><li><code>org.apache.commons.collections.bidimap</code> – 实现BidiMap系列接口的一组类</li><li><code>org.apache.commons.collections.buffer</code> – 实现Buffer接口的一组类</li><li><code>org.apache.commons.collections.collection</code> –实现java.util.Collection接口的一组类</li><li><code>org.apache.commons.collections.comparators</code>– 实现java.util.Comparator接口的一组类</li><li><code>org.apache.commons.collections.functors</code> –Commons Collections自定义的一组功能类</li><li><code>org.apache.commons.collections.iterators</code> – 实现java.util.Iterator接口的一组类</li><li><code>org.apache.commons.collections.keyvalue</code> – 实现集合和键/值映射相关的一组类</li><li><code>org.apache.commons.collections.list</code> – 实现java.util.List接口的一组类</li><li><code>org.apache.commons.collections.map</code> – 实现Map系列接口的一组类</li><li><code>org.apache.commons.collections.set</code> – 实现Set系列接口的一组类</li></ul><h2 id="二、Map的一些介绍"><a href="#二、Map的一些介绍" class="headerlink" title="二、Map的一些介绍"></a>二、Map的一些介绍</h2><p><code>Collections</code>包中的“Map”是在<code>java.util.Map</code>的基础上扩展的接口和类。有如下常用的Map:</p><ul><li><strong>LinkedMap</strong>，可以维护条目顺序的map；</li><li><strong>BidiMap</strong>，即双向Map，可以通过key找到value，也可以通过value找到key。需要注意的是BidiMap中key和value都不可以重复；</li><li><strong>MultiMap</strong>，一个key指向的是一组对象，add()和remove()的时候跟普通的Map无异，只是在get()时返回一个Collection，实现了一对多；</li><li><strong>LazyMap</strong>，即Map中的键/值对一开始并不存在，当被调用到时才创建。</li></ul><h2 id="三、Collections中Map的使用示例"><a href="#三、Collections中Map的使用示例" class="headerlink" title="三、Collections中Map的使用示例"></a>三、Collections中Map的使用示例</h2><h3 id="1-Map迭代器之mapIterator"><a href="#1-Map迭代器之mapIterator" class="headerlink" title="1. Map迭代器之mapIterator"></a>1. Map迭代器之mapIterator</h3><p><code>jdk</code>中的<code>Map</code>接口很难进行迭代。<code>api</code>用户总是需要通过<code>entryset</code>或者<code>keyset</code>进行迭代。<code>commons-collectons</code>现在提供了一个新的接口 - <code>mapIterator</code>来允许对<code>maps</code>进行简单的迭代。示例如下：</p><p>(1)、构造Map初始数据的方法：</p><pre><code class="java">/** * 构建map初始数据 * @param map */private static Map buildMap(Map map) {    map.put(&quot;one&quot;, &quot;1&quot;);    map.put(&quot;two&quot;, &quot;2&quot;);    map.put(&quot;three&quot;, &quot;3&quot;);    map.put(&quot;four&quot;, &quot;4&quot;);    return map;}</code></pre><p>(2)、使用MapIterator迭代数据的方法：</p><pre><code class="java">/** * map迭代器 * 遍历打印map,使用map.mapIterator() * @param map * @param mapName */private static void iteratorMap() {    Map map = this.buildMap(new HashMap());    // 遍历map,使用MapIterator    MapIterator it = map.mapIterator();    while (it.hasNext()) {        Object key = it.next();        Object value = it.getValue();        System.out.println(&quot;iterator map key:&quot; + key + &quot;, value: &quot; + value);    }}</code></pre><h3 id="2-有序map之LinkedMap"><a href="#2-有序map之LinkedMap" class="headerlink" title="2. 有序map之LinkedMap"></a>2. 有序map之LinkedMap</h3><p><code>LinkedMap</code>是一个可以维护Map中条目顺序的Map实现，条目顺序由最初的数据插入时来决定。同时也增加上面所说的<code>MapIterator</code>功能和一些便利的方法，并允许进行双向迭代。相较于<code>JDK1.4</code>中的<code>LinkedHashMap</code>效率有所提高，它还实现了<code>OrderedMap</code>接口。此外，还提供了非接口方法通过索引来访问Map中的数据。<strong>需要注意的是LinkedMap不是同步的，不是线程安全的</strong>。如果你想使用<code>LinkedMap</code>的同时使用多个线程，您必须使用适当的同步操作。最简单的方法是使用<code>Collections.synchronizedMap(Map)</code>来包装<code>LinkedMap</code>。如果不使用同步操作，当并发线程访问这个类时可能会抛出异常。</p><p>LinkedMap的一些代码示例代码如下：</p><pre><code class="java">/** * 有序map之LinkedMap */private static void linkedMapTest() {    OrderedMap orderMap = this.buildMap(new LinkedMap());    // 获取map中相应的值    System.out.println(&quot;LinkedMap firstKey:&quot; + orderMap.firstKey());    System.out.println(&quot;LinkedMap previous key:&quot; + orderMap.previousKey(&quot;four&quot;));    System.out.println(&quot;LinkedMap next key:&quot; + orderMap.nextKey(&quot;two&quot;));    System.out.println(&quot;LinkedMap last key:&quot; + orderMap.lastKey());    System.out.println(&quot;LinkedMap map Size:&quot; + orderMap.size());}</code></pre><h3 id="3-双向Map之BidiMap"><a href="#3-双向Map之BidiMap" class="headerlink" title="3. 双向Map之BidiMap"></a>3. 双向Map之BidiMap</h3><p>所谓<code>BidiMap</code>，直译就是双向<code>Map</code>，可以通过<code>key</code>找到<code>value</code>，也可以通过<code>value</code>找到<code>key</code>，这在我们日常的代码-名称匹配的时候很方便：因为我们除了需要通过代码找到名称之外，往往也需要处理用户输入的名称，然后获取其代码。需要注意的是BidiMap当中不光key不能重复，value也不可以重复。基本使用示例如下：</p><pre><code class="java">/** * BidiMap,是双向Map * 通过key得到value * 通过value得到key * 注意的是BidiMap,当中不光key不能重复，value也不可以。 */private static void bidiMapTest() {    BidiMap bidiMap = this.buildMap(new TreeBidiMap());    // 有相同值的，只有最后一个生效    bidiMap.put(&quot;san&quot;, &quot;3&quot;);    loopMap(bidiMap, &quot;BidiMap&quot;);    // 获取map中相应的值    System.out.println(&quot;BidiMap getKey:&quot; + bidiMap.getKey(&quot;2&quot;));    System.out.println(&quot;BidiMap getMoreSameKey:&quot; + bidiMap.getKey(&quot;3&quot;));    // 移除map的value    bidiMap.removeValue(&quot;3&quot;);    System.out.println(&quot;BidiMap getMoreSameKey2:&quot; + bidiMap.getKey(&quot;3&quot;));    // 交换map的key和value    BidiMap inversMap = bidiMap.inverseBidiMap();}</code></pre><h3 id="4-多值Map之MultiMap"><a href="#4-多值Map之MultiMap" class="headerlink" title="4. 多值Map之MultiMap"></a>4. 多值Map之MultiMap</h3><p>所谓<code>MultiMap</code>，就是说单个<code>key</code>可以对应多个<code>value</code>,在<code>put</code>或<code>remove</code>时和普通<code>Map</code>没有区别,但当<code>get</code>时将返回多个<code>value</code>,所以返回一个<code>collections</code>,利用<code>MultiMap</code>，我们就可以很方便的往一个<code>key</code>上放数量不定的对象，也就实现了一对多。在3.2.1版本中<code>MultiHashMap</code>已被废除,请使用<code>MultiValueMap</code>。简单的使用示例如下：</p><pre><code class="java">private static void multiMapTest() {    MultiMap multiMap = new MultiValueMap();    multiMap = multibuildMap(multiMap);    multiMap.put(&quot;three&quot;, &quot;5&quot;);    List&lt;String&gt; list = (List&lt;String&gt;) multiMap.get(&quot;three&quot;);    // 会打印: list:[3, 5]    System.out.println(&quot;list:&quot; + list);}</code></pre><h3 id="5-“懒加载”Map之LazyMap"><a href="#5-“懒加载”Map之LazyMap" class="headerlink" title="5. “懒加载”Map之LazyMap"></a>5. “懒加载”Map之LazyMap</h3><p>所谓<code>LazyMap</code>，意思就是这个<code>Map</code>中的键/值对一开始并不存在，当被调用到时才会创建，这样的解释初听上去是不是有点不可思议，这样的<code>LazyMap</code>有用吗？我们这样来理解：我们需要一个<code>Map</code>，但是由于创建成员的方法很“重”（比如数据库访问），或者我们只有在调用<code>get()</code>时才知道如何创建，或者<code>Map</code>中出现的可能性很多很多，我们无法在<code>get()</code>之前添加所有可能出现的键/值对，或者任何其它解释得通的原因，我们觉得没有必要去初始化一个<code>Map</code>而又希望它可以在必要时自动处理数据生成的话，<code>LazyMap</code>就变得很有用了。简单的使用示例如下：</p><pre><code class="java">/** * LazyMap.类似与Hibenrate的懒加载,在声明的时候并不会创建, * 而是在使用(get)的时候,才创建集合的内容,返回Factory的返回值 * 实现懒加载,当我们觉得没有必要去初始化一个Map而又希望它可以在必要时自动处理数据可以使用LazyMap * 有LazyList与LazyMap对应 */private static void lazyMapTest() {    //创建一个工厂，实现create方法    Factory factory = new Factory() {        @Override        public Object create() {            // 创建的默认值            return &quot;这是LazyMap get()不到时创建的默认值&quot;;        }    };    Map lazyMap = LazyMap.decorate(new HashMap(), factory);    System.out.println(&quot;map:&quot; + lazyMap);    //当此lazyMap调用get(key)时，如果无此key则返回varFactory里create方法返回的值    System.out.println(&quot;map:&quot; + lazyMap.get(&quot;hello&quot;));    // 有key对应的值时,返回123    lazyMap.put(&quot;hello&quot;, &quot;123&quot;);    System.out.println(&quot;map:&quot; + lazyMap.get(&quot;hello&quot;));}</code></pre><p><code>Apache Commons Collections</code>中的基本<code>map</code>的接口类型和使用方法，不仅有上面这些，还有很多细分的、拥有不同功能或者各功能会有交叉的<code>map</code>，等着我们在自己工作中去使用挖掘吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8中关于日期和时间API的20个使用示例</title>
      <link href="/2018/09/13/hou-duan/java/java-8-zhong-guan-yu-ri-qi-he-shi-jian-api-de-20-ge-shi-yong-shi-li/"/>
      <url>/2018/09/13/hou-duan/java/java-8-zhong-guan-yu-ri-qi-he-shi-jian-api-de-20-ge-shi-yong-shi-li/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>随着<a href="http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html" target="_blank" rel="noopener"><code>lambda</code></a>表达式、<a href="http://java67.blogspot.sg/2014/04/java-8-stream-api-examples-filter-map.html" target="_blank" rel="noopener">streams</a>以及一系列小优化，Java8推出了全新的日期时间API，在一下的指南中我们将通过一些简单的示例来学习如何使用新API。Java处理日期、日历和时间的方式一直为社区所诟病，将<code>java.util.Date</code>设定为可变类型，以及<a href="http://javarevisited.blogspot.sg/2012/03/simpledateformat-in-java-is-not-thread.html" target="_blank" rel="noopener"><code>SimpleDateFormat</code>的非线程安全</a>使其应用非常受限。<code>Java</code>也意识到需要一个更好的<code>API</code>来满足社区中已经习惯了使用<code>JodaTime API</code>的人们。全新<code>API</code>的众多好处之一就是，明确了日期时间概念，例如：瞬时（instant）、期间（duration）、日期、时间、时区和周期。同时继承了<code>Joda</code>库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新<code>API</code>基于ISO标准日历系统，<code>java.time</code>包下的所有类都是不可变类型而且线程安全。下面是新版API中<code>java.time</code>包里的一些关键类：</p><ul><li><code>Instant</code>：瞬时实例。</li><li><code>LocalDate</code>：本地日期，不包含具体时间。例如：<code>2014-01-14</code>可以用来记录生日、纪念日、加盟日等。</li><li><code>LocalTime</code>：本地时间，不包含日期。</li><li><code>LocalDateTime</code>：组合了日期和时间，但不包含时差和时区信息。</li><li><code>ZonedDateTime</code>：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了<code>ZoneOffSet</code>和<code>ZoneId</code>类，使得解决时区问题更为简便。<a href="http://javarevisited.blogspot.sg/2011/09/step-by-step-guide-to-convert-string-to.html" target="_blank" rel="noopener">解析和格式化时间</a>的<code>DateTimeFormatter</code>类也全部重新设计。<strong>注意，这篇文章是翻译自<a href="http://javarevisited.blogspot.sg/2015/03/20-examples-of-date-and-time-api-from-Java8.html" target="_blank" rel="noopener">Java 8 - 20 Examples of Date and Time API</a>，以下示例代码我做过一些简单的修改，当运行这些例子时会返回你当前的时间</strong>。</p><h2 id="二、在Java8中如何处理日期和时间"><a href="#二、在Java8中如何处理日期和时间" class="headerlink" title="二、在Java8中如何处理日期和时间"></a>二、在Java8中如何处理日期和时间</h2><p>常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探索。这对Java8新日期时间<code>API</code>也不例外。我创建了20个基于任务的实例来学习Java8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单日、保费到期日、信用卡过期日等。</p><h3 id="示例-1、在Java8中获取今天的日期"><a href="#示例-1、在Java8中获取今天的日期" class="headerlink" title="示例 1、在Java8中获取今天的日期"></a>示例 1、在Java8中获取今天的日期</h3><p>Java8中的<code>LocalDate</code>用于表示当天日期。和<code>java.util.Date</code>不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><pre><code class="java">LocalDate today = LocalDate.now();System.out.println(&quot;今天的日期是：&quot; + today);// 今天的日期是：2016-04-18</code></pre><p>上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的<code>Date</code>类打印出一堆没有格式化的信息。</p><h3 id="示例-2、在Java8中获取当前的年、月、日信息"><a href="#示例-2、在Java8中获取当前的年、月、日信息" class="headerlink" title="示例 2、在Java8中获取当前的年、月、日信息"></a>示例 2、在Java8中获取当前的年、月、日信息</h3><p><code>LocalDate</code>类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖<code>java.util.Calendar</code>类了。</p><pre><code class="java">LocalDate today = LocalDate.now();int year = today.getYear();int month = today.getMonthValue();int day = today.getDayOfMonth();System.out.printf(&quot;当前的年 : %d  月 : %d  日 : %d%n&quot;, year, month, day);// 当前的年 : 2016  月 : 4  日 : 18</code></pre><p>看到了吧，在Java8中得到年、月、日信息是这么简单直观，想用就用，没什么需要记的。对比看看以前Java是怎么处理年月日信息的吧。</p><h3 id="示例-3、在Java8中获取特定日期"><a href="#示例-3、在Java8中获取特定日期" class="headerlink" title="示例 3、在Java8中获取特定日期"></a>示例 3、在Java8中获取特定日期</h3><p>在第一个例子里，我们通过静态工厂方法<code>now()</code>非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法<code>LocalDate.of()</code>创建任意日期，该方法需要传入年、月、日做参数，返回对应的<code>LocalDate</code>实例。这个方法的好处是没再犯老<code>API</code>的设计错误，比如年度起始于1900，月份是从0开始等等。日期所见即所得，就像下面这个例子表示了1月14日，没有任何隐藏机关。</p><pre><code class="java">LocalDate dateOfBirth = LocalDate.of(2016, 4, 18);System.out.println(&quot;你的出生日期是：&quot; + dateOfBirth);// 你的出生日期是：2016-04-18</code></pre><p>可以看到创建的日期完全符合预期，与你写入的2016年4月18日完全一致。</p><h3 id="示例-4、在Java8中判断两个日期是否相等"><a href="#示例-4、在Java8中判断两个日期是否相等" class="headerlink" title="示例 4、在Java8中判断两个日期是否相等"></a>示例 4、在Java8中判断两个日期是否相等</h3><p>现实生活中有一类时间处理就是判断两个日期是否相等。你常常会检查今天是不是个特殊的日子，比如生日、纪念日或非交易日。这时就需要把指定的日期与某个特定日期做比较，例如判断这一天是否是假期。下面这个例子会帮助你用Java8的方式去解决，你肯定已经想到了，<code>LocalDate</code>重载了<code>equal</code>方法，请看下面的例子：</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate date1 = LocalDate.of(2016, 4, 18);if (date1.equals(today)) {    System.out.printf(&quot;今天 %s 和 date1 %s 是同一天!%n&quot;, today, date1);}// 今天 2016-04-18 和 date1 2016-04-18 是同一天!</code></pre><p>这个例子中我们比较的两个日期相同。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。对比<a href="http://javarevisited.blogspot.sg/2012/02/3-example-to-compare-two-dates-in-java.html" target="_blank" rel="noopener"><code>Java</code>老的日期比较方式</a>，你会感到清风拂面。</p><h3 id="示例-5、在Java8中检查像生日这种周期性事件"><a href="#示例-5、在Java8中检查像生日这种周期性事件" class="headerlink" title="示例 5、在Java8中检查像生日这种周期性事件"></a>示例 5、在Java8中检查像生日这种周期性事件</h3><p><code>Java</code>中另一个日期时间的处理就是检查类似每月账单、结婚纪念日、EMI日或保险缴费日这些周期性事件。如果你在电子商务网站工作，那么一定会有一个模块用来在圣诞节、感恩节这种节日时向客户发送问候邮件。<code>Java</code>中如何检查这些节日或其它周期性事件呢？答案就是<code>MonthDay</code>类。这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个<code>YearMonth</code>类。这些类也都是不可变并且线程安全的值类型。下面我们通过<code>MonthDay</code>来检查周期性事件：</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate dateOfBirth = LocalDate.of(2016, 4, 18);MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());MonthDay currentMonthDay = MonthDay.from(today);if(currentMonthDay.equals(birthday)){    System.out.println(&quot;好高兴今天是您的生日!!&quot;);}else{    System.out.println(&quot;对不起，今天不是您的生日!!&quot;);}// 好高兴今天是您的生日!!</code></pre><p>只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。</p><h3 id="示例-6、在Java8中获取当前时间"><a href="#示例-6、在Java8中获取当前时间" class="headerlink" title="示例 6、在Java8中获取当前时间"></a>示例 6、在Java8中获取当前时间</h3><p>与Java8获取日期的例子很像，获取时间使用的是<code>LocalTime</code>类，一个只有时间没有日期的<code>LocalDate</code>的近亲。可以调用静态工厂方法<code>now()</code>来获取当前时间。默认的格式是<code>hh:mm:ss:nnn</code>。对比一下<a href="http://javarevisited.blogspot.sg/2012/01/get-current-date-timestamps-java.html" target="_blank" rel="noopener">Java8之前获取当前时间的方式</a>。</p><pre><code class="java">LocalTime time = LocalTime.now();System.out.println(&quot;当前时间是:&quot; + time);// 当前时间是:23:43:42.200</code></pre><p>可以看到当前时间就只包含时间信息，没有日期。</p><h3 id="示例-7、如何在现有的时间上增加小时"><a href="#示例-7、如何在现有的时间上增加小时" class="headerlink" title="示例 7、如何在现有的时间上增加小时"></a>示例 7、如何在现有的时间上增加小时</h3><p>通过增加小时、分、秒来计算将来的时间很常见。Java8除了不变类型和线程安全的好处之外，还提供了更好的<code>plusHours()</code>方法替换<code>add()</code>，并且是兼容的。注意，这些方法返回一个全新的<code>LocalTime</code>实例，由于其不可变性，返回后一定要用变量赋值。</p><pre><code class="java">LocalTime time = LocalTime.now();LocalTime newTime = time.plusHours(2); // 添加两小时System.out.println(&quot;当前时间:&quot; + time + &quot;,两小时后的时间: &quot; +  newTime);// 当前时间:23:50:56.195,两小时后的时间: 01:50:56.195</code></pre><p>可以看到，新的时间在当前时间<code>23:50:56.195</code>的基础上增加了2个小时。和<a href="http://javarevisited.blogspot.sg/2012/12/how-to-add-subtract-days-months-years-to-date-time-java.html" target="_blank" rel="noopener">旧版<code>Java</code>的增减时间的处理方式</a>对比一下，看看哪种更好。</p><h3 id="示例-8、如何计算一周后的日期"><a href="#示例-8、如何计算一周后的日期" class="headerlink" title="示例 8、如何计算一周后的日期"></a>示例 8、如何计算一周后的日期</h3><p>和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。<code>LocalDate</code>日期不包含时间信息，它的<code>plus()</code>方法用来增加天、周、月，<code>ChronoUnit</code>类声明了这些时间单位。由于<code>LocalDate</code>也是不变类型，返回后一定要用变量赋值。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);System.out.println(&quot;今天是:&quot; + today + &quot;,一周以后的日期: &quot; + nextWeek);// 今天是:2016-04-18,一周以后的日期: 2016-04-25</code></pre><p>可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看<code>Java 8 API</code>中<code>的ChronoUnit</code>类。</p><h3 id="示例-9、计算一年前或一年后的日期"><a href="#示例-9、计算一年前或一年后的日期" class="headerlink" title="示例 9、计算一年前或一年后的日期"></a>示例 9、计算一年前或一年后的日期</h3><p>继续上面的例子，上个例子中我们通过<code>LocalDate</code>的<code>plus()</code>方法增加天数、周数或月数，这个例子我们利用<code>minus()</code>方法计算一年前的日期。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate preYear = today.minus(1, ChronoUnit.YEARS);LocalDate nextYear = today.plus(1, ChronoUnit.YEARS);System.out.println(&quot;今天是:&quot; + today + &quot;,一年前的日期: &quot; + preYear + &quot;,一年后的日期: &quot; + nextYear);// 今天是:2016-04-18,一年前的日期: 2015-04-18,一年后的日期: 2017-04-18</code></pre><p>例子结果中得到了两个日期，一个2015年、一个2017年、分别是2016年的前一年和后一年。</p><h3 id="示例-10、使用Java8的Clock时钟类"><a href="#示例-10、使用Java8的Clock时钟类" class="headerlink" title="示例 10、使用Java8的Clock时钟类"></a>示例 10、使用Java8的Clock时钟类</h3><p>Java8增加了一个<code>Clock</code>时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到<code>System.currentTimeInMillis()</code>和<code>TimeZone.getDefault()</code>的地方都可用<code>Clock</code>替换。</p><pre><code class="java">// 得到UTC的时区的日期时间clock对象Clock clock = Clock.systemUTC();System.out.println(&quot;Clock : &quot; + clock);// Clock : SystemClock[Z]// 得到基于当前时区的日期时间clock对象Clock defaultClock = Clock.systemDefaultZone();System.out.println(&quot;Clock : &quot; + clock);// Clock : SystemClock[Z]</code></pre><p>还可以针对clock时钟做比较，像下面这个例子：</p><pre><code class="java">public class MyClass {    // 依赖注入    private Clock clock;    ...    public void process(LocalDate eventDate) {        if (eventDate.isBefore(LocalDate.now(clock)) {            ...        }    }}</code></pre><p>这种方式在不同时区下处理日期时会非常管用。</p><h3 id="示例-11、如何用Java判断日期是早于还是晚于另一个日期"><a href="#示例-11、如何用Java判断日期是早于还是晚于另一个日期" class="headerlink" title="示例 11、如何用Java判断日期是早于还是晚于另一个日期"></a>示例 11、如何用Java判断日期是早于还是晚于另一个日期</h3><p>另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java8中，<code>LocalDate</code>类有两类方法<code>isBefore()</code>和<code>isAfter()</code>用于比较日期。调用<code>isBefore()</code>方法时，如果给定日期小于当前日期则返回<code>true</code>。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate tomorrow = LocalDate.of(2016, 4, 19);if (tomorrow.isAfter(today)) {    System.out.println(&quot;明天晚于今天！&quot;);}// 明天晚于今天！LocalDate yesterday = today.minus(1, ChronoUnit.DAYS);if (yesterday.isBefore(today)) {    System.out.println(&quot;昨天先于今天！&quot;);}// 昨天先于今天！</code></pre><p>在Java 8中比较日期非常方便，不需要使用额外的<code>Calendar</code>类来做这些基础工作了。</p><h3 id="示例-12、在Java8中处理时区"><a href="#示例-12、在Java8中处理时区" class="headerlink" title="示例 12、在Java8中处理时区"></a>示例 12、在Java8中处理时区</h3><p>Java8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如<code>ZoneId</code>来处理特定时区，<code>ZoneDateTime</code>类来表示某时区下的时间。这在Java8以前都是<a href="http://javarevisited.blogspot.sg/2013/02/convert-xmlgregoriancalendar-to-date-xmlgregoriancalendar-java-example-tutorial.html" target="_blank" rel="noopener"><code>GregorianCalendar</code>类</a>来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p><pre><code class="java">// Java 8中某时区下的日期和时间ZoneId america = ZoneId.of(&quot;America/New_York&quot;);LocalDateTime localtDateAndTime = LocalDateTime.now();ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );System.out.println(&quot;Current date and time in a particular timezone : &quot; + dateAndTimeInNewYork);// Current date and time in a particular timezone : 2016-04-19T23:10:09.251-04:00[America/New_York]</code></pre><p>和以前<a href="http://javarevisited.blogspot.sg/2012/04/how-to-convert-local-time-to-gmt-in.html" target="_blank" rel="noopener">使用<code>GMT</code>的方式转换本地时间</a>对比一下。注意，在Java8以前，一定要牢牢记住时区的名称，不然就会抛出下面的异常：</p><pre><code class="java">Exception in thread &quot;main&quot; java.time.zone.ZoneRulesException: Unknown time-zone ID: ASIA/Tokyo        at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:272)        at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)        at java.time.ZoneRegion.ofId(ZoneRegion.java:120)        at java.time.ZoneId.of(ZoneId.java:403)        at java.time.ZoneId.of(ZoneId.java:351)</code></pre><h3 id="示例-13、如何表示信用卡到期这类固定日期，答案就在YearMonth"><a href="#示例-13、如何表示信用卡到期这类固定日期，答案就在YearMonth" class="headerlink" title="示例 13、如何表示信用卡到期这类固定日期，答案就在YearMonth"></a>示例 13、如何表示信用卡到期这类固定日期，答案就在<code>YearMonth</code></h3><p>与<code>MonthDay</code>检查重复事件的例子相似，<code>YearMonth</code>是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，<code>YearMonth</code>实例的<code>lengthOfMonth()</code>方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><pre><code class="java">YearMonth currentYearMonth = YearMonth.now();System.out.printf(&quot;该月的天数 %s: %d%n&quot;, currentYearMonth, currentYearMonth.lengthOfMonth());// 该月的天数 2016-04: 30YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY);System.out.printf(&quot;您的信用卡到期是： %s%n&quot;, creditCardExpiry);// 您的信用卡到期是： 2018-02</code></pre><p>根据上述数据，你可以提醒客户信用卡快要到期了，个人认为这个类非常有用。</p><h3 id="示例-14、如何在Java8中检查闰年"><a href="#示例-14、如何在Java8中检查闰年" class="headerlink" title="示例 14、如何在Java8中检查闰年"></a>示例 14、如何在Java8中检查闰年</h3><p><code>LocalDate</code>类有一个很实用的方法<code>isLeapYear()</code>判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，纯<a href="http://java67.blogspot.sg/2012/12/how-to-check-leap-year-in-java-program.html" target="_blank" rel="noopener">Java逻辑编写的判断闰年</a>的程序。</p><pre><code class="java">LocalDate today = LocalDate.now();if (today.isLeapYear()) {    System.out.println(&quot;今年是闰年！&quot;);} else {    System.out.println(&quot;今年不是闰年！&quot;);}// 今年是闰年！</code></pre><p>你可以多写几个日期来验证是否是闰年，最好是写<code>JUnit</code>单元测试做判断。</p><h3 id="示例-15、计算两个日期之间的天数和月数"><a href="#示例-15、计算两个日期之间的天数和月数" class="headerlink" title="示例 15、计算两个日期之间的天数和月数"></a>示例 15、计算两个日期之间的天数和月数</h3><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java8中可以用<code>java.time.Period</code>类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate java8Release = LocalDate.of(2016, Month.APRIL, 21);Period periodToNext = Period.between(today, java8Release);System.out.println(&quot;2016年4月21日距离今天的天数：&quot; + periodToNext.getDays() );// 2016年4月21日距离今天的天数：3</code></pre><p>从上面可以看到现在是一月，Java8的中计算的当前日期是4月18日，中间相隔3天。</p><h3 id="示例-16、包含时差信息的日期和时间"><a href="#示例-16、包含时差信息的日期和时间" class="headerlink" title="示例 16、包含时差信息的日期和时间"></a>示例 16、包含时差信息的日期和时间</h3><p>在Java8中，<code>ZoneOffset</code>类用来表示时区，举例来说印度与GMT或UTC标准时区相差<code>+05:30</code>，可以通过<code>ZoneOffset.of()</code>静态方法来 获取对应的时区。一旦得到了时差就可以通过传入<code>LocalDateTime</code>和<code>ZoneOffset</code>来创建一个<code>OffSetDateTime</code>对象。</p><pre><code class="java">LocalDateTime datetime = LocalDateTime.of(2016, Month.APRIL, 19, 23, 35);ZoneOffset offset = ZoneOffset.of(&quot;+05:30&quot;);OffsetDateTime date = OffsetDateTime.of(datetime, offset);System.out.println(&quot;包含时差信息的日期和时间 : &quot; + date);//包含时差信息的日期和时间 : 2016-04-19T23:35+05:30</code></pre><p>现在的时间信息里已经包含了时区信息了。注意：<code>OffSetDateTime</code>是对计算机友好的，<code>ZoneDateTime</code>则对人更友好。</p><h3 id="示例-17、在Java8中获取当前的时间戳"><a href="#示例-17、在Java8中获取当前的时间戳" class="headerlink" title="示例 17、在Java8中获取当前的时间戳"></a>示例 17、在Java8中获取当前的时间戳</h3><p>如果你还记得Java8以前是如何获得当前时间戳，那么现在你终于解脱了。<code>Instant</code>类有一个静态工厂方法<code>now()</code>会返回当前的时间戳，如下所示：</p><pre><code class="java">Instant timestamp = Instant.now();System.out.println(&quot;时间戳是：&quot; + timestamp);// 时间戳是：2016-04-18T15:41:06.876Z</code></pre><p>时间戳信息里同时包含了日期和时间，这和<code>java.util.Date</code>很像。实际上<code>Instant</code>类确实等同于Java8之前的<code>Date</code>类，你可以使用<code>Date</code>类和<code>Instant</code>类各自的转换方法互相转换，例如：<code>Date.from(Instant)</code> 将<code>Instant</code>转换成<code>java.util.Date</code>，<code>Date.toInstant()</code>则是将<code>Date</code>类转换成<code>Instant</code>类。</p><h3 id="示例-18、在Java8中如何使用预定义的格式化工具去解析或格式化日期"><a href="#示例-18、在Java8中如何使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期"></a>示例 18、在Java8中如何使用预定义的格式化工具去解析或格式化日期</h3><p>在Java8以前的世界里，日期和时间的格式化非常诡异，唯一的帮助类<code>SimpleDateFormat</code>也是非线程安全的，而且用作局部变量解析和格式化日期时显得很笨重。幸好线程局部变量能使它在多线程环境中变得可用，不过这都是过去时了。Java8引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了<code>BASIC_ISO_DATE</code>格式化工具将2016年4月18日格式化成20160418。</p><pre><code class="java">String day = &quot;20160418&quot;;LocalDate formatted = LocalDate.parse(day, DateTimeFormatter.BASIC_ISO_DATE);System.out.printf(&quot;从字符串中解析的日期: %s 是 %s %n&quot;, day, formatted);// 从字符串中解析的日期: 20160418 是 2016-04-18 </code></pre><p>很明显的看出得到的日期和给出的日期是同一天，但是格式不同。</p><h3 id="示例-19、如何在Java中使用自定义格式化工具解析日期"><a href="#示例-19、如何在Java中使用自定义格式化工具解析日期" class="headerlink" title="示例 19、如何在Java中使用自定义格式化工具解析日期"></a>示例 19、如何在Java中使用自定义格式化工具解析日期</h3><p>上个例子使用了<a href="http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html" target="_blank" rel="noopener"><code>Java</code>内置的格式化工具</a>去解析日期字符串。尽管内置格式化工具很好用，有时还是需要定义特定的日期格式，下面这个例子展示了如何创建自定义日期格式化工具。例子中的日期格式是“MMM dd yyyy”。可以调用<code>DateTimeFormatter</code>的<code>ofPattern()</code>静态方法并传入任意格式返回其实例，格式中的字符和以前代表的一样，M代表月，m代表分。如果格式不规范会抛出<code>DateTimeParseException</code>异常，不过如果只是把M写成m这种逻辑错误是不会抛异常的。</p><pre><code class="java">String day = &quot;2016 04 18&quot;;try {    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);    LocalDate holiday = LocalDate.parse(day, formatter);    System.out.printf(&quot;成功解析字符串：%s, 时间是：%s%n&quot;, day, holiday);} catch (DateTimeParseException ex) {    System.out.printf(&quot;%s 解析失败!&quot;, day);    ex.printStackTrace();}// 成功解析字符串：2016 04 18, 时间是：2016-04-18</code></pre><p>日期值与传入的字符串是匹配的，只是格式不同而已。</p><h3 id="示例-20、在Java8中如何把日期转换成字符串"><a href="#示例-20、在Java8中如何把日期转换成字符串" class="headerlink" title="示例 20、在Java8中如何把日期转换成字符串"></a>示例 20、在Java8中如何把日期转换成字符串</h3><p>上 两个例子都用到了<code>DateTimeFormatter</code>类，主要是从字符串解析日期。现在我们反过来，把<code>LocalDateTime</code>日期实例转换成特定格式的字符串。这是迄今为止<a href="http://java67.blogspot.sg/2013/01/how-to-format-date-in-java-simpledateformat-example.html" target="_blank" rel="noopener"><code>Java</code>日期转字符串最为简单的方式</a>了。下面的例子将返回一个代表日期的格式化字符串。和前面类似，还是需要创建<code>DateTimeFormatter</code>实例并传入格式，但这回调用的是<code>format()</code>方法，而非<code>parse()</code>方法。这个方法会把传入的日期转化成指定格式的字符串。</p><pre><code class="java">LocalDateTime arrivalDate  = LocalDateTime.now();try {    DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;MMM dd yyyy  hh:mm a&quot;);    String landing = arrivalDate.format(format);    System.out.printf(&quot;格式化的日期时间:  %s %n&quot;, landing);} catch (DateTimeException ex) {    System.out.printf(&quot;%s 不能格式化!%n&quot;, arrivalDate);    ex.printStackTrace();}// 格式化的日期时间:  四月 19 2016  12:02 上午</code></pre><p>当前时间被指定的“MMM dd yyyy hh:mm a”格式格式化，格式包含3个代表月的字符串，时间后面带有AM和PM标记。</p><h2 id="Java-8日期时间API的重点"><a href="#Java-8日期时间API的重点" class="headerlink" title="Java 8日期时间API的重点"></a>Java 8日期时间API的重点</h2><p>通过这些例子，你肯定已经掌握了Java8日期时间API的新知识点。现在我们来回顾一下这个优雅<code>API</code>的使用要点：</p><ol><li>提供了<code>javax.time.ZoneId</code>获取时区。</li><li>提供了<code>LocalDate`</code>和LocalTime`类。</li><li>Java8的所有日期和时间<code>API</code>都是不可变类并且线程安全，而现有的<code>Date</code>和<code>Calendar</code> API中的<code>java.util.Date</code>和<code>SimpleDateFormat</code>是非线程安全的。</li><li>主包是<code>java.time</code>,包含了表示日期、时间、时间间隔的一些类。里面有两个子包<code>java.time.format</code>用于格式化， <code>java.time.temporal</code>用于更底层的操作。</li><li>时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或<code>UTC</code>的时差。例如：东京的时差是+09:00。</li><li><code>OffsetDateTime</code>类实际上组合了<code>LocalDateTime</code>类和<code>ZoneOffset</code>类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。</li><li><code>DateTimeFormatter</code>类用来格式化和解析时间。与<code>SimpleDateFormat</code>不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。<code>DateTimeFormatter</code>类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了<code>parse()</code>将字符串解析成日期，如果解析出错会抛出<code>DateTimeParseException</code>。<code>DateTimeFormatter</code>类同时还有<code>format()</code>用来格式化日期，如果出错会抛出<code>DateTimeException</code>异常。</li><li>再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。</li></ol><p>如何使用Java8的全新日期时间API就介绍到这了。这些简单的例子对帮助理解新API非常有用。由于这些例子都基于真实任务，你在做<code>Java</code>日期编程时不用再东张西望了。我们学会了如何创建并操作日期实例，学习了纯日期、以及包含时间信息和时差信息的日期、学会了怎样计算两个日期的间隔，这些在计算当天与某个特定日期间隔的例子中都有所展示。 我们还学到了在Java8中如何线程安全地解析和格式化日期，不用再使用蹩脚的线程局部变量技巧，也不用依赖<code>Joda Time</code>第三方库。新<code>API</code>可以作为处理日期时间操作的标准。</p><p>如果你喜欢这个教程并希望看到更多关于Java 8的教程，下面这些精彩的文章都值得一看：</p><ul><li>如何在Java8中用一行代码搞定文件读取？(<a href="http://javarevisited.blogspot.sg/2015/02/how-to-read-file-in-one-line-java-8.html" target="_blank" rel="noopener">示例</a>)</li><li>学习Java8的十大教程（<a href="http://java67.blogspot.sg/2014/09/top-10-java-8-tutorials-best-of-lot.html" target="_blank" rel="noopener">教程</a>）</li><li>免费的Java8教程和图书 （<a href="http://javarevisited.blogspot.sg/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">资源</a>）</li><li>Java 8 <code>Comparator</code>例子 （<a href="http://java67.blogspot.com/2014/11/java-8-comparator-example-using-lambda-expression.html" target="_blank" rel="noopener">示例</a>）</li><li>如何使用Java8的<code>Map</code>函数（<a href="http://java67.blogspot.sg/2015/01/java-8-map-function-examples.html" target="_blank" rel="noopener">示例</a>）</li><li>你准备好学习Java8的认证了吗 （<a href="http://javarevisited.blogspot.sg/2014/09/latest-OCPJP-exam-java-8-certification-oracle-java-se-8.html" target="_blank" rel="noopener">更多</a>）</li><li>如何使用Java8的默认方法。（<a href="http://javarevisited.blogspot.sg/2014/07/default-defender-or-extension-method-of-Java8-example-tutorial.html" target="_blank" rel="noopener">看这里</a>）</li><li>开始Java8之前需要温习的十个<code>Java 7</code>特性（<a href="http://javarevisited.blogspot.sg/2014/04/10-jdk-7-features-to-revisit-before-you.html" target="_blank" rel="noopener">更多</a>）</li><li>Java8学习<code>Stream API</code>十例（<a href="http://javarevisited.blogspot.sg/2014/03/2-examples-of-streams-with-Java8-collections.html" target="_blank" rel="noopener">示例</a>）</li><li>如何在匿名类中使用<code>Lambda</code>表达式（<a href="http://javarevisited.blogspot.sg/2015/01/how-to-use-lambda-expression-in-place-anonymous-class-java8.html" target="_blank" rel="noopener">答案</a>）</li><li>如何使用Java8的<code>Predicates</code>类过滤<code>Collection</code>？（<a href="http://javarevisited.blogspot.sg/2015/02/how-to-filter-collections-in-java-8.html" target="_blank" rel="noopener">答案</a>）</li><li><code>Java</code>中如何随即访问文件？（<a href="http://javarevisited.blogspot.sg/2015/02/randomaccessfile-example-in-java-read-write-String.html" target="_blank" rel="noopener">答案</a>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/12/hello-world/"/>
      <url>/2018/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
